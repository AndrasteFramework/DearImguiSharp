// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace ImGui
{
    public enum ImGuiNavLayer
    {
        ImGuiNavLayerMain = 0,
        ImGuiNavLayerMenu = 1,
        ImGuiNavLayerCOUNT = 2
    }

    public enum ImGuiInputSource
    {
        ImGuiInputSourceNone = 0,
        ImGuiInputSourceMouse = 1,
        ImGuiInputSourceNav = 2,
        ImGuiInputSourceNavKeyboard = 3,
        ImGuiInputSourceNavGamepad = 4,
        ImGuiInputSourceCOUNT = 5
    }

    public enum ImGuiNavForward
    {
        ImGuiNavForwardNone = 0,
        ImGuiNavForwardForwardQueued = 1,
        ImGuiNavForwardForwardActive = 2
    }

    public enum ImGuiLogType
    {
        ImGuiLogTypeNone = 0,
        ImGuiLogTypeTTY = 1,
        ImGuiLogTypeFile = 2,
        ImGuiLogTypeBuffer = 3,
        ImGuiLogTypeClipboard = 4
    }

    public enum ImGuiWindowFlags
    {
        ImGuiWindowFlagsNone = 0,
        ImGuiWindowFlagsNoTitleBar = 1,
        ImGuiWindowFlagsNoResize = 2,
        ImGuiWindowFlagsNoMove = 4,
        ImGuiWindowFlagsNoScrollbar = 8,
        ImGuiWindowFlagsNoScrollWithMouse = 16,
        ImGuiWindowFlagsNoCollapse = 32,
        ImGuiWindowFlagsAlwaysAutoResize = 64,
        ImGuiWindowFlagsNoBackground = 128,
        ImGuiWindowFlagsNoSavedSettings = 256,
        ImGuiWindowFlagsNoMouseInputs = 512,
        ImGuiWindowFlagsMenuBar = 1024,
        ImGuiWindowFlagsHorizontalScrollbar = 2048,
        ImGuiWindowFlagsNoFocusOnAppearing = 4096,
        ImGuiWindowFlagsNoBringToFrontOnFocus = 8192,
        ImGuiWindowFlagsAlwaysVerticalScrollbar = 16384,
        ImGuiWindowFlagsAlwaysHorizontalScrollbar = 32768,
        ImGuiWindowFlagsAlwaysUseWindowPadding = 65536,
        ImGuiWindowFlagsNoNavInputs = 262144,
        ImGuiWindowFlagsNoNavFocus = 524288,
        ImGuiWindowFlagsUnsavedDocument = 1048576,
        ImGuiWindowFlagsNoNav = 786432,
        ImGuiWindowFlagsNoDecoration = 43,
        ImGuiWindowFlagsNoInputs = 786944,
        ImGuiWindowFlagsNavFlattened = 8388608,
        ImGuiWindowFlagsChildWindow = 16777216,
        ImGuiWindowFlagsTooltip = 33554432,
        ImGuiWindowFlagsPopup = 67108864,
        ImGuiWindowFlagsModal = 134217728,
        ImGuiWindowFlagsChildMenu = 268435456
    }

    [Flags]
    public enum ImGuiInputTextFlags
    {
        ImGuiInputTextFlagsNone = 0,
        ImGuiInputTextFlagsCharsDecimal = 1,
        ImGuiInputTextFlagsCharsHexadecimal = 2,
        ImGuiInputTextFlagsCharsUppercase = 4,
        ImGuiInputTextFlagsCharsNoBlank = 8,
        ImGuiInputTextFlagsAutoSelectAll = 16,
        ImGuiInputTextFlagsEnterReturnsTrue = 32,
        ImGuiInputTextFlagsCallbackCompletion = 64,
        ImGuiInputTextFlagsCallbackHistory = 128,
        ImGuiInputTextFlagsCallbackAlways = 256,
        ImGuiInputTextFlagsCallbackCharFilter = 512,
        ImGuiInputTextFlagsAllowTabInput = 1024,
        ImGuiInputTextFlagsCtrlEnterForNewLine = 2048,
        ImGuiInputTextFlagsNoHorizontalScroll = 4096,
        ImGuiInputTextFlagsAlwaysInsertMode = 8192,
        ImGuiInputTextFlagsReadOnly = 16384,
        ImGuiInputTextFlagsPassword = 32768,
        ImGuiInputTextFlagsNoUndoRedo = 65536,
        ImGuiInputTextFlagsCharsScientific = 131072,
        ImGuiInputTextFlagsCallbackResize = 262144,
        ImGuiInputTextFlagsMultiline = 1048576,
        ImGuiInputTextFlagsNoMarkEdited = 2097152
    }

    public enum ImGuiTreeNodeFlags
    {
        ImGuiTreeNodeFlagsNone = 0,
        ImGuiTreeNodeFlagsSelected = 1,
        ImGuiTreeNodeFlagsFramed = 2,
        ImGuiTreeNodeFlagsAllowItemOverlap = 4,
        ImGuiTreeNodeFlagsNoTreePushOnOpen = 8,
        ImGuiTreeNodeFlagsNoAutoOpenOnLog = 16,
        ImGuiTreeNodeFlagsDefaultOpen = 32,
        ImGuiTreeNodeFlagsOpenOnDoubleClick = 64,
        ImGuiTreeNodeFlagsOpenOnArrow = 128,
        ImGuiTreeNodeFlagsLeaf = 256,
        ImGuiTreeNodeFlagsBullet = 512,
        ImGuiTreeNodeFlagsFramePadding = 1024,
        ImGuiTreeNodeFlagsSpanAvailWidth = 2048,
        ImGuiTreeNodeFlagsSpanFullWidth = 4096,
        ImGuiTreeNodeFlagsNavLeftJumpsBackHere = 8192,
        ImGuiTreeNodeFlagsCollapsingHeader = 26
    }

    [Flags]
    public enum ImGuiSelectableFlags
    {
        ImGuiSelectableFlagsNone = 0,
        ImGuiSelectableFlagsDontClosePopups = 1,
        ImGuiSelectableFlagsSpanAllColumns = 2,
        ImGuiSelectableFlagsAllowDoubleClick = 4,
        ImGuiSelectableFlagsDisabled = 8,
        ImGuiSelectableFlagsAllowItemOverlap = 16
    }

    public enum ImGuiComboFlags
    {
        ImGuiComboFlagsNone = 0,
        ImGuiComboFlagsPopupAlignLeft = 1,
        ImGuiComboFlagsHeightSmall = 2,
        ImGuiComboFlagsHeightRegular = 4,
        ImGuiComboFlagsHeightLarge = 8,
        ImGuiComboFlagsHeightLargest = 16,
        ImGuiComboFlagsNoArrowButton = 32,
        ImGuiComboFlagsNoPreview = 64,
        ImGuiComboFlagsHeightMask = 30
    }

    public enum ImGuiTabBarFlags
    {
        ImGuiTabBarFlagsNone = 0,
        ImGuiTabBarFlagsReorderable = 1,
        ImGuiTabBarFlagsAutoSelectNewTabs = 2,
        ImGuiTabBarFlagsTabListPopupButton = 4,
        ImGuiTabBarFlagsNoCloseWithMiddleMouseButton = 8,
        ImGuiTabBarFlagsNoTabListScrollingButtons = 16,
        ImGuiTabBarFlagsNoTooltip = 32,
        ImGuiTabBarFlagsFittingPolicyResizeDown = 64,
        ImGuiTabBarFlagsFittingPolicyScroll = 128,
        ImGuiTabBarFlagsFittingPolicyMask = 192,
        ImGuiTabBarFlagsFittingPolicyDefault = 64
    }

    [Flags]
    public enum ImGuiTabItemFlags
    {
        ImGuiTabItemFlagsNone = 0,
        ImGuiTabItemFlagsUnsavedDocument = 1,
        ImGuiTabItemFlagsSetSelected = 2,
        ImGuiTabItemFlagsNoCloseWithMiddleMouseButton = 4,
        ImGuiTabItemFlagsNoPushId = 8
    }

    public enum ImGuiFocusedFlags
    {
        ImGuiFocusedFlagsNone = 0,
        ImGuiFocusedFlagsChildWindows = 1,
        ImGuiFocusedFlagsRootWindow = 2,
        ImGuiFocusedFlagsAnyWindow = 4,
        ImGuiFocusedFlagsRootAndChildWindows = 3
    }

    public enum ImGuiHoveredFlags
    {
        ImGuiHoveredFlagsNone = 0,
        ImGuiHoveredFlagsChildWindows = 1,
        ImGuiHoveredFlagsRootWindow = 2,
        ImGuiHoveredFlagsAnyWindow = 4,
        ImGuiHoveredFlagsAllowWhenBlockedByPopup = 8,
        ImGuiHoveredFlagsAllowWhenBlockedByActiveItem = 32,
        ImGuiHoveredFlagsAllowWhenOverlapped = 64,
        ImGuiHoveredFlagsAllowWhenDisabled = 128,
        ImGuiHoveredFlagsRectOnly = 104,
        ImGuiHoveredFlagsRootAndChildWindows = 3
    }

    public enum ImGuiDragDropFlags
    {
        ImGuiDragDropFlagsNone = 0,
        ImGuiDragDropFlagsSourceNoPreviewTooltip = 1,
        ImGuiDragDropFlagsSourceNoDisableHover = 2,
        ImGuiDragDropFlagsSourceNoHoldToOpenOthers = 4,
        ImGuiDragDropFlagsSourceAllowNullID = 8,
        ImGuiDragDropFlagsSourceExtern = 16,
        ImGuiDragDropFlagsSourceAutoExpirePayload = 32,
        ImGuiDragDropFlagsAcceptBeforeDelivery = 1024,
        ImGuiDragDropFlagsAcceptNoDrawDefaultRect = 2048,
        ImGuiDragDropFlagsAcceptNoPreviewTooltip = 4096,
        ImGuiDragDropFlagsAcceptPeekOnly = 3072
    }

    public enum ImGuiDataType
    {
        ImGuiDataTypeS8 = 0,
        ImGuiDataTypeU8 = 1,
        ImGuiDataTypeS16 = 2,
        ImGuiDataTypeU16 = 3,
        ImGuiDataTypeS32 = 4,
        ImGuiDataTypeU32 = 5,
        ImGuiDataTypeS64 = 6,
        ImGuiDataTypeU64 = 7,
        ImGuiDataTypeFloat = 8,
        ImGuiDataTypeDouble = 9,
        ImGuiDataTypeCOUNT = 10
    }

    public enum ImGuiDir
    {
        ImGuiDirNone = -1,
        ImGuiDirLeft = 0,
        ImGuiDirRight = 1,
        ImGuiDirUp = 2,
        ImGuiDirDown = 3,
        ImGuiDirCOUNT = 4
    }

    public enum ImGuiKey
    {
        ImGuiKeyTab = 0,
        ImGuiKeyLeftArrow = 1,
        ImGuiKeyRightArrow = 2,
        ImGuiKeyUpArrow = 3,
        ImGuiKeyDownArrow = 4,
        ImGuiKeyPageUp = 5,
        ImGuiKeyPageDown = 6,
        ImGuiKeyHome = 7,
        ImGuiKeyEnd = 8,
        ImGuiKeyInsert = 9,
        ImGuiKeyDelete = 10,
        ImGuiKeyBackspace = 11,
        ImGuiKeySpace = 12,
        ImGuiKeyEnter = 13,
        ImGuiKeyEscape = 14,
        ImGuiKeyKeyPadEnter = 15,
        ImGuiKeyA = 16,
        ImGuiKeyC = 17,
        ImGuiKeyV = 18,
        ImGuiKeyX = 19,
        ImGuiKeyY = 20,
        ImGuiKeyZ = 21,
        ImGuiKeyCOUNT = 22
    }

    public enum ImGuiNavInput
    {
        ImGuiNavInputActivate = 0,
        ImGuiNavInputCancel = 1,
        ImGuiNavInputInput = 2,
        ImGuiNavInputMenu = 3,
        ImGuiNavInputDpadLeft = 4,
        ImGuiNavInputDpadRight = 5,
        ImGuiNavInputDpadUp = 6,
        ImGuiNavInputDpadDown = 7,
        ImGuiNavInputLStickLeft = 8,
        ImGuiNavInputLStickRight = 9,
        ImGuiNavInputLStickUp = 10,
        ImGuiNavInputLStickDown = 11,
        ImGuiNavInputFocusPrev = 12,
        ImGuiNavInputFocusNext = 13,
        ImGuiNavInputTweakSlow = 14,
        ImGuiNavInputTweakFast = 15,
        ImGuiNavInputKeyMenu = 16,
        ImGuiNavInputKeyLeft = 17,
        ImGuiNavInputKeyRight = 18,
        ImGuiNavInputKeyUp = 19,
        ImGuiNavInputKeyDown = 20,
        ImGuiNavInputCOUNT = 21,
        ImGuiNavInputInternalStart = 16
    }

    [Flags]
    public enum ImGuiConfigFlags
    {
        ImGuiConfigFlagsNone = 0,
        ImGuiConfigFlagsNavEnableKeyboard = 1,
        ImGuiConfigFlagsNavEnableGamepad = 2,
        ImGuiConfigFlagsNavEnableSetMousePos = 4,
        ImGuiConfigFlagsNavNoCaptureKeyboard = 8,
        ImGuiConfigFlagsNoMouse = 16,
        ImGuiConfigFlagsNoMouseCursorChange = 32,
        ImGuiConfigFlagsIsSRGB = 1048576,
        ImGuiConfigFlagsIsTouchScreen = 2097152
    }

    [Flags]
    public enum ImGuiBackendFlags
    {
        ImGuiBackendFlagsNone = 0,
        ImGuiBackendFlagsHasGamepad = 1,
        ImGuiBackendFlagsHasMouseCursors = 2,
        ImGuiBackendFlagsHasSetMousePos = 4,
        ImGuiBackendFlagsRendererHasVtxOffset = 8
    }

    public enum ImGuiCol
    {
        ImGuiColText = 0,
        ImGuiColTextDisabled = 1,
        ImGuiColWindowBg = 2,
        ImGuiColChildBg = 3,
        ImGuiColPopupBg = 4,
        ImGuiColBorder = 5,
        ImGuiColBorderShadow = 6,
        ImGuiColFrameBg = 7,
        ImGuiColFrameBgHovered = 8,
        ImGuiColFrameBgActive = 9,
        ImGuiColTitleBg = 10,
        ImGuiColTitleBgActive = 11,
        ImGuiColTitleBgCollapsed = 12,
        ImGuiColMenuBarBg = 13,
        ImGuiColScrollbarBg = 14,
        ImGuiColScrollbarGrab = 15,
        ImGuiColScrollbarGrabHovered = 16,
        ImGuiColScrollbarGrabActive = 17,
        ImGuiColCheckMark = 18,
        ImGuiColSliderGrab = 19,
        ImGuiColSliderGrabActive = 20,
        ImGuiColButton = 21,
        ImGuiColButtonHovered = 22,
        ImGuiColButtonActive = 23,
        ImGuiColHeader = 24,
        ImGuiColHeaderHovered = 25,
        ImGuiColHeaderActive = 26,
        ImGuiColSeparator = 27,
        ImGuiColSeparatorHovered = 28,
        ImGuiColSeparatorActive = 29,
        ImGuiColResizeGrip = 30,
        ImGuiColResizeGripHovered = 31,
        ImGuiColResizeGripActive = 32,
        ImGuiColTab = 33,
        ImGuiColTabHovered = 34,
        ImGuiColTabActive = 35,
        ImGuiColTabUnfocused = 36,
        ImGuiColTabUnfocusedActive = 37,
        ImGuiColPlotLines = 38,
        ImGuiColPlotLinesHovered = 39,
        ImGuiColPlotHistogram = 40,
        ImGuiColPlotHistogramHovered = 41,
        ImGuiColTextSelectedBg = 42,
        ImGuiColDragDropTarget = 43,
        ImGuiColNavHighlight = 44,
        ImGuiColNavWindowingHighlight = 45,
        ImGuiColNavWindowingDimBg = 46,
        ImGuiColModalWindowDimBg = 47,
        ImGuiColCOUNT = 48
    }

    public enum ImGuiStyleVar
    {
        ImGuiStyleVarAlpha = 0,
        ImGuiStyleVarWindowPadding = 1,
        ImGuiStyleVarWindowRounding = 2,
        ImGuiStyleVarWindowBorderSize = 3,
        ImGuiStyleVarWindowMinSize = 4,
        ImGuiStyleVarWindowTitleAlign = 5,
        ImGuiStyleVarChildRounding = 6,
        ImGuiStyleVarChildBorderSize = 7,
        ImGuiStyleVarPopupRounding = 8,
        ImGuiStyleVarPopupBorderSize = 9,
        ImGuiStyleVarFramePadding = 10,
        ImGuiStyleVarFrameRounding = 11,
        ImGuiStyleVarFrameBorderSize = 12,
        ImGuiStyleVarItemSpacing = 13,
        ImGuiStyleVarItemInnerSpacing = 14,
        ImGuiStyleVarIndentSpacing = 15,
        ImGuiStyleVarScrollbarSize = 16,
        ImGuiStyleVarScrollbarRounding = 17,
        ImGuiStyleVarGrabMinSize = 18,
        ImGuiStyleVarGrabRounding = 19,
        ImGuiStyleVarTabRounding = 20,
        ImGuiStyleVarButtonTextAlign = 21,
        ImGuiStyleVarSelectableTextAlign = 22,
        ImGuiStyleVarCOUNT = 23
    }

    public enum ImGuiColorEditFlags
    {
        ImGuiColorEditFlagsNone = 0,
        ImGuiColorEditFlagsNoAlpha = 2,
        ImGuiColorEditFlagsNoPicker = 4,
        ImGuiColorEditFlagsNoOptions = 8,
        ImGuiColorEditFlagsNoSmallPreview = 16,
        ImGuiColorEditFlagsNoInputs = 32,
        ImGuiColorEditFlagsNoTooltip = 64,
        ImGuiColorEditFlagsNoLabel = 128,
        ImGuiColorEditFlagsNoSidePreview = 256,
        ImGuiColorEditFlagsNoDragDrop = 512,
        ImGuiColorEditFlagsAlphaBar = 65536,
        ImGuiColorEditFlagsAlphaPreview = 131072,
        ImGuiColorEditFlagsAlphaPreviewHalf = 262144,
        ImGuiColorEditFlagsHDR = 524288,
        ImGuiColorEditFlagsDisplayRGB = 1048576,
        ImGuiColorEditFlagsDisplayHSV = 2097152,
        ImGuiColorEditFlagsDisplayHex = 4194304,
        ImGuiColorEditFlagsUint8 = 8388608,
        ImGuiColorEditFlagsFloat = 16777216,
        ImGuiColorEditFlagsPickerHueBar = 33554432,
        ImGuiColorEditFlagsPickerHueWheel = 67108864,
        ImGuiColorEditFlagsInputRGB = 134217728,
        ImGuiColorEditFlagsInputHSV = 268435456,
        ImGuiColorEditFlagsOptionsDefault = 177209344,
        ImGuiColorEditFlagsDisplayMask = 7340032,
        ImGuiColorEditFlagsDataTypeMask = 25165824,
        ImGuiColorEditFlagsPickerMask = 100663296,
        ImGuiColorEditFlagsInputMask = 402653184
    }

    public enum ImGuiMouseButton
    {
        ImGuiMouseButtonLeft = 0,
        ImGuiMouseButtonRight = 1,
        ImGuiMouseButtonMiddle = 2,
        ImGuiMouseButtonCOUNT = 5
    }

    public enum ImGuiMouseCursor
    {
        ImGuiMouseCursorNone = -1,
        ImGuiMouseCursorArrow = 0,
        ImGuiMouseCursorTextInput = 1,
        ImGuiMouseCursorResizeAll = 2,
        ImGuiMouseCursorResizeNS = 3,
        ImGuiMouseCursorResizeEW = 4,
        ImGuiMouseCursorResizeNESW = 5,
        ImGuiMouseCursorResizeNWSE = 6,
        ImGuiMouseCursorHand = 7,
        ImGuiMouseCursorNotAllowed = 8,
        ImGuiMouseCursorCOUNT = 9
    }

    [Flags]
    public enum ImGuiCond
    {
        ImGuiCondAlways = 1,
        ImGuiCondOnce = 2,
        ImGuiCondFirstUseEver = 4,
        ImGuiCondAppearing = 8
    }

    public enum ImDrawCornerFlags
    {
        ImDrawCornerFlagsNone = 0,
        ImDrawCornerFlagsTopLeft = 1,
        ImDrawCornerFlagsTopRight = 2,
        ImDrawCornerFlagsBotLeft = 4,
        ImDrawCornerFlagsBotRight = 8,
        ImDrawCornerFlagsTop = 3,
        ImDrawCornerFlagsBot = 12,
        ImDrawCornerFlagsLeft = 5,
        ImDrawCornerFlagsRight = 10,
        ImDrawCornerFlagsAll = 15
    }

    [Flags]
    public enum ImDrawListFlags
    {
        ImDrawListFlagsNone = 0,
        ImDrawListFlagsAntiAliasedLines = 1,
        ImDrawListFlagsAntiAliasedFill = 2,
        ImDrawListFlagsAllowVtxOffset = 4
    }

    public enum ImFontAtlasFlags
    {
        ImFontAtlasFlagsNone = 0,
        ImFontAtlasFlagsNoPowerOfTwoHeight = 1,
        ImFontAtlasFlagsNoMouseCursors = 2
    }

    public enum ImGuiButtonFlags
    {
        ImGuiButtonFlagsNone = 0,
        ImGuiButtonFlagsRepeat = 1,
        ImGuiButtonFlagsPressedOnClick = 2,
        ImGuiButtonFlagsPressedOnClickRelease = 4,
        ImGuiButtonFlagsPressedOnClickReleaseAnywhere = 8,
        ImGuiButtonFlagsPressedOnRelease = 16,
        ImGuiButtonFlagsPressedOnDoubleClick = 32,
        ImGuiButtonFlagsPressedOnDragDropHold = 64,
        ImGuiButtonFlagsFlattenChildren = 128,
        ImGuiButtonFlagsAllowItemOverlap = 256,
        ImGuiButtonFlagsDontClosePopups = 512,
        ImGuiButtonFlagsDisabled = 1024,
        ImGuiButtonFlagsAlignTextBaseLine = 2048,
        ImGuiButtonFlagsNoKeyModifiers = 4096,
        ImGuiButtonFlagsNoHoldingActiveId = 8192,
        ImGuiButtonFlagsNoNavFocus = 16384,
        ImGuiButtonFlagsNoHoveredOnNav = 32768,
        ImGuiButtonFlagsMouseButtonLeft = 65536,
        ImGuiButtonFlagsMouseButtonRight = 131072,
        ImGuiButtonFlagsMouseButtonMiddle = 262144,
        ImGuiButtonFlagsMouseButtonMask = 458752,
        ImGuiButtonFlagsMouseButtonShift = 16,
        ImGuiButtonFlagsMouseButtonDefault = 65536,
        ImGuiButtonFlagsPressedOnMask = 126,
        ImGuiButtonFlagsPressedOnDefault = 4
    }

    public enum ImGuiSliderFlags
    {
        ImGuiSliderFlagsNone = 0,
        ImGuiSliderFlagsVertical = 1
    }

    public enum ImGuiDragFlags
    {
        ImGuiDragFlagsNone = 0,
        ImGuiDragFlagsVertical = 1
    }

    [Flags]
    public enum ImGuiColumnsFlags
    {
        ImGuiColumnsFlagsNone = 0,
        ImGuiColumnsFlagsNoBorder = 1,
        ImGuiColumnsFlagsNoResize = 2,
        ImGuiColumnsFlagsNoPreserveWidths = 4,
        ImGuiColumnsFlagsNoForceWithinWindow = 8,
        ImGuiColumnsFlagsGrowParentContentsSize = 16
    }

    [Flags]
    public enum ImGuiSelectableFlagsPrivate
    {
        ImGuiSelectableFlagsNoHoldingActiveID = 1048576,
        ImGuiSelectableFlagsPressedOnClick = 2097152,
        ImGuiSelectableFlagsPressedOnRelease = 4194304,
        ImGuiSelectableFlagsDrawFillAvailWidth = 8388608,
        ImGuiSelectableFlagsDrawHoveredWhenHeld = 16777216,
        ImGuiSelectableFlagsSetNavIdOnHover = 33554432
    }

    [Flags]
    public enum ImGuiTreeNodeFlagsPrivate
    {
        ImGuiTreeNodeFlagsClipLabelForTrailingButton = 1048576
    }

    [Flags]
    public enum ImGuiSeparatorFlags
    {
        ImGuiSeparatorFlagsNone = 0,
        ImGuiSeparatorFlagsHorizontal = 1,
        ImGuiSeparatorFlagsVertical = 2,
        ImGuiSeparatorFlagsSpanAllColumns = 4
    }

    [Flags]
    public enum ImGuiItemFlags
    {
        ImGuiItemFlagsNone = 0,
        ImGuiItemFlagsNoTabStop = 1,
        ImGuiItemFlagsButtonRepeat = 2,
        ImGuiItemFlagsDisabled = 4,
        ImGuiItemFlagsNoNav = 8,
        ImGuiItemFlagsNoNavDefaultFocus = 16,
        ImGuiItemFlagsSelectableDontClosePopup = 32,
        ImGuiItemFlagsMixedValue = 64,
        ImGuiItemFlagsDefault = 0
    }

    [Flags]
    public enum ImGuiItemStatusFlags
    {
        ImGuiItemStatusFlagsNone = 0,
        ImGuiItemStatusFlagsHoveredRect = 1,
        ImGuiItemStatusFlagsHasDisplayRect = 2,
        ImGuiItemStatusFlagsEdited = 4,
        ImGuiItemStatusFlagsToggledSelection = 8,
        ImGuiItemStatusFlagsToggledOpen = 16,
        ImGuiItemStatusFlagsHasDeactivated = 32,
        ImGuiItemStatusFlagsDeactivated = 64
    }

    public enum ImGuiTextFlags
    {
        ImGuiTextFlagsNone = 0,
        ImGuiTextFlagsNoWidthForLargeClippedText = 1
    }

    public enum ImGuiTooltipFlags
    {
        ImGuiTooltipFlagsNone = 0,
        ImGuiTooltipFlagsOverridePreviousTooltip = 1
    }

    public enum ImGuiLayoutType
    {
        ImGuiLayoutTypeHorizontal = 0,
        ImGuiLayoutTypeVertical = 1
    }

    public enum ImGuiAxis
    {
        ImGuiAxisNone = -1,
        ImGuiAxisX = 0,
        ImGuiAxisY = 1
    }

    public enum ImGuiPlotType
    {
        ImGuiPlotTypeLines = 0,
        ImGuiPlotTypeHistogram = 1
    }

    public enum ImGuiInputReadMode
    {
        ImGuiInputReadModeDown = 0,
        ImGuiInputReadModePressed = 1,
        ImGuiInputReadModeReleased = 2,
        ImGuiInputReadModeRepeat = 3,
        ImGuiInputReadModeRepeatSlow = 4,
        ImGuiInputReadModeRepeatFast = 5
    }

    [Flags]
    public enum ImGuiNavHighlightFlags
    {
        ImGuiNavHighlightFlagsNone = 0,
        ImGuiNavHighlightFlagsTypeDefault = 1,
        ImGuiNavHighlightFlagsTypeThin = 2,
        ImGuiNavHighlightFlagsAlwaysDraw = 4,
        ImGuiNavHighlightFlagsNoRounding = 8
    }

    [Flags]
    public enum ImGuiNavDirSourceFlags
    {
        ImGuiNavDirSourceFlagsNone = 0,
        ImGuiNavDirSourceFlagsKeyboard = 1,
        ImGuiNavDirSourceFlagsPadDPad = 2,
        ImGuiNavDirSourceFlagsPadLStick = 4
    }

    [Flags]
    public enum ImGuiNavMoveFlags
    {
        ImGuiNavMoveFlagsNone = 0,
        ImGuiNavMoveFlagsLoopX = 1,
        ImGuiNavMoveFlagsLoopY = 2,
        ImGuiNavMoveFlagsWrapX = 4,
        ImGuiNavMoveFlagsWrapY = 8,
        ImGuiNavMoveFlagsAllowCurrentNavId = 16,
        ImGuiNavMoveFlagsAlsoScoreVisibleSet = 32,
        ImGuiNavMoveFlagsScrollToEdge = 64
    }

    public enum ImGuiPopupPositionPolicy
    {
        ImGuiPopupPositionPolicyDefault = 0,
        ImGuiPopupPositionPolicyComboBox = 1
    }

    [Flags]
    public enum ImGuiNextWindowDataFlags
    {
        ImGuiNextWindowDataFlagsNone = 0,
        ImGuiNextWindowDataFlagsHasPos = 1,
        ImGuiNextWindowDataFlagsHasSize = 2,
        ImGuiNextWindowDataFlagsHasContentSize = 4,
        ImGuiNextWindowDataFlagsHasCollapsed = 8,
        ImGuiNextWindowDataFlagsHasSizeConstraint = 16,
        ImGuiNextWindowDataFlagsHasFocus = 32,
        ImGuiNextWindowDataFlagsHasBgAlpha = 64
    }

    public enum ImGuiNextItemDataFlags
    {
        ImGuiNextItemDataFlagsNone = 0,
        ImGuiNextItemDataFlagsHasWidth = 1,
        ImGuiNextItemDataFlagsHasOpen = 2
    }

    [Flags]
    public enum ImGuiTabBarFlagsPrivate
    {
        ImGuiTabBarFlagsDockNode = 1048576,
        ImGuiTabBarFlagsIsFocused = 2097152,
        ImGuiTabBarFlagsSaveSettings = 4194304
    }

    [Flags]
    public enum ImGuiTabItemFlagsPrivate
    {
        ImGuiTabItemFlagsNoCloseButton = 1048576
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void ImDrawCallback(global::System.IntPtr parent_list, global::System.IntPtr cmd);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiSizeCallback(global::System.IntPtr data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate int ImGuiInputTextCallback(global::System.IntPtr data);

    public unsafe partial class ImVector : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVector> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVector>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVector __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVector(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVector __CreateInstance(global::ImGui.ImVector.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVector(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVector.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector.__Internal));
            *(global::ImGui.ImVector.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector(global::ImGui.ImVector.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVector(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVector()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVector(global::ImGui.ImVector _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVector.__Internal*) __Instance) = *((global::ImGui.ImVector.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVector __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVector.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVector.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVector.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVector.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::System.IntPtr Data
        {
            get
            {
                return ((global::ImGui.ImVector.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImVector.__Internal*)__Instance)->Data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVector_float : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_float@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVector_float> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVector_float>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVector_float __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVector_float(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVector_float __CreateInstance(global::ImGui.ImVector_float.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVector_float(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVector_float.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_float.__Internal));
            *(global::ImGui.ImVector_float.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_float(global::ImGui.ImVector_float.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVector_float(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVector_float()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_float.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVector_float(global::ImGui.ImVector_float _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_float.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVector_float.__Internal*) __Instance) = *((global::ImGui.ImVector_float.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVector_float __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVector_float.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVector_float.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVector_float.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVector_float.__Internal*)__Instance)->Capacity = value;
            }
        }

        public float* Data
        {
            get
            {
                return (float*) ((global::ImGui.ImVector_float.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImVector_float.__Internal*)__Instance)->Data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImWchar : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImWchar@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImWchar> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImWchar>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImWchar __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImWchar(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImWchar __CreateInstance(global::ImGui.ImVectorImWchar.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImWchar(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImWchar.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImWchar.__Internal));
            *(global::ImGui.ImVectorImWchar.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImWchar(global::ImGui.ImVectorImWchar.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImWchar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImWchar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImWchar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImWchar(global::ImGui.ImVectorImWchar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImWchar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImWchar.__Internal*) __Instance) = *((global::ImGui.ImVectorImWchar.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImWchar __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImWchar.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImWchar.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImWchar.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImWchar.__Internal*)__Instance)->Capacity = value;
            }
        }

        public ushort* Data
        {
            get
            {
                return (ushort*) ((global::ImGui.ImVectorImWchar.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImVectorImWchar.__Internal*)__Instance)->Data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImDrawVert : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImDrawVert@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImDrawVert> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImDrawVert>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImDrawVert __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImDrawVert(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImDrawVert __CreateInstance(global::ImGui.ImVectorImDrawVert.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImDrawVert(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImDrawVert.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawVert.__Internal));
            *(global::ImGui.ImVectorImDrawVert.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawVert(global::ImGui.ImVectorImDrawVert.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImDrawVert(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImDrawVert()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawVert.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawVert(global::ImGui.ImVectorImDrawVert _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawVert.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImDrawVert.__Internal*) __Instance) = *((global::ImGui.ImVectorImDrawVert.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImDrawVert __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImDrawVert.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawVert.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImDrawVert.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawVert.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImDrawVert Data
        {
            get
            {
                global::ImGui.ImDrawVert __result0;
                if (((global::ImGui.ImVectorImDrawVert.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImDrawVert.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImDrawVert.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImDrawVert) global::ImGui.ImDrawVert.NativeToManagedMap[((global::ImGui.ImVectorImDrawVert.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImDrawVert.__CreateInstance(((global::ImGui.ImVectorImDrawVert.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawVert.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiSettingsHandler : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiSettingsHandler@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiSettingsHandler> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiSettingsHandler>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiSettingsHandler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiSettingsHandler(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiSettingsHandler __CreateInstance(global::ImGui.ImVectorImGuiSettingsHandler.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiSettingsHandler(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiSettingsHandler.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiSettingsHandler.__Internal));
            *(global::ImGui.ImVectorImGuiSettingsHandler.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiSettingsHandler(global::ImGui.ImVectorImGuiSettingsHandler.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiSettingsHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiSettingsHandler()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiSettingsHandler(global::ImGui.ImVectorImGuiSettingsHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiSettingsHandler.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiSettingsHandler.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiSettingsHandler __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiSettingsHandler.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiSettingsHandler.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiSettingsHandler.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiSettingsHandler.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiSettingsHandler Data
        {
            get
            {
                global::ImGui.ImGuiSettingsHandler __result0;
                if (((global::ImGui.ImVectorImGuiSettingsHandler.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiSettingsHandler.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiSettingsHandler.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiSettingsHandler) global::ImGui.ImGuiSettingsHandler.NativeToManagedMap[((global::ImGui.ImVectorImGuiSettingsHandler.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiSettingsHandler.__CreateInstance(((global::ImGui.ImVectorImGuiSettingsHandler.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiSettingsHandler.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImVec4 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImVec4@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImVec4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImVec4>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImVec4 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImVec4(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImVec4 __CreateInstance(global::ImGui.ImVectorImVec4.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImVec4(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImVec4.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImVec4.__Internal));
            *(global::ImGui.ImVectorImVec4.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImVec4(global::ImGui.ImVectorImVec4.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImVec4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImVec4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImVec4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImVec4(global::ImGui.ImVectorImVec4 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImVec4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImVec4.__Internal*) __Instance) = *((global::ImGui.ImVectorImVec4.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImVec4 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImVec4.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImVec4.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImVec4.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImVec4.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImVec4 Data
        {
            get
            {
                global::ImGui.ImVec4 __result0;
                if (((global::ImGui.ImVectorImVec4.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImVec4.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImVec4.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImVec4) global::ImGui.ImVec4.NativeToManagedMap[((global::ImGui.ImVectorImVec4.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImVec4.__CreateInstance(((global::ImGui.ImVectorImVec4.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImVec4.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiGroupData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiGroupData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiGroupData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiGroupData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiGroupData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiGroupData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiGroupData __CreateInstance(global::ImGui.ImVectorImGuiGroupData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiGroupData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiGroupData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiGroupData.__Internal));
            *(global::ImGui.ImVectorImGuiGroupData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiGroupData(global::ImGui.ImVectorImGuiGroupData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiGroupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiGroupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiGroupData(global::ImGui.ImVectorImGuiGroupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiGroupData.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiGroupData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiGroupData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiGroupData.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiGroupData.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiGroupData.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiGroupData.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiGroupData Data
        {
            get
            {
                global::ImGui.ImGuiGroupData __result0;
                if (((global::ImGui.ImVectorImGuiGroupData.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiGroupData.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiGroupData.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiGroupData) global::ImGui.ImGuiGroupData.NativeToManagedMap[((global::ImGui.ImVectorImGuiGroupData.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiGroupData.__CreateInstance(((global::ImGui.ImVectorImGuiGroupData.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiGroupData.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiID : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiID@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiID> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiID>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiID __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiID(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiID __CreateInstance(global::ImGui.ImVectorImGuiID.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiID(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiID.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiID.__Internal));
            *(global::ImGui.ImVectorImGuiID.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiID(global::ImGui.ImVectorImGuiID.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiID(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiID()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiID.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiID(global::ImGui.ImVectorImGuiID _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiID.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiID.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiID.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiID __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiID.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiID.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiID.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiID.__Internal*)__Instance)->Capacity = value;
            }
        }

        public uint* Data
        {
            get
            {
                return (uint*) ((global::ImGui.ImVectorImGuiID.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiID.__Internal*)__Instance)->Data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiWindowPtr : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiWindowPtr@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiWindowPtr> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiWindowPtr>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiWindowPtr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiWindowPtr(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiWindowPtr __CreateInstance(global::ImGui.ImVectorImGuiWindowPtr.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiWindowPtr(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiWindowPtr.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiWindowPtr.__Internal));
            *(global::ImGui.ImVectorImGuiWindowPtr.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiWindowPtr(global::ImGui.ImVectorImGuiWindowPtr.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiWindowPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiWindowPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiWindowPtr.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiWindowPtr(global::ImGui.ImVectorImGuiWindowPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiWindowPtr.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiWindowPtr.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiWindowPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiWindowPtr __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiWindowPtr.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiWindowPtr.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiWindowPtr.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiWindowPtr.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiWindow Data
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImVectorImGuiWindowPtr.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiWindowPtr.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImVectorImGuiWindowPtr.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImVectorImGuiWindowPtr.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                var __value = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                ((global::ImGui.ImVectorImGuiWindowPtr.__Internal*)__Instance)->Data = new global::System.IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImVectorImGuiColumnData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiColumnData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiColumnData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiColumnData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiColumnData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiColumnData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiColumnData __CreateInstance(global::ImGui.ImVectorImGuiColumnData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiColumnData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiColumnData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiColumnData.__Internal));
            *(global::ImGui.ImVectorImGuiColumnData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiColumnData(global::ImGui.ImVectorImGuiColumnData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiColumnData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiColumnData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiColumnData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiColumnData(global::ImGui.ImVectorImGuiColumnData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiColumnData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiColumnData.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiColumnData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiColumnData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiColumnData.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiColumnData.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiColumnData.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiColumnData.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiColumnData Data
        {
            get
            {
                global::ImGui.ImGuiColumnData __result0;
                if (((global::ImGui.ImVectorImGuiColumnData.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiColumnData.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiColumnData.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiColumnData) global::ImGui.ImGuiColumnData.NativeToManagedMap[((global::ImGui.ImVectorImGuiColumnData.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiColumnData.__CreateInstance(((global::ImGui.ImVectorImGuiColumnData.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiColumnData.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiColorMod : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiColorMod@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiColorMod> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiColorMod>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiColorMod __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiColorMod(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiColorMod __CreateInstance(global::ImGui.ImVectorImGuiColorMod.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiColorMod(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiColorMod.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiColorMod.__Internal));
            *(global::ImGui.ImVectorImGuiColorMod.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiColorMod(global::ImGui.ImVectorImGuiColorMod.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiColorMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiColorMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiColorMod(global::ImGui.ImVectorImGuiColorMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiColorMod.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiColorMod.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiColorMod __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiColorMod.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiColorMod.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiColorMod.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiColorMod.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiColorMod Data
        {
            get
            {
                global::ImGui.ImGuiColorMod __result0;
                if (((global::ImGui.ImVectorImGuiColorMod.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiColorMod.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiColorMod.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiColorMod) global::ImGui.ImGuiColorMod.NativeToManagedMap[((global::ImGui.ImVectorImGuiColorMod.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiColorMod.__CreateInstance(((global::ImGui.ImVectorImGuiColorMod.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiColorMod.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImVec2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImVec2@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImVec2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImVec2>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImVec2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImVec2(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImVec2 __CreateInstance(global::ImGui.ImVectorImVec2.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImVec2(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImVec2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImVec2.__Internal));
            *(global::ImGui.ImVectorImVec2.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImVec2(global::ImGui.ImVectorImVec2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImVec2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImVec2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImVec2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImVec2(global::ImGui.ImVectorImVec2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImVec2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImVec2.__Internal*) __Instance) = *((global::ImGui.ImVectorImVec2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImVec2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImVec2.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImVec2.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImVec2.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImVec2.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImVec2 Data
        {
            get
            {
                global::ImGui.ImVec2 __result0;
                if (((global::ImGui.ImVectorImVec2.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImVec2.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImVec2.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImVec2) global::ImGui.ImVec2.NativeToManagedMap[((global::ImGui.ImVectorImVec2.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImVec2.__CreateInstance(((global::ImGui.ImVectorImVec2.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImVec2.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImFontGlyph : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImFontGlyph@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImFontGlyph> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImFontGlyph>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImFontGlyph __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImFontGlyph(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImFontGlyph __CreateInstance(global::ImGui.ImVectorImFontGlyph.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImFontGlyph(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImFontGlyph.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontGlyph.__Internal));
            *(global::ImGui.ImVectorImFontGlyph.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontGlyph(global::ImGui.ImVectorImFontGlyph.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImFontGlyph(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImFontGlyph()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontGlyph(global::ImGui.ImVectorImFontGlyph _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImFontGlyph.__Internal*) __Instance) = *((global::ImGui.ImVectorImFontGlyph.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImFontGlyph __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImFontGlyph.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImFontGlyph.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImFontGlyph.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImFontGlyph.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImFontGlyph Data
        {
            get
            {
                global::ImGui.ImFontGlyph __result0;
                if (((global::ImGui.ImVectorImFontGlyph.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFontGlyph.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImFontGlyph.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImFontGlyph) global::ImGui.ImFontGlyph.NativeToManagedMap[((global::ImGui.ImVectorImFontGlyph.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImFontGlyph.__CreateInstance(((global::ImGui.ImVectorImFontGlyph.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImFontGlyph.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTextRange : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiTextRange@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiTextRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiTextRange>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiTextRange __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiTextRange(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiTextRange __CreateInstance(global::ImGui.ImVectorImGuiTextRange.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiTextRange(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiTextRange.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiTextRange.__Internal));
            *(global::ImGui.ImVectorImGuiTextRange.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTextRange(global::ImGui.ImVectorImGuiTextRange.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiTextRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiTextRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiTextRange(global::ImGui.ImVectorImGuiTextRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiTextRange.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiTextRange.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiTextRange __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiTextRange.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiTextRange.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiTextRange.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiTextRange.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiTextRange Data
        {
            get
            {
                global::ImGui.ImGuiTextRange __result0;
                if (((global::ImGui.ImVectorImGuiTextRange.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiTextRange.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiTextRange.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiTextRange) global::ImGui.ImGuiTextRange.NativeToManagedMap[((global::ImGui.ImVectorImGuiTextRange.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiTextRange.__CreateInstance(((global::ImGui.ImVectorImGuiTextRange.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiTextRange.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiStoragePair : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiStoragePair@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiStoragePair> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiStoragePair>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiStoragePair __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiStoragePair(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiStoragePair __CreateInstance(global::ImGui.ImVectorImGuiStoragePair.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiStoragePair(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiStoragePair.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiStoragePair.__Internal));
            *(global::ImGui.ImVectorImGuiStoragePair.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiStoragePair(global::ImGui.ImVectorImGuiStoragePair.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiStoragePair(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiStoragePair()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiStoragePair(global::ImGui.ImVectorImGuiStoragePair _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiStoragePair.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiStoragePair.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiStoragePair __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiStoragePair.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiStoragePair.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiStoragePair.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiStoragePair.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiStoragePair Data
        {
            get
            {
                global::ImGui.ImGuiStoragePair __result0;
                if (((global::ImGui.ImVectorImGuiStoragePair.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiStoragePair.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiStoragePair.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiStoragePair) global::ImGui.ImGuiStoragePair.NativeToManagedMap[((global::ImGui.ImVectorImGuiStoragePair.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiStoragePair.__CreateInstance(((global::ImGui.ImVectorImGuiStoragePair.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiStoragePair.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiStyleMod : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiStyleMod@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiStyleMod> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiStyleMod>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiStyleMod __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiStyleMod(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiStyleMod __CreateInstance(global::ImGui.ImVectorImGuiStyleMod.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiStyleMod(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiStyleMod.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiStyleMod.__Internal));
            *(global::ImGui.ImVectorImGuiStyleMod.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiStyleMod(global::ImGui.ImVectorImGuiStyleMod.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiStyleMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiStyleMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiStyleMod(global::ImGui.ImVectorImGuiStyleMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiStyleMod.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiStyleMod.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiStyleMod __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiStyleMod.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiStyleMod.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiStyleMod.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiStyleMod.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiStyleMod Data
        {
            get
            {
                global::ImGui.ImGuiStyleMod __result0;
                if (((global::ImGui.ImVectorImGuiStyleMod.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiStyleMod.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiStyleMod.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiStyleMod) global::ImGui.ImGuiStyleMod.NativeToManagedMap[((global::ImGui.ImVectorImGuiStyleMod.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiStyleMod.__CreateInstance(((global::ImGui.ImVectorImGuiStyleMod.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiStyleMod.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImDrawChannel : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImDrawChannel@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImDrawChannel> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImDrawChannel>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImDrawChannel __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImDrawChannel(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImDrawChannel __CreateInstance(global::ImGui.ImVectorImDrawChannel.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImDrawChannel(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImDrawChannel.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawChannel.__Internal));
            *(global::ImGui.ImVectorImDrawChannel.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawChannel(global::ImGui.ImVectorImDrawChannel.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImDrawChannel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImDrawChannel()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawChannel(global::ImGui.ImVectorImDrawChannel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImDrawChannel.__Internal*) __Instance) = *((global::ImGui.ImVectorImDrawChannel.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImDrawChannel __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImDrawChannel.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawChannel.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImDrawChannel.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawChannel.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImDrawChannel Data
        {
            get
            {
                global::ImGui.ImDrawChannel __result0;
                if (((global::ImGui.ImVectorImDrawChannel.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImDrawChannel.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImDrawChannel.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImDrawChannel) global::ImGui.ImDrawChannel.NativeToManagedMap[((global::ImGui.ImVectorImDrawChannel.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImDrawChannel.__CreateInstance(((global::ImGui.ImVectorImDrawChannel.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawChannel.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImDrawListPtr : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImDrawListPtr@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImDrawListPtr> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImDrawListPtr>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImDrawListPtr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImDrawListPtr(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImDrawListPtr __CreateInstance(global::ImGui.ImVectorImDrawListPtr.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImDrawListPtr(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImDrawListPtr.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawListPtr.__Internal));
            *(global::ImGui.ImVectorImDrawListPtr.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawListPtr(global::ImGui.ImVectorImDrawListPtr.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImDrawListPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImDrawListPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawListPtr.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawListPtr(global::ImGui.ImVectorImDrawListPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawListPtr.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImDrawListPtr.__Internal*) __Instance) = *((global::ImGui.ImVectorImDrawListPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImDrawListPtr __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImDrawListPtr.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawListPtr.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImDrawListPtr.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawListPtr.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImDrawList Data
        {
            get
            {
                global::ImGui.ImDrawList __result0;
                if (((global::ImGui.ImVectorImDrawListPtr.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImDrawList.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImDrawListPtr.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImDrawList) global::ImGui.ImDrawList.NativeToManagedMap[((global::ImGui.ImVectorImDrawListPtr.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImDrawList.__CreateInstance(((global::ImGui.ImVectorImDrawListPtr.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                var __value = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                ((global::ImGui.ImVectorImDrawListPtr.__Internal*)__Instance)->Data = new global::System.IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImVectorImU32 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImU32@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImU32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImU32>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImU32 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImU32(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImU32 __CreateInstance(global::ImGui.ImVectorImU32.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImU32(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImU32.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImU32.__Internal));
            *(global::ImGui.ImVectorImU32.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImU32(global::ImGui.ImVectorImU32.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImU32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImU32()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImU32.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImU32(global::ImGui.ImVectorImU32 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImU32.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImU32.__Internal*) __Instance) = *((global::ImGui.ImVectorImU32.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImU32 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImU32.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImU32.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImU32.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImU32.__Internal*)__Instance)->Capacity = value;
            }
        }

        public uint* Data
        {
            get
            {
                return (uint*) ((global::ImGui.ImVectorImU32.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImVectorImU32.__Internal*)__Instance)->Data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiItemFlags : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiItemFlags@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiItemFlags> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiItemFlags>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiItemFlags __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiItemFlags(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiItemFlags __CreateInstance(global::ImGui.ImVectorImGuiItemFlags.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiItemFlags(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiItemFlags.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiItemFlags.__Internal));
            *(global::ImGui.ImVectorImGuiItemFlags.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiItemFlags(global::ImGui.ImVectorImGuiItemFlags.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiItemFlags(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiItemFlags()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiItemFlags.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiItemFlags(global::ImGui.ImVectorImGuiItemFlags _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiItemFlags.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiItemFlags.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiItemFlags.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiItemFlags __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiItemFlags.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiItemFlags.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiItemFlags.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiItemFlags.__Internal*)__Instance)->Capacity = value;
            }
        }

        public int* Data
        {
            get
            {
                return (int*) ((global::ImGui.ImVectorImGuiItemFlags.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiItemFlags.__Internal*)__Instance)->Data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImFontAtlasCustomRect : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImFontAtlasCustomRect@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImFontAtlasCustomRect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImFontAtlasCustomRect>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImFontAtlasCustomRect __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImFontAtlasCustomRect(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImFontAtlasCustomRect __CreateInstance(global::ImGui.ImVectorImFontAtlasCustomRect.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImFontAtlasCustomRect(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImFontAtlasCustomRect.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontAtlasCustomRect.__Internal));
            *(global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontAtlasCustomRect(global::ImGui.ImVectorImFontAtlasCustomRect.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImFontAtlasCustomRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImFontAtlasCustomRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontAtlasCustomRect(global::ImGui.ImVectorImFontAtlasCustomRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*) __Instance) = *((global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImFontAtlasCustomRect __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImFontAtlasCustomRect Data
        {
            get
            {
                global::ImGui.ImFontAtlasCustomRect __result0;
                if (((global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFontAtlasCustomRect.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImFontAtlasCustomRect) global::ImGui.ImFontAtlasCustomRect.NativeToManagedMap[((global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImFontAtlasCustomRect.__CreateInstance(((global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTabItem : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiTabItem@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiTabItem> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiTabItem>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiTabItem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiTabItem(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiTabItem __CreateInstance(global::ImGui.ImVectorImGuiTabItem.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiTabItem(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiTabItem.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiTabItem.__Internal));
            *(global::ImGui.ImVectorImGuiTabItem.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTabItem(global::ImGui.ImVectorImGuiTabItem.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiTabItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiTabItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiTabItem(global::ImGui.ImVectorImGuiTabItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiTabItem.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiTabItem.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiTabItem __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiTabItem.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiTabItem.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiTabItem.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiTabItem.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiTabItem Data
        {
            get
            {
                global::ImGui.ImGuiTabItem __result0;
                if (((global::ImGui.ImVectorImGuiTabItem.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiTabItem.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiTabItem.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiTabItem) global::ImGui.ImGuiTabItem.NativeToManagedMap[((global::ImGui.ImVectorImGuiTabItem.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiTabItem.__CreateInstance(((global::ImGui.ImVectorImGuiTabItem.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiTabItem.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiColumns : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiColumns@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiColumns> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiColumns>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiColumns __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiColumns(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiColumns __CreateInstance(global::ImGui.ImVectorImGuiColumns.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiColumns(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiColumns.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiColumns.__Internal));
            *(global::ImGui.ImVectorImGuiColumns.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiColumns(global::ImGui.ImVectorImGuiColumns.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiColumns(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiColumns()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiColumns.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiColumns(global::ImGui.ImVectorImGuiColumns _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiColumns.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiColumns.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiColumns.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiColumns __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiColumns.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiColumns.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiColumns.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiColumns.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiColumns Data
        {
            get
            {
                global::ImGui.ImGuiColumns __result0;
                if (((global::ImGui.ImVectorImGuiColumns.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiColumns.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiColumns.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiColumns) global::ImGui.ImGuiColumns.NativeToManagedMap[((global::ImGui.ImVectorImGuiColumns.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiColumns.__CreateInstance(((global::ImGui.ImVectorImGuiColumns.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiColumns.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiShrinkWidthItem : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiShrinkWidthItem@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiShrinkWidthItem> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiShrinkWidthItem>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiShrinkWidthItem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiShrinkWidthItem(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiShrinkWidthItem __CreateInstance(global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiShrinkWidthItem(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal));
            *(global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiShrinkWidthItem(global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiShrinkWidthItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiShrinkWidthItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiShrinkWidthItem(global::ImGui.ImVectorImGuiShrinkWidthItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiShrinkWidthItem __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiShrinkWidthItem Data
        {
            get
            {
                global::ImGui.ImGuiShrinkWidthItem __result0;
                if (((global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiShrinkWidthItem.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiShrinkWidthItem) global::ImGui.ImGuiShrinkWidthItem.NativeToManagedMap[((global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiShrinkWidthItem.__CreateInstance(((global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVector_char : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_char@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVector_char> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVector_char>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVector_char __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVector_char(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVector_char __CreateInstance(global::ImGui.ImVector_char.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVector_char(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVector_char.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_char.__Internal));
            *(global::ImGui.ImVector_char.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_char(global::ImGui.ImVector_char.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVector_char(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVector_char()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_char.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVector_char(global::ImGui.ImVector_char _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_char.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVector_char.__Internal*) __Instance) = *((global::ImGui.ImVector_char.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVector_char __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVector_char.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVector_char.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVector_char.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVector_char.__Internal*)__Instance)->Capacity = value;
            }
        }

        public sbyte* Data
        {
            get
            {
                return (sbyte*) ((global::ImGui.ImVector_char.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImVector_char.__Internal*)__Instance)->Data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImTextureID : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImTextureID@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImTextureID> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImTextureID>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImTextureID __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImTextureID(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImTextureID __CreateInstance(global::ImGui.ImVectorImTextureID.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImTextureID(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImTextureID.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImTextureID.__Internal));
            *(global::ImGui.ImVectorImTextureID.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImTextureID(global::ImGui.ImVectorImTextureID.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImTextureID(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImTextureID()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImTextureID.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImTextureID(global::ImGui.ImVectorImTextureID _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImTextureID.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImTextureID.__Internal*) __Instance) = *((global::ImGui.ImVectorImTextureID.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImTextureID __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImTextureID.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImTextureID.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImTextureID.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImTextureID.__Internal*)__Instance)->Capacity = value;
            }
        }

        public void** Data
        {
            get
            {
                return (void**) ((global::ImGui.ImVectorImTextureID.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImVectorImTextureID.__Internal*)__Instance)->Data = (IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImFontPtr : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImFontPtr@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImFontPtr> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImFontPtr>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImFontPtr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImFontPtr(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImFontPtr __CreateInstance(global::ImGui.ImVectorImFontPtr.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImFontPtr(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImFontPtr.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontPtr.__Internal));
            *(global::ImGui.ImVectorImFontPtr.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontPtr(global::ImGui.ImVectorImFontPtr.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImFontPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImFontPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontPtr.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontPtr(global::ImGui.ImVectorImFontPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontPtr.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImFontPtr.__Internal*) __Instance) = *((global::ImGui.ImVectorImFontPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImFontPtr __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImFontPtr.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImFontPtr.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImFontPtr.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImFontPtr.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImFont Data
        {
            get
            {
                global::ImGui.ImFont __result0;
                if (((global::ImGui.ImVectorImFontPtr.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImFontPtr.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[((global::ImGui.ImVectorImFontPtr.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImFont.__CreateInstance(((global::ImGui.ImVectorImFontPtr.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                var __value = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                ((global::ImGui.ImVectorImFontPtr.__Internal*)__Instance)->Data = new global::System.IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImVectorImFontConfig : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImFontConfig@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImFontConfig> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImFontConfig>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImFontConfig __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImFontConfig(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImFontConfig __CreateInstance(global::ImGui.ImVectorImFontConfig.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImFontConfig(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImFontConfig.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontConfig.__Internal));
            *(global::ImGui.ImVectorImFontConfig.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontConfig(global::ImGui.ImVectorImFontConfig.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImFontConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImFontConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontConfig(global::ImGui.ImVectorImFontConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImFontConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImFontConfig.__Internal*) __Instance) = *((global::ImGui.ImVectorImFontConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImFontConfig __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImFontConfig.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImFontConfig.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImFontConfig.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImFontConfig.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImFontConfig Data
        {
            get
            {
                global::ImGui.ImFontConfig __result0;
                if (((global::ImGui.ImVectorImFontConfig.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFontConfig.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImFontConfig.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImFontConfig) global::ImGui.ImFontConfig.NativeToManagedMap[((global::ImGui.ImVectorImFontConfig.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImFontConfig.__CreateInstance(((global::ImGui.ImVectorImFontConfig.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImFontConfig.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVector_int : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_int@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVector_int> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVector_int>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVector_int __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVector_int(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVector_int __CreateInstance(global::ImGui.ImVector_int.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVector_int(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVector_int.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_int.__Internal));
            *(global::ImGui.ImVector_int.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_int(global::ImGui.ImVector_int.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVector_int(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVector_int()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_int.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVector_int(global::ImGui.ImVector_int _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_int.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVector_int.__Internal*) __Instance) = *((global::ImGui.ImVector_int.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVector_int __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVector_int.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVector_int.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVector_int.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVector_int.__Internal*)__Instance)->Capacity = value;
            }
        }

        public int* Data
        {
            get
            {
                return (int*) ((global::ImGui.ImVector_int.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImVector_int.__Internal*)__Instance)->Data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImDrawCmd : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImDrawCmd@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImDrawCmd> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImDrawCmd>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImDrawCmd __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImDrawCmd(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImDrawCmd __CreateInstance(global::ImGui.ImVectorImDrawCmd.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImDrawCmd(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImDrawCmd.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawCmd.__Internal));
            *(global::ImGui.ImVectorImDrawCmd.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawCmd(global::ImGui.ImVectorImDrawCmd.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImDrawCmd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImDrawCmd()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawCmd(global::ImGui.ImVectorImDrawCmd _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImDrawCmd.__Internal*) __Instance) = *((global::ImGui.ImVectorImDrawCmd.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImDrawCmd __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImDrawCmd.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawCmd.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImDrawCmd.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawCmd.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImDrawCmd Data
        {
            get
            {
                global::ImGui.ImDrawCmd __result0;
                if (((global::ImGui.ImVectorImDrawCmd.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImDrawCmd.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImDrawCmd.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImDrawCmd) global::ImGui.ImDrawCmd.NativeToManagedMap[((global::ImGui.ImVectorImDrawCmd.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImDrawCmd.__CreateInstance(((global::ImGui.ImVectorImDrawCmd.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawCmd.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiPtrOrIndex : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiPtrOrIndex@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiPtrOrIndex> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiPtrOrIndex>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiPtrOrIndex __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiPtrOrIndex(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiPtrOrIndex __CreateInstance(global::ImGui.ImVectorImGuiPtrOrIndex.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiPtrOrIndex(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiPtrOrIndex.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiPtrOrIndex.__Internal));
            *(global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiPtrOrIndex(global::ImGui.ImVectorImGuiPtrOrIndex.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiPtrOrIndex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiPtrOrIndex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiPtrOrIndex(global::ImGui.ImVectorImGuiPtrOrIndex _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiPtrOrIndex __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiPtrOrIndex Data
        {
            get
            {
                global::ImGui.ImGuiPtrOrIndex __result0;
                if (((global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiPtrOrIndex.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiPtrOrIndex) global::ImGui.ImGuiPtrOrIndex.NativeToManagedMap[((global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiPtrOrIndex.__CreateInstance(((global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiPopupData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiPopupData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiPopupData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiPopupData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiPopupData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiPopupData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiPopupData __CreateInstance(global::ImGui.ImVectorImGuiPopupData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiPopupData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiPopupData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiPopupData.__Internal));
            *(global::ImGui.ImVectorImGuiPopupData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiPopupData(global::ImGui.ImVectorImGuiPopupData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiPopupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiPopupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiPopupData(global::ImGui.ImVectorImGuiPopupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiPopupData.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiPopupData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiPopupData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiPopupData.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiPopupData.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiPopupData.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiPopupData.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiPopupData Data
        {
            get
            {
                global::ImGui.ImGuiPopupData __result0;
                if (((global::ImGui.ImVectorImGuiPopupData.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiPopupData.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiPopupData.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiPopupData) global::ImGui.ImGuiPopupData.NativeToManagedMap[((global::ImGui.ImVectorImGuiPopupData.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiPopupData.__CreateInstance(((global::ImGui.ImVectorImGuiPopupData.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiPopupData.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImDrawIdx : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImDrawIdx@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImDrawIdx> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImDrawIdx>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImDrawIdx __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImDrawIdx(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImDrawIdx __CreateInstance(global::ImGui.ImVectorImDrawIdx.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImDrawIdx(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImDrawIdx.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawIdx.__Internal));
            *(global::ImGui.ImVectorImDrawIdx.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawIdx(global::ImGui.ImVectorImDrawIdx.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImDrawIdx(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImDrawIdx()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawIdx.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawIdx(global::ImGui.ImVectorImDrawIdx _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImDrawIdx.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImDrawIdx.__Internal*) __Instance) = *((global::ImGui.ImVectorImDrawIdx.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImDrawIdx __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImDrawIdx.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawIdx.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImDrawIdx.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawIdx.__Internal*)__Instance)->Capacity = value;
            }
        }

        public ushort* Data
        {
            get
            {
                return (ushort*) ((global::ImGui.ImVectorImDrawIdx.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImVectorImDrawIdx.__Internal*)__Instance)->Data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVector_unsigned_char : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_unsigned_char@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVector_unsigned_char> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVector_unsigned_char>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVector_unsigned_char __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVector_unsigned_char(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVector_unsigned_char __CreateInstance(global::ImGui.ImVector_unsigned_char.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVector_unsigned_char(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVector_unsigned_char.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_unsigned_char.__Internal));
            *(global::ImGui.ImVector_unsigned_char.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_unsigned_char(global::ImGui.ImVector_unsigned_char.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVector_unsigned_char(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVector_unsigned_char()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_unsigned_char.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVector_unsigned_char(global::ImGui.ImVector_unsigned_char _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVector_unsigned_char.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVector_unsigned_char.__Internal*) __Instance) = *((global::ImGui.ImVector_unsigned_char.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVector_unsigned_char __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVector_unsigned_char.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVector_unsigned_char.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVector_unsigned_char.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVector_unsigned_char.__Internal*)__Instance)->Capacity = value;
            }
        }

        public byte* Data
        {
            get
            {
                return (byte*) ((global::ImGui.ImVector_unsigned_char.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImVector_unsigned_char.__Internal*)__Instance)->Data = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiWindowSettings : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiWindowSettings@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiWindowSettings> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiWindowSettings>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiWindowSettings __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiWindowSettings(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiWindowSettings __CreateInstance(global::ImGui.ImVectorImGuiWindowSettings.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiWindowSettings(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiWindowSettings.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiWindowSettings.__Internal));
            *(global::ImGui.ImVectorImGuiWindowSettings.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiWindowSettings(global::ImGui.ImVectorImGuiWindowSettings.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiWindowSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiWindowSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiWindowSettings(global::ImGui.ImVectorImGuiWindowSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiWindowSettings.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiWindowSettings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiWindowSettings __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiWindowSettings.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiWindowSettings.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiWindowSettings.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiWindowSettings.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiWindowSettings Data
        {
            get
            {
                global::ImGui.ImGuiWindowSettings __result0;
                if (((global::ImGui.ImVectorImGuiWindowSettings.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindowSettings.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiWindowSettings.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiWindowSettings) global::ImGui.ImGuiWindowSettings.NativeToManagedMap[((global::ImGui.ImVectorImGuiWindowSettings.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiWindowSettings.__CreateInstance(((global::ImGui.ImVectorImGuiWindowSettings.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiWindowSettings.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImChunkStreamImGuiWindowSettings : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVectorImGuiWindowSettings.__Internal Buf;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImChunkStream_ImGuiWindowSettings@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImChunkStreamImGuiWindowSettings> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImChunkStreamImGuiWindowSettings>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImChunkStreamImGuiWindowSettings __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImChunkStreamImGuiWindowSettings(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImChunkStreamImGuiWindowSettings __CreateInstance(global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImChunkStreamImGuiWindowSettings(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal));
            *(global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImChunkStreamImGuiWindowSettings(global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImChunkStreamImGuiWindowSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImChunkStreamImGuiWindowSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImChunkStreamImGuiWindowSettings(global::ImGui.ImChunkStreamImGuiWindowSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal*) __Instance) = *((global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImChunkStreamImGuiWindowSettings __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVectorImGuiWindowSettings Buf
        {
            get
            {
                return global::ImGui.ImVectorImGuiWindowSettings.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal*) __Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal*)__Instance)->Buf = *(global::ImGui.ImVectorImGuiWindowSettings.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class StbUndoRecord : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int @where;

            [FieldOffset(4)]
            internal int insert_length;

            [FieldOffset(8)]
            internal int delete_length;

            [FieldOffset(12)]
            internal int char_storage;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0StbUndoRecord@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.StbUndoRecord> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.StbUndoRecord>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.StbUndoRecord __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.StbUndoRecord(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.StbUndoRecord __CreateInstance(global::ImGui.StbUndoRecord.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.StbUndoRecord(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.StbUndoRecord.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.StbUndoRecord.__Internal));
            *(global::ImGui.StbUndoRecord.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbUndoRecord(global::ImGui.StbUndoRecord.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbUndoRecord(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public StbUndoRecord()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.StbUndoRecord.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbUndoRecord(global::ImGui.StbUndoRecord _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.StbUndoRecord.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.StbUndoRecord.__Internal*) __Instance) = *((global::ImGui.StbUndoRecord.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.StbUndoRecord __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Where
        {
            get
            {
                return ((global::ImGui.StbUndoRecord.__Internal*) __Instance)->@where;
            }

            set
            {
                ((global::ImGui.StbUndoRecord.__Internal*)__Instance)->@where = value;
            }
        }

        public int InsertLength
        {
            get
            {
                return ((global::ImGui.StbUndoRecord.__Internal*) __Instance)->insert_length;
            }

            set
            {
                ((global::ImGui.StbUndoRecord.__Internal*)__Instance)->insert_length = value;
            }
        }

        public int DeleteLength
        {
            get
            {
                return ((global::ImGui.StbUndoRecord.__Internal*) __Instance)->delete_length;
            }

            set
            {
                ((global::ImGui.StbUndoRecord.__Internal*)__Instance)->delete_length = value;
            }
        }

        public int CharStorage
        {
            get
            {
                return ((global::ImGui.StbUndoRecord.__Internal*) __Instance)->char_storage;
            }

            set
            {
                ((global::ImGui.StbUndoRecord.__Internal*)__Instance)->char_storage = value;
            }
        }
    }

    public unsafe partial class StbUndoState : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 3596)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed byte undo_rec[1584];

            [FieldOffset(1584)]
            internal fixed ushort undo_char[999];

            [FieldOffset(3582)]
            internal short undo_point;

            [FieldOffset(3584)]
            internal short redo_point;

            [FieldOffset(3588)]
            internal int undo_char_point;

            [FieldOffset(3592)]
            internal int redo_char_point;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0StbUndoState@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.StbUndoState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.StbUndoState>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.StbUndoState __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.StbUndoState(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.StbUndoState __CreateInstance(global::ImGui.StbUndoState.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.StbUndoState(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.StbUndoState.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.StbUndoState.__Internal));
            *(global::ImGui.StbUndoState.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbUndoState(global::ImGui.StbUndoState.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbUndoState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public StbUndoState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.StbUndoState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbUndoState(global::ImGui.StbUndoState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.StbUndoState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.StbUndoState.__Internal*) __Instance) = *((global::ImGui.StbUndoState.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.StbUndoState __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.StbUndoRecord[] UndoRec
        {
            get
            {
                global::ImGui.StbUndoRecord[] __value = null;
                if (((global::ImGui.StbUndoState.__Internal*) __Instance)->undo_rec != null)
                {
                    __value = new global::ImGui.StbUndoRecord[99];
                    for (int i = 0; i < 99; i++)
                        __value[i] = global::ImGui.StbUndoRecord.__CreateInstance(*((global::ImGui.StbUndoRecord.__Internal*)&(((global::ImGui.StbUndoState.__Internal*) __Instance)->undo_rec[i * sizeof(global::ImGui.StbUndoRecord.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 99)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 99; i++)
                        *(global::ImGui.StbUndoRecord.__Internal*) &((global::ImGui.StbUndoState.__Internal*)__Instance)->undo_rec[i * sizeof(global::ImGui.StbUndoRecord.__Internal)] = *(global::ImGui.StbUndoRecord.__Internal*)value[i].__Instance;
                }
            }
        }

        public ushort[] UndoChar
        {
            get
            {
                ushort[] __value = null;
                if (((global::ImGui.StbUndoState.__Internal*) __Instance)->undo_char != null)
                {
                    __value = new ushort[999];
                    for (int i = 0; i < 999; i++)
                        __value[i] = ((global::ImGui.StbUndoState.__Internal*) __Instance)->undo_char[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 999; i++)
                        ((global::ImGui.StbUndoState.__Internal*)__Instance)->undo_char[i] = value[i];
                }
            }
        }

        public short UndoPoint
        {
            get
            {
                return ((global::ImGui.StbUndoState.__Internal*) __Instance)->undo_point;
            }

            set
            {
                ((global::ImGui.StbUndoState.__Internal*)__Instance)->undo_point = value;
            }
        }

        public short RedoPoint
        {
            get
            {
                return ((global::ImGui.StbUndoState.__Internal*) __Instance)->redo_point;
            }

            set
            {
                ((global::ImGui.StbUndoState.__Internal*)__Instance)->redo_point = value;
            }
        }

        public int UndoCharPoint
        {
            get
            {
                return ((global::ImGui.StbUndoState.__Internal*) __Instance)->undo_char_point;
            }

            set
            {
                ((global::ImGui.StbUndoState.__Internal*)__Instance)->undo_char_point = value;
            }
        }

        public int RedoCharPoint
        {
            get
            {
                return ((global::ImGui.StbUndoState.__Internal*) __Instance)->redo_char_point;
            }

            set
            {
                ((global::ImGui.StbUndoState.__Internal*)__Instance)->redo_char_point = value;
            }
        }
    }

    public unsafe partial class STB_TexteditState : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 3620)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int cursor;

            [FieldOffset(4)]
            internal int select_start;

            [FieldOffset(8)]
            internal int select_end;

            [FieldOffset(12)]
            internal byte insert_mode;

            [FieldOffset(13)]
            internal byte cursor_at_end_of_line;

            [FieldOffset(14)]
            internal byte initialized;

            [FieldOffset(15)]
            internal byte has_preferred_x;

            [FieldOffset(16)]
            internal byte single_line;

            [FieldOffset(17)]
            internal byte padding1;

            [FieldOffset(18)]
            internal byte padding2;

            [FieldOffset(19)]
            internal byte padding3;

            [FieldOffset(20)]
            internal float preferred_x;

            [FieldOffset(24)]
            internal global::ImGui.StbUndoState.__Internal undostate;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0STB_TexteditState@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.STB_TexteditState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.STB_TexteditState>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.STB_TexteditState __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.STB_TexteditState(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.STB_TexteditState __CreateInstance(global::ImGui.STB_TexteditState.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.STB_TexteditState(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.STB_TexteditState.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.STB_TexteditState.__Internal));
            *(global::ImGui.STB_TexteditState.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private STB_TexteditState(global::ImGui.STB_TexteditState.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected STB_TexteditState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public STB_TexteditState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.STB_TexteditState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public STB_TexteditState(global::ImGui.STB_TexteditState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.STB_TexteditState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.STB_TexteditState.__Internal*) __Instance) = *((global::ImGui.STB_TexteditState.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.STB_TexteditState __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Cursor
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->cursor;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->cursor = value;
            }
        }

        public int SelectStart
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->select_start;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->select_start = value;
            }
        }

        public int SelectEnd
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->select_end;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->select_end = value;
            }
        }

        public byte InsertMode
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->insert_mode;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->insert_mode = value;
            }
        }

        public byte CursorAtEndOfLine
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->cursor_at_end_of_line;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->cursor_at_end_of_line = value;
            }
        }

        public byte Initialized
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->initialized;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->initialized = value;
            }
        }

        public byte HasPreferredX
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->has_preferred_x;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->has_preferred_x = value;
            }
        }

        public byte SingleLine
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->single_line;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->single_line = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->padding1;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->padding2;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->padding2 = value;
            }
        }

        public byte Padding3
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->padding3;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->padding3 = value;
            }
        }

        public float PreferredX
        {
            get
            {
                return ((global::ImGui.STB_TexteditState.__Internal*) __Instance)->preferred_x;
            }

            set
            {
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->preferred_x = value;
            }
        }

        public global::ImGui.StbUndoState Undostate
        {
            get
            {
                return global::ImGui.StbUndoState.__CreateInstance(new global::System.IntPtr(&((global::ImGui.STB_TexteditState.__Internal*) __Instance)->undostate));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.STB_TexteditState.__Internal*)__Instance)->undostate = *(global::ImGui.StbUndoState.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class StbTexteditRow : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float x0;

            [FieldOffset(4)]
            internal float x1;

            [FieldOffset(8)]
            internal float baseline_y_delta;

            [FieldOffset(12)]
            internal float ymin;

            [FieldOffset(16)]
            internal float ymax;

            [FieldOffset(20)]
            internal int num_chars;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0StbTexteditRow@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.StbTexteditRow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.StbTexteditRow>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.StbTexteditRow __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.StbTexteditRow(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.StbTexteditRow __CreateInstance(global::ImGui.StbTexteditRow.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.StbTexteditRow(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.StbTexteditRow.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.StbTexteditRow.__Internal));
            *(global::ImGui.StbTexteditRow.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbTexteditRow(global::ImGui.StbTexteditRow.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbTexteditRow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public StbTexteditRow()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.StbTexteditRow.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbTexteditRow(global::ImGui.StbTexteditRow _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.StbTexteditRow.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.StbTexteditRow.__Internal*) __Instance) = *((global::ImGui.StbTexteditRow.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.StbTexteditRow __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X0
        {
            get
            {
                return ((global::ImGui.StbTexteditRow.__Internal*) __Instance)->x0;
            }

            set
            {
                ((global::ImGui.StbTexteditRow.__Internal*)__Instance)->x0 = value;
            }
        }

        public float X1
        {
            get
            {
                return ((global::ImGui.StbTexteditRow.__Internal*) __Instance)->x1;
            }

            set
            {
                ((global::ImGui.StbTexteditRow.__Internal*)__Instance)->x1 = value;
            }
        }

        public float BaselineYDelta
        {
            get
            {
                return ((global::ImGui.StbTexteditRow.__Internal*) __Instance)->baseline_y_delta;
            }

            set
            {
                ((global::ImGui.StbTexteditRow.__Internal*)__Instance)->baseline_y_delta = value;
            }
        }

        public float Ymin
        {
            get
            {
                return ((global::ImGui.StbTexteditRow.__Internal*) __Instance)->ymin;
            }

            set
            {
                ((global::ImGui.StbTexteditRow.__Internal*)__Instance)->ymin = value;
            }
        }

        public float Ymax
        {
            get
            {
                return ((global::ImGui.StbTexteditRow.__Internal*) __Instance)->ymax;
            }

            set
            {
                ((global::ImGui.StbTexteditRow.__Internal*)__Instance)->ymax = value;
            }
        }

        public int NumChars
        {
            get
            {
                return ((global::ImGui.StbTexteditRow.__Internal*) __Instance)->num_chars;
            }

            set
            {
                ((global::ImGui.StbTexteditRow.__Internal*)__Instance)->num_chars = value;
            }
        }
    }

    public unsafe partial class ImVec2 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float x;

            [FieldOffset(4)]
            internal float y;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVec2@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec2ih_ImVec2ihVec2")]
            internal static extern global::System.IntPtr IhImVec2ihVec2(global::System.IntPtr __instance);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVec2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVec2>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVec2 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVec2(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVec2 __CreateInstance(global::ImGui.ImVec2.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVec2(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVec2.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec2.__Internal));
            *(global::ImGui.ImVec2.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec2(global::ImGui.ImVec2.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVec2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVec2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVec2(global::ImGui.ImVec2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVec2.__Internal*) __Instance) = *((global::ImGui.ImVec2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVec2 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((global::ImGui.ImVec2.__Internal*) __Instance)->x;
            }

            set
            {
                ((global::ImGui.ImVec2.__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((global::ImGui.ImVec2.__Internal*) __Instance)->y;
            }

            set
            {
                ((global::ImGui.ImVec2.__Internal*)__Instance)->y = value;
            }
        }

        public global::ImGui.ImVec2ih IhImVec2ihVec2
        {
            get
            {
                var __ret = __Internal.IhImVec2ihVec2(__Instance);
                global::ImGui.ImVec2ih __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImVec2ih.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::ImGui.ImVec2ih) global::ImGui.ImVec2ih.NativeToManagedMap[__ret];
                else __result0 = global::ImGui.ImVec2ih.__CreateInstance(__ret);
                return __result0;
            }
        }
    }

    public unsafe partial class ImVec4 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float x;

            [FieldOffset(4)]
            internal float y;

            [FieldOffset(8)]
            internal float z;

            [FieldOffset(12)]
            internal float w;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVec4@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVec4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVec4>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVec4 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVec4(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVec4 __CreateInstance(global::ImGui.ImVec4.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVec4(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVec4.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec4.__Internal));
            *(global::ImGui.ImVec4.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec4(global::ImGui.ImVec4.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVec4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVec4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVec4(global::ImGui.ImVec4 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVec4.__Internal*) __Instance) = *((global::ImGui.ImVec4.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVec4 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((global::ImGui.ImVec4.__Internal*) __Instance)->x;
            }

            set
            {
                ((global::ImGui.ImVec4.__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((global::ImGui.ImVec4.__Internal*) __Instance)->y;
            }

            set
            {
                ((global::ImGui.ImVec4.__Internal*)__Instance)->y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((global::ImGui.ImVec4.__Internal*) __Instance)->z;
            }

            set
            {
                ((global::ImGui.ImVec4.__Internal*)__Instance)->z = value;
            }
        }

        public float W
        {
            get
            {
                return ((global::ImGui.ImVec4.__Internal*) __Instance)->w;
            }

            set
            {
                ((global::ImGui.ImVec4.__Internal*)__Instance)->w = value;
            }
        }
    }

    public unsafe partial class ImGuiStyle : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 948)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float Alpha;

            [FieldOffset(4)]
            internal global::ImGui.ImVec2.__Internal WindowPadding;

            [FieldOffset(12)]
            internal float WindowRounding;

            [FieldOffset(16)]
            internal float WindowBorderSize;

            [FieldOffset(20)]
            internal global::ImGui.ImVec2.__Internal WindowMinSize;

            [FieldOffset(28)]
            internal global::ImGui.ImVec2.__Internal WindowTitleAlign;

            [FieldOffset(36)]
            internal int WindowMenuButtonPosition;

            [FieldOffset(40)]
            internal float ChildRounding;

            [FieldOffset(44)]
            internal float ChildBorderSize;

            [FieldOffset(48)]
            internal float PopupRounding;

            [FieldOffset(52)]
            internal float PopupBorderSize;

            [FieldOffset(56)]
            internal global::ImGui.ImVec2.__Internal FramePadding;

            [FieldOffset(64)]
            internal float FrameRounding;

            [FieldOffset(68)]
            internal float FrameBorderSize;

            [FieldOffset(72)]
            internal global::ImGui.ImVec2.__Internal ItemSpacing;

            [FieldOffset(80)]
            internal global::ImGui.ImVec2.__Internal ItemInnerSpacing;

            [FieldOffset(88)]
            internal global::ImGui.ImVec2.__Internal TouchExtraPadding;

            [FieldOffset(96)]
            internal float IndentSpacing;

            [FieldOffset(100)]
            internal float ColumnsMinSpacing;

            [FieldOffset(104)]
            internal float ScrollbarSize;

            [FieldOffset(108)]
            internal float ScrollbarRounding;

            [FieldOffset(112)]
            internal float GrabMinSize;

            [FieldOffset(116)]
            internal float GrabRounding;

            [FieldOffset(120)]
            internal float TabRounding;

            [FieldOffset(124)]
            internal float TabBorderSize;

            [FieldOffset(128)]
            internal int ColorButtonPosition;

            [FieldOffset(132)]
            internal global::ImGui.ImVec2.__Internal ButtonTextAlign;

            [FieldOffset(140)]
            internal global::ImGui.ImVec2.__Internal SelectableTextAlign;

            [FieldOffset(148)]
            internal global::ImGui.ImVec2.__Internal DisplayWindowPadding;

            [FieldOffset(156)]
            internal global::ImGui.ImVec2.__Internal DisplaySafeAreaPadding;

            [FieldOffset(164)]
            internal float MouseCursorScale;

            [FieldOffset(168)]
            internal byte AntiAliasedLines;

            [FieldOffset(169)]
            internal byte AntiAliasedFill;

            [FieldOffset(172)]
            internal float CurveTessellationTol;

            [FieldOffset(176)]
            internal float CircleSegmentMaxError;

            [FieldOffset(180)]
            internal fixed byte Colors[768];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiStyle@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiStyle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiStyle>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiStyle __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiStyle(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiStyle __CreateInstance(global::ImGui.ImGuiStyle.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiStyle(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiStyle.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStyle.__Internal));
            *(global::ImGui.ImGuiStyle.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStyle(global::ImGui.ImGuiStyle.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiStyle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiStyle()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStyle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiStyle(global::ImGui.ImGuiStyle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStyle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiStyle.__Internal*) __Instance) = *((global::ImGui.ImGuiStyle.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiStyle __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Alpha
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->Alpha;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->Alpha = value;
            }
        }

        public global::ImGui.ImVec2 WindowPadding
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStyle.__Internal*) __Instance)->WindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->WindowPadding = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float WindowRounding
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->WindowRounding;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->WindowRounding = value;
            }
        }

        public float WindowBorderSize
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->WindowBorderSize;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->WindowBorderSize = value;
            }
        }

        public global::ImGui.ImVec2 WindowMinSize
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStyle.__Internal*) __Instance)->WindowMinSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->WindowMinSize = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 WindowTitleAlign
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStyle.__Internal*) __Instance)->WindowTitleAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->WindowTitleAlign = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public int WindowMenuButtonPosition
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->WindowMenuButtonPosition;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->WindowMenuButtonPosition = value;
            }
        }

        public float ChildRounding
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->ChildRounding;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->ChildRounding = value;
            }
        }

        public float ChildBorderSize
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->ChildBorderSize;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->ChildBorderSize = value;
            }
        }

        public float PopupRounding
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->PopupRounding;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->PopupRounding = value;
            }
        }

        public float PopupBorderSize
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->PopupBorderSize;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->PopupBorderSize = value;
            }
        }

        public global::ImGui.ImVec2 FramePadding
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStyle.__Internal*) __Instance)->FramePadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->FramePadding = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float FrameRounding
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->FrameRounding;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->FrameRounding = value;
            }
        }

        public float FrameBorderSize
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->FrameBorderSize;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->FrameBorderSize = value;
            }
        }

        public global::ImGui.ImVec2 ItemSpacing
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStyle.__Internal*) __Instance)->ItemSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->ItemSpacing = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 ItemInnerSpacing
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStyle.__Internal*) __Instance)->ItemInnerSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->ItemInnerSpacing = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 TouchExtraPadding
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStyle.__Internal*) __Instance)->TouchExtraPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->TouchExtraPadding = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float IndentSpacing
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->IndentSpacing;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->IndentSpacing = value;
            }
        }

        public float ColumnsMinSpacing
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->ColumnsMinSpacing;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->ColumnsMinSpacing = value;
            }
        }

        public float ScrollbarSize
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->ScrollbarSize;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->ScrollbarSize = value;
            }
        }

        public float ScrollbarRounding
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->ScrollbarRounding;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->ScrollbarRounding = value;
            }
        }

        public float GrabMinSize
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->GrabMinSize;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->GrabMinSize = value;
            }
        }

        public float GrabRounding
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->GrabRounding;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->GrabRounding = value;
            }
        }

        public float TabRounding
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->TabRounding;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->TabRounding = value;
            }
        }

        public float TabBorderSize
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->TabBorderSize;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->TabBorderSize = value;
            }
        }

        public int ColorButtonPosition
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->ColorButtonPosition;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->ColorButtonPosition = value;
            }
        }

        public global::ImGui.ImVec2 ButtonTextAlign
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStyle.__Internal*) __Instance)->ButtonTextAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->ButtonTextAlign = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 SelectableTextAlign
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStyle.__Internal*) __Instance)->SelectableTextAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->SelectableTextAlign = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 DisplayWindowPadding
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStyle.__Internal*) __Instance)->DisplayWindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->DisplayWindowPadding = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 DisplaySafeAreaPadding
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStyle.__Internal*) __Instance)->DisplaySafeAreaPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->DisplaySafeAreaPadding = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float MouseCursorScale
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->MouseCursorScale;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->MouseCursorScale = value;
            }
        }

        public bool AntiAliasedLines
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->AntiAliasedLines != 0;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->AntiAliasedLines = (byte) (value ? 1 : 0);
            }
        }

        public bool AntiAliasedFill
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->AntiAliasedFill != 0;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->AntiAliasedFill = (byte) (value ? 1 : 0);
            }
        }

        public float CurveTessellationTol
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->CurveTessellationTol;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->CurveTessellationTol = value;
            }
        }

        public float CircleSegmentMaxError
        {
            get
            {
                return ((global::ImGui.ImGuiStyle.__Internal*) __Instance)->CircleSegmentMaxError;
            }

            set
            {
                ((global::ImGui.ImGuiStyle.__Internal*)__Instance)->CircleSegmentMaxError = value;
            }
        }

        public global::ImGui.ImVec4[] Colors
        {
            get
            {
                global::ImGui.ImVec4[] __value = null;
                if (((global::ImGui.ImGuiStyle.__Internal*) __Instance)->Colors != null)
                {
                    __value = new global::ImGui.ImVec4[48];
                    for (int i = 0; i < 48; i++)
                        __value[i] = global::ImGui.ImVec4.__CreateInstance(*((global::ImGui.ImVec4.__Internal*)&(((global::ImGui.ImGuiStyle.__Internal*) __Instance)->Colors[i * sizeof(global::ImGui.ImVec4.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 48)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 48; i++)
                        *(global::ImGui.ImVec4.__Internal*) &((global::ImGui.ImGuiStyle.__Internal*)__Instance)->Colors[i * sizeof(global::ImGui.ImVec4.__Internal)] = *(global::ImGui.ImVec4.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class ImGuiIO : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 5456)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int ConfigFlags;

            [FieldOffset(4)]
            internal int BackendFlags;

            [FieldOffset(8)]
            internal global::ImGui.ImVec2.__Internal DisplaySize;

            [FieldOffset(16)]
            internal float DeltaTime;

            [FieldOffset(20)]
            internal float IniSavingRate;

            [FieldOffset(24)]
            internal global::System.IntPtr IniFilename;

            [FieldOffset(32)]
            internal global::System.IntPtr LogFilename;

            [FieldOffset(40)]
            internal float MouseDoubleClickTime;

            [FieldOffset(44)]
            internal float MouseDoubleClickMaxDist;

            [FieldOffset(48)]
            internal float MouseDragThreshold;

            [FieldOffset(52)]
            internal fixed int KeyMap[22];

            [FieldOffset(140)]
            internal float KeyRepeatDelay;

            [FieldOffset(144)]
            internal float KeyRepeatRate;

            [FieldOffset(152)]
            internal global::System.IntPtr UserData;

            [FieldOffset(160)]
            internal global::System.IntPtr Fonts;

            [FieldOffset(168)]
            internal float FontGlobalScale;

            [FieldOffset(172)]
            internal byte FontAllowUserScaling;

            [FieldOffset(176)]
            internal global::System.IntPtr FontDefault;

            [FieldOffset(184)]
            internal global::ImGui.ImVec2.__Internal DisplayFramebufferScale;

            [FieldOffset(192)]
            internal byte MouseDrawCursor;

            [FieldOffset(193)]
            internal byte ConfigMacOSXBehaviors;

            [FieldOffset(194)]
            internal byte ConfigInputTextCursorBlink;

            [FieldOffset(195)]
            internal byte ConfigWindowsResizeFromEdges;

            [FieldOffset(196)]
            internal byte ConfigWindowsMoveFromTitleBarOnly;

            [FieldOffset(200)]
            internal float ConfigWindowsMemoryCompactTimer;

            [FieldOffset(208)]
            internal global::System.IntPtr BackendPlatformName;

            [FieldOffset(216)]
            internal global::System.IntPtr BackendRendererName;

            [FieldOffset(224)]
            internal global::System.IntPtr BackendPlatformUserData;

            [FieldOffset(232)]
            internal global::System.IntPtr BackendRendererUserData;

            [FieldOffset(240)]
            internal global::System.IntPtr BackendLanguageUserData;

            [FieldOffset(248)]
            internal global::System.IntPtr GetClipboardTextFn;

            [FieldOffset(256)]
            internal global::System.IntPtr SetClipboardTextFn;

            [FieldOffset(264)]
            internal global::System.IntPtr ClipboardUserData;

            [FieldOffset(272)]
            internal global::System.IntPtr ImeSetInputScreenPosFn;

            [FieldOffset(280)]
            internal global::System.IntPtr ImeWindowHandle;

            [FieldOffset(288)]
            internal global::System.IntPtr RenderDrawListsFnUnused;

            [FieldOffset(296)]
            internal global::ImGui.ImVec2.__Internal MousePos;

            [FieldOffset(304)]
            internal fixed byte MouseDown[5];

            [FieldOffset(312)]
            internal float MouseWheel;

            [FieldOffset(316)]
            internal float MouseWheelH;

            [FieldOffset(320)]
            internal byte KeyCtrl;

            [FieldOffset(321)]
            internal byte KeyShift;

            [FieldOffset(322)]
            internal byte KeyAlt;

            [FieldOffset(323)]
            internal byte KeySuper;

            [FieldOffset(324)]
            internal fixed byte KeysDown[512];

            [FieldOffset(836)]
            internal fixed float NavInputs[21];

            [FieldOffset(920)]
            internal byte WantCaptureMouse;

            [FieldOffset(921)]
            internal byte WantCaptureKeyboard;

            [FieldOffset(922)]
            internal byte WantTextInput;

            [FieldOffset(923)]
            internal byte WantSetMousePos;

            [FieldOffset(924)]
            internal byte WantSaveIniSettings;

            [FieldOffset(925)]
            internal byte NavActive;

            [FieldOffset(926)]
            internal byte NavVisible;

            [FieldOffset(928)]
            internal float Framerate;

            [FieldOffset(932)]
            internal int MetricsRenderVertices;

            [FieldOffset(936)]
            internal int MetricsRenderIndices;

            [FieldOffset(940)]
            internal int MetricsRenderWindows;

            [FieldOffset(944)]
            internal int MetricsActiveWindows;

            [FieldOffset(948)]
            internal int MetricsActiveAllocations;

            [FieldOffset(952)]
            internal global::ImGui.ImVec2.__Internal MouseDelta;

            [FieldOffset(960)]
            internal global::ImGui.ImVec2.__Internal MousePosPrev;

            [FieldOffset(968)]
            internal fixed byte MouseClickedPos[40];

            [FieldOffset(1008)]
            internal fixed double MouseClickedTime[5];

            [FieldOffset(1048)]
            internal fixed byte MouseClicked[5];

            [FieldOffset(1053)]
            internal fixed byte MouseDoubleClicked[5];

            [FieldOffset(1058)]
            internal fixed byte MouseReleased[5];

            [FieldOffset(1063)]
            internal fixed byte MouseDownOwned[5];

            [FieldOffset(1068)]
            internal fixed byte MouseDownWasDoubleClick[5];

            [FieldOffset(1076)]
            internal fixed float MouseDownDuration[5];

            [FieldOffset(1096)]
            internal fixed float MouseDownDurationPrev[5];

            [FieldOffset(1116)]
            internal fixed byte MouseDragMaxDistanceAbs[40];

            [FieldOffset(1156)]
            internal fixed float MouseDragMaxDistanceSqr[5];

            [FieldOffset(1176)]
            internal fixed float KeysDownDuration[512];

            [FieldOffset(3224)]
            internal fixed float KeysDownDurationPrev[512];

            [FieldOffset(5272)]
            internal fixed float NavInputsDownDuration[21];

            [FieldOffset(5356)]
            internal fixed float NavInputsDownDurationPrev[21];

            [FieldOffset(5440)]
            internal global::ImGui.ImVectorImWchar.__Internal InputQueueCharacters;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiIO@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiIO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiIO>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiIO __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiIO(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiIO __CreateInstance(global::ImGui.ImGuiIO.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiIO(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiIO.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiIO.__Internal));
            *(global::ImGui.ImGuiIO.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiIO(global::ImGui.ImGuiIO.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiIO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiIO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiIO(global::ImGui.ImGuiIO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiIO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiIO.__Internal*) __Instance) = *((global::ImGui.ImGuiIO.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiIO __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int ConfigFlags
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->ConfigFlags;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->ConfigFlags = value;
            }
        }

        public int BackendFlags
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->BackendFlags;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->BackendFlags = value;
            }
        }

        public global::ImGui.ImVec2 DisplaySize
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiIO.__Internal*) __Instance)->DisplaySize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->DisplaySize = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float DeltaTime
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->DeltaTime;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->DeltaTime = value;
            }
        }

        public float IniSavingRate
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->IniSavingRate;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->IniSavingRate = value;
            }
        }

        public string IniFilename
        {
            get
            {
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->IniFilename == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::ImGui.ImGuiIO.__Internal*) __Instance)->IniFilename;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::ImGui.ImGuiIO.__Internal*) __Instance)->IniFilename, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::ImGui.ImGuiIO.__Internal*)__Instance)->IniFilename = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string LogFilename
        {
            get
            {
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->LogFilename == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::ImGui.ImGuiIO.__Internal*) __Instance)->LogFilename;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::ImGui.ImGuiIO.__Internal*) __Instance)->LogFilename, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::ImGui.ImGuiIO.__Internal*)__Instance)->LogFilename = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public float MouseDoubleClickTime
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDoubleClickTime;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDoubleClickTime = value;
            }
        }

        public float MouseDoubleClickMaxDist
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDoubleClickMaxDist;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDoubleClickMaxDist = value;
            }
        }

        public float MouseDragThreshold
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDragThreshold;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDragThreshold = value;
            }
        }

        public int[] KeyMap
        {
            get
            {
                int[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeyMap != null)
                {
                    __value = new int[22];
                    for (int i = 0; i < 22; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeyMap[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 22; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->KeyMap[i] = value[i];
                }
            }
        }

        public float KeyRepeatDelay
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeyRepeatDelay;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->KeyRepeatDelay = value;
            }
        }

        public float KeyRepeatRate
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeyRepeatRate;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->KeyRepeatRate = value;
            }
        }

        public global::System.IntPtr UserData
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->UserData;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->UserData = (global::System.IntPtr) value;
            }
        }

        public global::ImGui.ImFontAtlas Fonts
        {
            get
            {
                global::ImGui.ImFontAtlas __result0;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->Fonts == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFontAtlas.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiIO.__Internal*) __Instance)->Fonts))
                    __result0 = (global::ImGui.ImFontAtlas) global::ImGui.ImFontAtlas.NativeToManagedMap[((global::ImGui.ImGuiIO.__Internal*) __Instance)->Fonts];
                else __result0 = global::ImGui.ImFontAtlas.__CreateInstance(((global::ImGui.ImGuiIO.__Internal*) __Instance)->Fonts);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->Fonts = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public float FontGlobalScale
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->FontGlobalScale;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->FontGlobalScale = value;
            }
        }

        public bool FontAllowUserScaling
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->FontAllowUserScaling != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->FontAllowUserScaling = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGui.ImFont FontDefault
        {
            get
            {
                global::ImGui.ImFont __result0;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->FontDefault == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiIO.__Internal*) __Instance)->FontDefault))
                    __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[((global::ImGui.ImGuiIO.__Internal*) __Instance)->FontDefault];
                else __result0 = global::ImGui.ImFont.__CreateInstance(((global::ImGui.ImGuiIO.__Internal*) __Instance)->FontDefault);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->FontDefault = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImVec2 DisplayFramebufferScale
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiIO.__Internal*) __Instance)->DisplayFramebufferScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->DisplayFramebufferScale = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool MouseDrawCursor
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDrawCursor != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDrawCursor = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigMacOSXBehaviors
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->ConfigMacOSXBehaviors != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->ConfigMacOSXBehaviors = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigInputTextCursorBlink
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->ConfigInputTextCursorBlink != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->ConfigInputTextCursorBlink = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigWindowsResizeFromEdges
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->ConfigWindowsResizeFromEdges != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->ConfigWindowsResizeFromEdges = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigWindowsMoveFromTitleBarOnly
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->ConfigWindowsMoveFromTitleBarOnly != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->ConfigWindowsMoveFromTitleBarOnly = (byte) (value ? 1 : 0);
            }
        }

        public float ConfigWindowsMemoryCompactTimer
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->ConfigWindowsMemoryCompactTimer;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->ConfigWindowsMemoryCompactTimer = value;
            }
        }

        public string BackendPlatformName
        {
            get
            {
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->BackendPlatformName == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::ImGui.ImGuiIO.__Internal*) __Instance)->BackendPlatformName;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::ImGui.ImGuiIO.__Internal*) __Instance)->BackendPlatformName, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::ImGui.ImGuiIO.__Internal*)__Instance)->BackendPlatformName = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string BackendRendererName
        {
            get
            {
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->BackendRendererName == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::ImGui.ImGuiIO.__Internal*) __Instance)->BackendRendererName;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::ImGui.ImGuiIO.__Internal*) __Instance)->BackendRendererName, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::ImGui.ImGuiIO.__Internal*)__Instance)->BackendRendererName = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public global::System.IntPtr BackendPlatformUserData
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->BackendPlatformUserData;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->BackendPlatformUserData = (global::System.IntPtr) value;
            }
        }

        public global::System.IntPtr BackendRendererUserData
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->BackendRendererUserData;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->BackendRendererUserData = (global::System.IntPtr) value;
            }
        }

        public global::System.IntPtr BackendLanguageUserData
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->BackendLanguageUserData;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->BackendLanguageUserData = (global::System.IntPtr) value;
            }
        }

        public global::ImGui.Delegates.Func_IntPtr_IntPtr GetClipboardTextFn
        {
            get
            {
                var __ptr0 = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->GetClipboardTextFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGui.Delegates.Func_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGui.Delegates.Func_IntPtr_IntPtr));
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->GetClipboardTextFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::ImGui.Delegates.Action_IntPtr_string SetClipboardTextFn
        {
            get
            {
                var __ptr0 = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->SetClipboardTextFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGui.Delegates.Action_IntPtr_string) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGui.Delegates.Action_IntPtr_string));
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->SetClipboardTextFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr ClipboardUserData
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->ClipboardUserData;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->ClipboardUserData = (global::System.IntPtr) value;
            }
        }

        public global::ImGui.Delegates.Action_int_int ImeSetInputScreenPosFn
        {
            get
            {
                var __ptr0 = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->ImeSetInputScreenPosFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGui.Delegates.Action_int_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGui.Delegates.Action_int_int));
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->ImeSetInputScreenPosFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr ImeWindowHandle
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->ImeWindowHandle;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->ImeWindowHandle = (global::System.IntPtr) value;
            }
        }

        public global::System.IntPtr RenderDrawListsFnUnused
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->RenderDrawListsFnUnused;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->RenderDrawListsFnUnused = (global::System.IntPtr) value;
            }
        }

        public global::ImGui.ImVec2 MousePos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiIO.__Internal*) __Instance)->MousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MousePos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool[] MouseDown
        {
            get
            {
                bool[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDown != null)
                {
                    __value = new bool[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDown[i] != 0;
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDown[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float MouseWheel
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseWheel;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseWheel = value;
            }
        }

        public float MouseWheelH
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseWheelH;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseWheelH = value;
            }
        }

        public bool KeyCtrl
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeyCtrl != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->KeyCtrl = (byte) (value ? 1 : 0);
            }
        }

        public bool KeyShift
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeyShift != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->KeyShift = (byte) (value ? 1 : 0);
            }
        }

        public bool KeyAlt
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeyAlt != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->KeyAlt = (byte) (value ? 1 : 0);
            }
        }

        public bool KeySuper
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeySuper != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->KeySuper = (byte) (value ? 1 : 0);
            }
        }

        public bool[] KeysDown
        {
            get
            {
                bool[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeysDown != null)
                {
                    __value = new bool[512];
                    for (int i = 0; i < 512; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeysDown[i] != 0;
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->KeysDown[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float[] NavInputs
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->NavInputs != null)
                {
                    __value = new float[21];
                    for (int i = 0; i < 21; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->NavInputs[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 21; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->NavInputs[i] = value[i];
                }
            }
        }

        public bool WantCaptureMouse
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->WantCaptureMouse != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->WantCaptureMouse = (byte) (value ? 1 : 0);
            }
        }

        public bool WantCaptureKeyboard
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->WantCaptureKeyboard != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->WantCaptureKeyboard = (byte) (value ? 1 : 0);
            }
        }

        public bool WantTextInput
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->WantTextInput != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->WantTextInput = (byte) (value ? 1 : 0);
            }
        }

        public bool WantSetMousePos
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->WantSetMousePos != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->WantSetMousePos = (byte) (value ? 1 : 0);
            }
        }

        public bool WantSaveIniSettings
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->WantSaveIniSettings != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->WantSaveIniSettings = (byte) (value ? 1 : 0);
            }
        }

        public bool NavActive
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->NavActive != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->NavActive = (byte) (value ? 1 : 0);
            }
        }

        public bool NavVisible
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->NavVisible != 0;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->NavVisible = (byte) (value ? 1 : 0);
            }
        }

        public float Framerate
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->Framerate;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->Framerate = value;
            }
        }

        public int MetricsRenderVertices
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MetricsRenderVertices;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MetricsRenderVertices = value;
            }
        }

        public int MetricsRenderIndices
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MetricsRenderIndices;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MetricsRenderIndices = value;
            }
        }

        public int MetricsRenderWindows
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MetricsRenderWindows;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MetricsRenderWindows = value;
            }
        }

        public int MetricsActiveWindows
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MetricsActiveWindows;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MetricsActiveWindows = value;
            }
        }

        public int MetricsActiveAllocations
        {
            get
            {
                return ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MetricsActiveAllocations;
            }

            set
            {
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MetricsActiveAllocations = value;
            }
        }

        public global::ImGui.ImVec2 MouseDelta
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDelta));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDelta = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 MousePosPrev
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiIO.__Internal*) __Instance)->MousePosPrev));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MousePosPrev = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2[] MouseClickedPos
        {
            get
            {
                global::ImGui.ImVec2[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseClickedPos != null)
                {
                    __value = new global::ImGui.ImVec2[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = global::ImGui.ImVec2.__CreateInstance(*((global::ImGui.ImVec2.__Internal*)&(((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseClickedPos[i * sizeof(global::ImGui.ImVec2.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 5)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 5; i++)
                        *(global::ImGui.ImVec2.__Internal*) &((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseClickedPos[i * sizeof(global::ImGui.ImVec2.__Internal)] = *(global::ImGui.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public double[] MouseClickedTime
        {
            get
            {
                double[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseClickedTime != null)
                {
                    __value = new double[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseClickedTime[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseClickedTime[i] = value[i];
                }
            }
        }

        public bool[] MouseClicked
        {
            get
            {
                bool[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseClicked != null)
                {
                    __value = new bool[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseClicked[i] != 0;
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseClicked[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDoubleClicked
        {
            get
            {
                bool[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDoubleClicked != null)
                {
                    __value = new bool[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDoubleClicked[i] != 0;
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDoubleClicked[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseReleased
        {
            get
            {
                bool[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseReleased != null)
                {
                    __value = new bool[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseReleased[i] != 0;
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseReleased[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDownOwned
        {
            get
            {
                bool[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDownOwned != null)
                {
                    __value = new bool[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDownOwned[i] != 0;
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDownOwned[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDownWasDoubleClick
        {
            get
            {
                bool[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDownWasDoubleClick != null)
                {
                    __value = new bool[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDownWasDoubleClick[i] != 0;
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDownWasDoubleClick[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float[] MouseDownDuration
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDownDuration != null)
                {
                    __value = new float[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDownDuration[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDownDuration[i] = value[i];
                }
            }
        }

        public float[] MouseDownDurationPrev
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDownDurationPrev != null)
                {
                    __value = new float[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDownDurationPrev[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDownDurationPrev[i] = value[i];
                }
            }
        }

        public global::ImGui.ImVec2[] MouseDragMaxDistanceAbs
        {
            get
            {
                global::ImGui.ImVec2[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDragMaxDistanceAbs != null)
                {
                    __value = new global::ImGui.ImVec2[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = global::ImGui.ImVec2.__CreateInstance(*((global::ImGui.ImVec2.__Internal*)&(((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDragMaxDistanceAbs[i * sizeof(global::ImGui.ImVec2.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 5)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 5; i++)
                        *(global::ImGui.ImVec2.__Internal*) &((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDragMaxDistanceAbs[i * sizeof(global::ImGui.ImVec2.__Internal)] = *(global::ImGui.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public float[] MouseDragMaxDistanceSqr
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDragMaxDistanceSqr != null)
                {
                    __value = new float[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->MouseDragMaxDistanceSqr[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->MouseDragMaxDistanceSqr[i] = value[i];
                }
            }
        }

        public float[] KeysDownDuration
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeysDownDuration != null)
                {
                    __value = new float[512];
                    for (int i = 0; i < 512; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeysDownDuration[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->KeysDownDuration[i] = value[i];
                }
            }
        }

        public float[] KeysDownDurationPrev
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeysDownDurationPrev != null)
                {
                    __value = new float[512];
                    for (int i = 0; i < 512; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->KeysDownDurationPrev[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->KeysDownDurationPrev[i] = value[i];
                }
            }
        }

        public float[] NavInputsDownDuration
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->NavInputsDownDuration != null)
                {
                    __value = new float[21];
                    for (int i = 0; i < 21; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->NavInputsDownDuration[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 21; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->NavInputsDownDuration[i] = value[i];
                }
            }
        }

        public float[] NavInputsDownDurationPrev
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiIO.__Internal*) __Instance)->NavInputsDownDurationPrev != null)
                {
                    __value = new float[21];
                    for (int i = 0; i < 21; i++)
                        __value[i] = ((global::ImGui.ImGuiIO.__Internal*) __Instance)->NavInputsDownDurationPrev[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 21; i++)
                        ((global::ImGui.ImGuiIO.__Internal*)__Instance)->NavInputsDownDurationPrev[i] = value[i];
                }
            }
        }

        public global::ImGui.ImVectorImWchar InputQueueCharacters
        {
            get
            {
                return global::ImGui.ImVectorImWchar.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiIO.__Internal*) __Instance)->InputQueueCharacters));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiIO.__Internal*)__Instance)->InputQueueCharacters = *(global::ImGui.ImVectorImWchar.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiInputTextCallbackData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int EventFlag;

            [FieldOffset(4)]
            internal int Flags;

            [FieldOffset(8)]
            internal global::System.IntPtr UserData;

            [FieldOffset(16)]
            internal ushort EventChar;

            [FieldOffset(20)]
            internal int EventKey;

            [FieldOffset(24)]
            internal global::System.IntPtr Buf;

            [FieldOffset(32)]
            internal int BufTextLen;

            [FieldOffset(36)]
            internal int BufSize;

            [FieldOffset(40)]
            internal byte BufDirty;

            [FieldOffset(44)]
            internal int CursorPos;

            [FieldOffset(48)]
            internal int SelectionStart;

            [FieldOffset(52)]
            internal int SelectionEnd;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiInputTextCallbackData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiInputTextCallbackData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiInputTextCallbackData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiInputTextCallbackData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiInputTextCallbackData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiInputTextCallbackData __CreateInstance(global::ImGui.ImGuiInputTextCallbackData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiInputTextCallbackData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiInputTextCallbackData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiInputTextCallbackData.__Internal));
            *(global::ImGui.ImGuiInputTextCallbackData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputTextCallbackData(global::ImGui.ImGuiInputTextCallbackData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiInputTextCallbackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiInputTextCallbackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiInputTextCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiInputTextCallbackData(global::ImGui.ImGuiInputTextCallbackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiInputTextCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance) = *((global::ImGui.ImGuiInputTextCallbackData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiInputTextCallbackData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int EventFlag
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->EventFlag;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->EventFlag = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->Flags;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->Flags = value;
            }
        }

        public global::System.IntPtr UserData
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->UserData;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->UserData = (global::System.IntPtr) value;
            }
        }

        public ushort EventChar
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->EventChar;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->EventChar = value;
            }
        }

        public int EventKey
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->EventKey;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->EventKey = value;
            }
        }

        public sbyte* Buf
        {
            get
            {
                return (sbyte*) ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->Buf;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->Buf = (global::System.IntPtr) value;
            }
        }

        public int BufTextLen
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->BufTextLen;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->BufTextLen = value;
            }
        }

        public int BufSize
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->BufSize;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->BufSize = value;
            }
        }

        public bool BufDirty
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->BufDirty != 0;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->BufDirty = (byte) (value ? 1 : 0);
            }
        }

        public int CursorPos
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->CursorPos;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->CursorPos = value;
            }
        }

        public int SelectionStart
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->SelectionStart;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->SelectionStart = value;
            }
        }

        public int SelectionEnd
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextCallbackData.__Internal*) __Instance)->SelectionEnd;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextCallbackData.__Internal*)__Instance)->SelectionEnd = value;
            }
        }
    }

    public unsafe partial class ImGuiSizeCallbackData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr UserData;

            [FieldOffset(8)]
            internal global::ImGui.ImVec2.__Internal Pos;

            [FieldOffset(16)]
            internal global::ImGui.ImVec2.__Internal CurrentSize;

            [FieldOffset(24)]
            internal global::ImGui.ImVec2.__Internal DesiredSize;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiSizeCallbackData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiSizeCallbackData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiSizeCallbackData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiSizeCallbackData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiSizeCallbackData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiSizeCallbackData __CreateInstance(global::ImGui.ImGuiSizeCallbackData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiSizeCallbackData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiSizeCallbackData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiSizeCallbackData.__Internal));
            *(global::ImGui.ImGuiSizeCallbackData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiSizeCallbackData(global::ImGui.ImGuiSizeCallbackData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiSizeCallbackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiSizeCallbackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiSizeCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiSizeCallbackData(global::ImGui.ImGuiSizeCallbackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiSizeCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiSizeCallbackData.__Internal*) __Instance) = *((global::ImGui.ImGuiSizeCallbackData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiSizeCallbackData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::System.IntPtr UserData
        {
            get
            {
                return ((global::ImGui.ImGuiSizeCallbackData.__Internal*) __Instance)->UserData;
            }

            set
            {
                ((global::ImGui.ImGuiSizeCallbackData.__Internal*)__Instance)->UserData = (global::System.IntPtr) value;
            }
        }

        public global::ImGui.ImVec2 Pos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiSizeCallbackData.__Internal*) __Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiSizeCallbackData.__Internal*)__Instance)->Pos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 CurrentSize
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiSizeCallbackData.__Internal*) __Instance)->CurrentSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiSizeCallbackData.__Internal*)__Instance)->CurrentSize = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 DesiredSize
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiSizeCallbackData.__Internal*) __Instance)->DesiredSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiSizeCallbackData.__Internal*)__Instance)->DesiredSize = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiPayload : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 64)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr Data;

            [FieldOffset(8)]
            internal int DataSize;

            [FieldOffset(12)]
            internal uint SourceId;

            [FieldOffset(16)]
            internal uint SourceParentId;

            [FieldOffset(20)]
            internal int DataFrameCount;

            [FieldOffset(24)]
            internal fixed sbyte DataType[33];

            [FieldOffset(57)]
            internal byte Preview;

            [FieldOffset(58)]
            internal byte Delivery;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiPayload@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiPayload> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiPayload>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiPayload __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiPayload(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiPayload __CreateInstance(global::ImGui.ImGuiPayload.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiPayload(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiPayload.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiPayload.__Internal));
            *(global::ImGui.ImGuiPayload.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPayload(global::ImGui.ImGuiPayload.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiPayload(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiPayload()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiPayload.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiPayload(global::ImGui.ImGuiPayload _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiPayload.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiPayload.__Internal*) __Instance) = *((global::ImGui.ImGuiPayload.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiPayload __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::System.IntPtr Data
        {
            get
            {
                return ((global::ImGui.ImGuiPayload.__Internal*) __Instance)->Data;
            }

            set
            {
                ((global::ImGui.ImGuiPayload.__Internal*)__Instance)->Data = (global::System.IntPtr) value;
            }
        }

        public int DataSize
        {
            get
            {
                return ((global::ImGui.ImGuiPayload.__Internal*) __Instance)->DataSize;
            }

            set
            {
                ((global::ImGui.ImGuiPayload.__Internal*)__Instance)->DataSize = value;
            }
        }

        public uint SourceId
        {
            get
            {
                return ((global::ImGui.ImGuiPayload.__Internal*) __Instance)->SourceId;
            }

            set
            {
                ((global::ImGui.ImGuiPayload.__Internal*)__Instance)->SourceId = value;
            }
        }

        public uint SourceParentId
        {
            get
            {
                return ((global::ImGui.ImGuiPayload.__Internal*) __Instance)->SourceParentId;
            }

            set
            {
                ((global::ImGui.ImGuiPayload.__Internal*)__Instance)->SourceParentId = value;
            }
        }

        public int DataFrameCount
        {
            get
            {
                return ((global::ImGui.ImGuiPayload.__Internal*) __Instance)->DataFrameCount;
            }

            set
            {
                ((global::ImGui.ImGuiPayload.__Internal*)__Instance)->DataFrameCount = value;
            }
        }

        public sbyte[] DataType
        {
            get
            {
                sbyte[] __value = null;
                if (((global::ImGui.ImGuiPayload.__Internal*) __Instance)->DataType != null)
                {
                    __value = new sbyte[33];
                    for (int i = 0; i < 33; i++)
                        __value[i] = ((global::ImGui.ImGuiPayload.__Internal*) __Instance)->DataType[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 33; i++)
                        ((global::ImGui.ImGuiPayload.__Internal*)__Instance)->DataType[i] = value[i];
                }
            }
        }

        public bool Preview
        {
            get
            {
                return ((global::ImGui.ImGuiPayload.__Internal*) __Instance)->Preview != 0;
            }

            set
            {
                ((global::ImGui.ImGuiPayload.__Internal*)__Instance)->Preview = (byte) (value ? 1 : 0);
            }
        }

        public bool Delivery
        {
            get
            {
                return ((global::ImGui.ImGuiPayload.__Internal*) __Instance)->Delivery != 0;
            }

            set
            {
                ((global::ImGui.ImGuiPayload.__Internal*)__Instance)->Delivery = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiOnceUponAFrame : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int RefFrame;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiOnceUponAFrame@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiOnceUponAFrame> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiOnceUponAFrame>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiOnceUponAFrame __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiOnceUponAFrame(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiOnceUponAFrame __CreateInstance(global::ImGui.ImGuiOnceUponAFrame.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiOnceUponAFrame(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiOnceUponAFrame.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiOnceUponAFrame.__Internal));
            *(global::ImGui.ImGuiOnceUponAFrame.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiOnceUponAFrame(global::ImGui.ImGuiOnceUponAFrame.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiOnceUponAFrame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiOnceUponAFrame()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiOnceUponAFrame.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiOnceUponAFrame(global::ImGui.ImGuiOnceUponAFrame _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiOnceUponAFrame.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiOnceUponAFrame.__Internal*) __Instance) = *((global::ImGui.ImGuiOnceUponAFrame.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiOnceUponAFrame __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int RefFrame
        {
            get
            {
                return ((global::ImGui.ImGuiOnceUponAFrame.__Internal*) __Instance)->RefFrame;
            }

            set
            {
                ((global::ImGui.ImGuiOnceUponAFrame.__Internal*)__Instance)->RefFrame = value;
            }
        }
    }

    public unsafe partial class ImGuiTextFilter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 280)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed sbyte InputBuf[256];

            [FieldOffset(256)]
            internal global::ImGui.ImVectorImGuiTextRange.__Internal Filters;

            [FieldOffset(272)]
            internal int CountGrep;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiTextFilter@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiTextFilter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiTextFilter>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiTextFilter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiTextFilter(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiTextFilter __CreateInstance(global::ImGui.ImGuiTextFilter.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiTextFilter(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiTextFilter.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTextFilter.__Internal));
            *(global::ImGui.ImGuiTextFilter.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextFilter(global::ImGui.ImGuiTextFilter.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiTextFilter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiTextFilter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTextFilter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTextFilter(global::ImGui.ImGuiTextFilter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTextFilter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiTextFilter.__Internal*) __Instance) = *((global::ImGui.ImGuiTextFilter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiTextFilter __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] InputBuf
        {
            get
            {
                sbyte[] __value = null;
                if (((global::ImGui.ImGuiTextFilter.__Internal*) __Instance)->InputBuf != null)
                {
                    __value = new sbyte[256];
                    for (int i = 0; i < 256; i++)
                        __value[i] = ((global::ImGui.ImGuiTextFilter.__Internal*) __Instance)->InputBuf[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 256; i++)
                        ((global::ImGui.ImGuiTextFilter.__Internal*)__Instance)->InputBuf[i] = value[i];
                }
            }
        }

        public global::ImGui.ImVectorImGuiTextRange Filters
        {
            get
            {
                return global::ImGui.ImVectorImGuiTextRange.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiTextFilter.__Internal*) __Instance)->Filters));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiTextFilter.__Internal*)__Instance)->Filters = *(global::ImGui.ImVectorImGuiTextRange.__Internal*) value.__Instance;
            }
        }

        public int CountGrep
        {
            get
            {
                return ((global::ImGui.ImGuiTextFilter.__Internal*) __Instance)->CountGrep;
            }

            set
            {
                ((global::ImGui.ImGuiTextFilter.__Internal*)__Instance)->CountGrep = value;
            }
        }
    }

    public unsafe partial class ImGuiTextBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVector_char.__Internal Buf;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiTextBuffer@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextBuffer_appendf")]
            internal static extern void Appendf(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiTextBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiTextBuffer>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiTextBuffer __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiTextBuffer(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiTextBuffer __CreateInstance(global::ImGui.ImGuiTextBuffer.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiTextBuffer(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiTextBuffer.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTextBuffer.__Internal));
            *(global::ImGui.ImGuiTextBuffer.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextBuffer(global::ImGui.ImGuiTextBuffer.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiTextBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiTextBuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTextBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTextBuffer(global::ImGui.ImGuiTextBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTextBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiTextBuffer.__Internal*) __Instance) = *((global::ImGui.ImGuiTextBuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiTextBuffer __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Appendf(string fmt)
        {
            __Internal.Appendf(__Instance, fmt);
        }

        public global::ImGui.ImVector_char Buf
        {
            get
            {
                return global::ImGui.ImVector_char.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiTextBuffer.__Internal*) __Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiTextBuffer.__Internal*)__Instance)->Buf = *(global::ImGui.ImVector_char.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStorage : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVectorImGuiStoragePair.__Internal Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiStorage@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiStorage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiStorage>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiStorage __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiStorage(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiStorage __CreateInstance(global::ImGui.ImGuiStorage.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiStorage(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiStorage.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStorage.__Internal));
            *(global::ImGui.ImGuiStorage.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStorage(global::ImGui.ImGuiStorage.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiStorage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiStorage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStorage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiStorage(global::ImGui.ImGuiStorage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStorage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiStorage.__Internal*) __Instance) = *((global::ImGui.ImGuiStorage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiStorage __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVectorImGuiStoragePair Data
        {
            get
            {
                return global::ImGui.ImVectorImGuiStoragePair.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiStorage.__Internal*) __Instance)->Data));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiStorage.__Internal*)__Instance)->Data = *(global::ImGui.ImVectorImGuiStoragePair.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTabBar : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Size;

            [FieldOffset(4)]
            internal int Capacity;

            [FieldOffset(8)]
            internal global::System.IntPtr Data;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVector_ImGuiTabBar@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiTabBar> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVectorImGuiTabBar>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVectorImGuiTabBar __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiTabBar(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVectorImGuiTabBar __CreateInstance(global::ImGui.ImVectorImGuiTabBar.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVectorImGuiTabBar(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVectorImGuiTabBar.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiTabBar.__Internal));
            *(global::ImGui.ImVectorImGuiTabBar.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTabBar(global::ImGui.ImVectorImGuiTabBar.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVectorImGuiTabBar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVectorImGuiTabBar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiTabBar(global::ImGui.ImVectorImGuiTabBar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVectorImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVectorImGuiTabBar.__Internal*) __Instance) = *((global::ImGui.ImVectorImGuiTabBar.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVectorImGuiTabBar __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiTabBar.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiTabBar.__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((global::ImGui.ImVectorImGuiTabBar.__Internal*) __Instance)->Capacity;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiTabBar.__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::ImGui.ImGuiTabBar Data
        {
            get
            {
                global::ImGui.ImGuiTabBar __result0;
                if (((global::ImGui.ImVectorImGuiTabBar.__Internal*) __Instance)->Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiTabBar.NativeToManagedMap.ContainsKey(((global::ImGui.ImVectorImGuiTabBar.__Internal*) __Instance)->Data))
                    __result0 = (global::ImGui.ImGuiTabBar) global::ImGui.ImGuiTabBar.NativeToManagedMap[((global::ImGui.ImVectorImGuiTabBar.__Internal*) __Instance)->Data];
                else __result0 = global::ImGui.ImGuiTabBar.__CreateInstance(((global::ImGui.ImVectorImGuiTabBar.__Internal*) __Instance)->Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImVectorImGuiTabBar.__Internal*)__Instance)->Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImPoolImGuiTabBar : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVectorImGuiTabBar.__Internal Buf;

            [FieldOffset(16)]
            internal global::ImGui.ImGuiStorage.__Internal Map;

            [FieldOffset(32)]
            internal int FreeIdx;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImPool_ImGuiTabBar@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImPoolImGuiTabBar> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImPoolImGuiTabBar>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImPoolImGuiTabBar __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImPoolImGuiTabBar(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImPoolImGuiTabBar __CreateInstance(global::ImGui.ImPoolImGuiTabBar.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImPoolImGuiTabBar(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImPoolImGuiTabBar.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImPoolImGuiTabBar.__Internal));
            *(global::ImGui.ImPoolImGuiTabBar.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImPoolImGuiTabBar(global::ImGui.ImPoolImGuiTabBar.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImPoolImGuiTabBar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImPoolImGuiTabBar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImPoolImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImPoolImGuiTabBar(global::ImGui.ImPoolImGuiTabBar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImPoolImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImPoolImGuiTabBar.__Internal*) __Instance) = *((global::ImGui.ImPoolImGuiTabBar.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImPoolImGuiTabBar __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVectorImGuiTabBar Buf
        {
            get
            {
                return global::ImGui.ImVectorImGuiTabBar.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImPoolImGuiTabBar.__Internal*) __Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImPoolImGuiTabBar.__Internal*)__Instance)->Buf = *(global::ImGui.ImVectorImGuiTabBar.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiStorage Map
        {
            get
            {
                return global::ImGui.ImGuiStorage.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImPoolImGuiTabBar.__Internal*) __Instance)->Map));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImPoolImGuiTabBar.__Internal*)__Instance)->Map = *(global::ImGui.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public int FreeIdx
        {
            get
            {
                return ((global::ImGui.ImPoolImGuiTabBar.__Internal*) __Instance)->FreeIdx;
            }

            set
            {
                ((global::ImGui.ImPoolImGuiTabBar.__Internal*)__Instance)->FreeIdx = value;
            }
        }
    }

    public unsafe partial class ImGuiListClipper : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int DisplayStart;

            [FieldOffset(4)]
            internal int DisplayEnd;

            [FieldOffset(8)]
            internal int ItemsCount;

            [FieldOffset(12)]
            internal int StepNo;

            [FieldOffset(16)]
            internal float ItemsHeight;

            [FieldOffset(20)]
            internal float StartPosY;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiListClipper@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiListClipper> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiListClipper>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiListClipper __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiListClipper(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiListClipper __CreateInstance(global::ImGui.ImGuiListClipper.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiListClipper(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiListClipper.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiListClipper.__Internal));
            *(global::ImGui.ImGuiListClipper.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiListClipper(global::ImGui.ImGuiListClipper.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiListClipper(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiListClipper()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiListClipper.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiListClipper(global::ImGui.ImGuiListClipper _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiListClipper.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiListClipper.__Internal*) __Instance) = *((global::ImGui.ImGuiListClipper.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiListClipper __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int DisplayStart
        {
            get
            {
                return ((global::ImGui.ImGuiListClipper.__Internal*) __Instance)->DisplayStart;
            }

            set
            {
                ((global::ImGui.ImGuiListClipper.__Internal*)__Instance)->DisplayStart = value;
            }
        }

        public int DisplayEnd
        {
            get
            {
                return ((global::ImGui.ImGuiListClipper.__Internal*) __Instance)->DisplayEnd;
            }

            set
            {
                ((global::ImGui.ImGuiListClipper.__Internal*)__Instance)->DisplayEnd = value;
            }
        }

        public int ItemsCount
        {
            get
            {
                return ((global::ImGui.ImGuiListClipper.__Internal*) __Instance)->ItemsCount;
            }

            set
            {
                ((global::ImGui.ImGuiListClipper.__Internal*)__Instance)->ItemsCount = value;
            }
        }

        public int StepNo
        {
            get
            {
                return ((global::ImGui.ImGuiListClipper.__Internal*) __Instance)->StepNo;
            }

            set
            {
                ((global::ImGui.ImGuiListClipper.__Internal*)__Instance)->StepNo = value;
            }
        }

        public float ItemsHeight
        {
            get
            {
                return ((global::ImGui.ImGuiListClipper.__Internal*) __Instance)->ItemsHeight;
            }

            set
            {
                ((global::ImGui.ImGuiListClipper.__Internal*)__Instance)->ItemsHeight = value;
            }
        }

        public float StartPosY
        {
            get
            {
                return ((global::ImGui.ImGuiListClipper.__Internal*) __Instance)->StartPosY;
            }

            set
            {
                ((global::ImGui.ImGuiListClipper.__Internal*)__Instance)->StartPosY = value;
            }
        }
    }

    public unsafe partial class ImColor : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVec4.__Internal Value;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImColor@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImColor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImColor>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImColor __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImColor(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImColor __CreateInstance(global::ImGui.ImColor.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImColor(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImColor.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImColor.__Internal));
            *(global::ImGui.ImColor.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImColor(global::ImGui.ImColor.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImColor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImColor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImColor(global::ImGui.ImColor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImColor.__Internal*) __Instance) = *((global::ImGui.ImColor.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImColor __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVec4 Value
        {
            get
            {
                return global::ImGui.ImVec4.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImColor.__Internal*) __Instance)->Value));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImColor.__Internal*)__Instance)->Value = *(global::ImGui.ImVec4.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawCmd : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint ElemCount;

            [FieldOffset(4)]
            internal global::ImGui.ImVec4.__Internal ClipRect;

            [FieldOffset(24)]
            internal global::System.IntPtr TextureId;

            [FieldOffset(32)]
            internal uint VtxOffset;

            [FieldOffset(36)]
            internal uint IdxOffset;

            [FieldOffset(40)]
            internal global::System.IntPtr UserCallback;

            [FieldOffset(48)]
            internal global::System.IntPtr UserCallbackData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImDrawCmd@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawCmd> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawCmd>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImDrawCmd __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawCmd(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImDrawCmd __CreateInstance(global::ImGui.ImDrawCmd.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawCmd(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImDrawCmd.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawCmd.__Internal));
            *(global::ImGui.ImDrawCmd.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawCmd(global::ImGui.ImDrawCmd.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawCmd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImDrawCmd()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawCmd(global::ImGui.ImDrawCmd _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImDrawCmd.__Internal*) __Instance) = *((global::ImGui.ImDrawCmd.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImDrawCmd __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ElemCount
        {
            get
            {
                return ((global::ImGui.ImDrawCmd.__Internal*) __Instance)->ElemCount;
            }

            set
            {
                ((global::ImGui.ImDrawCmd.__Internal*)__Instance)->ElemCount = value;
            }
        }

        public global::ImGui.ImVec4 ClipRect
        {
            get
            {
                return global::ImGui.ImVec4.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawCmd.__Internal*) __Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawCmd.__Internal*)__Instance)->ClipRect = *(global::ImGui.ImVec4.__Internal*) value.__Instance;
            }
        }

        public global::System.IntPtr TextureId
        {
            get
            {
                return ((global::ImGui.ImDrawCmd.__Internal*) __Instance)->TextureId;
            }

            set
            {
                ((global::ImGui.ImDrawCmd.__Internal*)__Instance)->TextureId = (global::System.IntPtr) value;
            }
        }

        public uint VtxOffset
        {
            get
            {
                return ((global::ImGui.ImDrawCmd.__Internal*) __Instance)->VtxOffset;
            }

            set
            {
                ((global::ImGui.ImDrawCmd.__Internal*)__Instance)->VtxOffset = value;
            }
        }

        public uint IdxOffset
        {
            get
            {
                return ((global::ImGui.ImDrawCmd.__Internal*) __Instance)->IdxOffset;
            }

            set
            {
                ((global::ImGui.ImDrawCmd.__Internal*)__Instance)->IdxOffset = value;
            }
        }

        public global::ImGui.ImDrawCallback UserCallback
        {
            get
            {
                var __ptr0 = ((global::ImGui.ImDrawCmd.__Internal*) __Instance)->UserCallback;
                return __ptr0 == IntPtr.Zero? null : (global::ImGui.ImDrawCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGui.ImDrawCallback));
            }

            set
            {
                ((global::ImGui.ImDrawCmd.__Internal*)__Instance)->UserCallback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr UserCallbackData
        {
            get
            {
                return ((global::ImGui.ImDrawCmd.__Internal*) __Instance)->UserCallbackData;
            }

            set
            {
                ((global::ImGui.ImDrawCmd.__Internal*)__Instance)->UserCallbackData = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImDrawVert : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVec2.__Internal pos;

            [FieldOffset(8)]
            internal global::ImGui.ImVec2.__Internal uv;

            [FieldOffset(16)]
            internal uint col;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImDrawVert@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawVert> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawVert>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImDrawVert __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawVert(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImDrawVert __CreateInstance(global::ImGui.ImDrawVert.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawVert(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImDrawVert.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawVert.__Internal));
            *(global::ImGui.ImDrawVert.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawVert(global::ImGui.ImDrawVert.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawVert(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImDrawVert()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawVert.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawVert(global::ImGui.ImDrawVert _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawVert.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImDrawVert.__Internal*) __Instance) = *((global::ImGui.ImDrawVert.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImDrawVert __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVec2 Pos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawVert.__Internal*) __Instance)->pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawVert.__Internal*)__Instance)->pos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 Uv
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawVert.__Internal*) __Instance)->uv));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawVert.__Internal*)__Instance)->uv = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public uint Col
        {
            get
            {
                return ((global::ImGui.ImDrawVert.__Internal*) __Instance)->col;
            }

            set
            {
                ((global::ImGui.ImDrawVert.__Internal*)__Instance)->col = value;
            }
        }
    }

    public unsafe partial class ImDrawChannel : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVectorImDrawCmd.__Internal _CmdBuffer;

            [FieldOffset(16)]
            internal global::ImGui.ImVectorImDrawIdx.__Internal _IdxBuffer;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImDrawChannel@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawChannel> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawChannel>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImDrawChannel __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawChannel(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImDrawChannel __CreateInstance(global::ImGui.ImDrawChannel.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawChannel(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImDrawChannel.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawChannel.__Internal));
            *(global::ImGui.ImDrawChannel.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawChannel(global::ImGui.ImDrawChannel.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawChannel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImDrawChannel()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawChannel(global::ImGui.ImDrawChannel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImDrawChannel.__Internal*) __Instance) = *((global::ImGui.ImDrawChannel.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImDrawChannel __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVectorImDrawCmd CmdBuffer
        {
            get
            {
                return global::ImGui.ImVectorImDrawCmd.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawChannel.__Internal*) __Instance)->_CmdBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawChannel.__Internal*)__Instance)->_CmdBuffer = *(global::ImGui.ImVectorImDrawCmd.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImDrawIdx IdxBuffer
        {
            get
            {
                return global::ImGui.ImVectorImDrawIdx.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawChannel.__Internal*) __Instance)->_IdxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawChannel.__Internal*)__Instance)->_IdxBuffer = *(global::ImGui.ImVectorImDrawIdx.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawListSplitter : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int _Current;

            [FieldOffset(4)]
            internal int _Count;

            [FieldOffset(8)]
            internal global::ImGui.ImVectorImDrawChannel.__Internal _Channels;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImDrawListSplitter@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawListSplitter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawListSplitter>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImDrawListSplitter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawListSplitter(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImDrawListSplitter __CreateInstance(global::ImGui.ImDrawListSplitter.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawListSplitter(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImDrawListSplitter.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawListSplitter.__Internal));
            *(global::ImGui.ImDrawListSplitter.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawListSplitter(global::ImGui.ImDrawListSplitter.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawListSplitter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImDrawListSplitter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawListSplitter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawListSplitter(global::ImGui.ImDrawListSplitter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawListSplitter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImDrawListSplitter.__Internal*) __Instance) = *((global::ImGui.ImDrawListSplitter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImDrawListSplitter __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Current
        {
            get
            {
                return ((global::ImGui.ImDrawListSplitter.__Internal*) __Instance)->_Current;
            }

            set
            {
                ((global::ImGui.ImDrawListSplitter.__Internal*)__Instance)->_Current = value;
            }
        }

        public int Count
        {
            get
            {
                return ((global::ImGui.ImDrawListSplitter.__Internal*) __Instance)->_Count;
            }

            set
            {
                ((global::ImGui.ImDrawListSplitter.__Internal*)__Instance)->_Count = value;
            }
        }

        public global::ImGui.ImVectorImDrawChannel Channels
        {
            get
            {
                return global::ImGui.ImVectorImDrawChannel.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawListSplitter.__Internal*) __Instance)->_Channels));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawListSplitter.__Internal*)__Instance)->_Channels = *(global::ImGui.ImVectorImDrawChannel.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawList : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 168)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVectorImDrawCmd.__Internal CmdBuffer;

            [FieldOffset(16)]
            internal global::ImGui.ImVectorImDrawIdx.__Internal IdxBuffer;

            [FieldOffset(32)]
            internal global::ImGui.ImVectorImDrawVert.__Internal VtxBuffer;

            [FieldOffset(48)]
            internal int Flags;

            [FieldOffset(56)]
            internal global::System.IntPtr _Data;

            [FieldOffset(64)]
            internal global::System.IntPtr _OwnerName;

            [FieldOffset(72)]
            internal uint _VtxCurrentOffset;

            [FieldOffset(76)]
            internal uint _VtxCurrentIdx;

            [FieldOffset(80)]
            internal global::System.IntPtr _VtxWritePtr;

            [FieldOffset(88)]
            internal global::System.IntPtr _IdxWritePtr;

            [FieldOffset(96)]
            internal global::ImGui.ImVectorImVec4.__Internal _ClipRectStack;

            [FieldOffset(112)]
            internal global::ImGui.ImVectorImTextureID.__Internal _TextureIdStack;

            [FieldOffset(128)]
            internal global::ImGui.ImVectorImVec2.__Internal _Path;

            [FieldOffset(144)]
            internal global::ImGui.ImDrawListSplitter.__Internal _Splitter;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImDrawList@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawList> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawList>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImDrawList __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawList(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImDrawList __CreateInstance(global::ImGui.ImDrawList.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawList(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImDrawList.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawList.__Internal));
            *(global::ImGui.ImDrawList.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawList(global::ImGui.ImDrawList.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawList(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImDrawList()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawList.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawList(global::ImGui.ImDrawList _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawList.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImDrawList.__Internal*) __Instance) = *((global::ImGui.ImDrawList.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImDrawList __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVectorImDrawCmd CmdBuffer
        {
            get
            {
                return global::ImGui.ImVectorImDrawCmd.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawList.__Internal*) __Instance)->CmdBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->CmdBuffer = *(global::ImGui.ImVectorImDrawCmd.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImDrawIdx IdxBuffer
        {
            get
            {
                return global::ImGui.ImVectorImDrawIdx.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawList.__Internal*) __Instance)->IdxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->IdxBuffer = *(global::ImGui.ImVectorImDrawIdx.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImDrawVert VtxBuffer
        {
            get
            {
                return global::ImGui.ImVectorImDrawVert.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawList.__Internal*) __Instance)->VtxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->VtxBuffer = *(global::ImGui.ImVectorImDrawVert.__Internal*) value.__Instance;
            }
        }

        public int Flags
        {
            get
            {
                return ((global::ImGui.ImDrawList.__Internal*) __Instance)->Flags;
            }

            set
            {
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->Flags = value;
            }
        }

        public global::ImGui.ImDrawListSharedData Data
        {
            get
            {
                global::ImGui.ImDrawListSharedData __result0;
                if (((global::ImGui.ImDrawList.__Internal*) __Instance)->_Data == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImDrawListSharedData.NativeToManagedMap.ContainsKey(((global::ImGui.ImDrawList.__Internal*) __Instance)->_Data))
                    __result0 = (global::ImGui.ImDrawListSharedData) global::ImGui.ImDrawListSharedData.NativeToManagedMap[((global::ImGui.ImDrawList.__Internal*) __Instance)->_Data];
                else __result0 = global::ImGui.ImDrawListSharedData.__CreateInstance(((global::ImGui.ImDrawList.__Internal*) __Instance)->_Data);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->_Data = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public string OwnerName
        {
            get
            {
                if (((global::ImGui.ImDrawList.__Internal*) __Instance)->_OwnerName == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::ImGui.ImDrawList.__Internal*) __Instance)->_OwnerName;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::ImGui.ImDrawList.__Internal*) __Instance)->_OwnerName, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::ImGui.ImDrawList.__Internal*)__Instance)->_OwnerName = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public uint VtxCurrentOffset
        {
            get
            {
                return ((global::ImGui.ImDrawList.__Internal*) __Instance)->_VtxCurrentOffset;
            }

            set
            {
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->_VtxCurrentOffset = value;
            }
        }

        public uint VtxCurrentIdx
        {
            get
            {
                return ((global::ImGui.ImDrawList.__Internal*) __Instance)->_VtxCurrentIdx;
            }

            set
            {
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->_VtxCurrentIdx = value;
            }
        }

        public global::ImGui.ImDrawVert VtxWritePtr
        {
            get
            {
                global::ImGui.ImDrawVert __result0;
                if (((global::ImGui.ImDrawList.__Internal*) __Instance)->_VtxWritePtr == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImDrawVert.NativeToManagedMap.ContainsKey(((global::ImGui.ImDrawList.__Internal*) __Instance)->_VtxWritePtr))
                    __result0 = (global::ImGui.ImDrawVert) global::ImGui.ImDrawVert.NativeToManagedMap[((global::ImGui.ImDrawList.__Internal*) __Instance)->_VtxWritePtr];
                else __result0 = global::ImGui.ImDrawVert.__CreateInstance(((global::ImGui.ImDrawList.__Internal*) __Instance)->_VtxWritePtr);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->_VtxWritePtr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public ushort* IdxWritePtr
        {
            get
            {
                return (ushort*) ((global::ImGui.ImDrawList.__Internal*) __Instance)->_IdxWritePtr;
            }

            set
            {
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->_IdxWritePtr = (global::System.IntPtr) value;
            }
        }

        public global::ImGui.ImVectorImVec4 ClipRectStack
        {
            get
            {
                return global::ImGui.ImVectorImVec4.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawList.__Internal*) __Instance)->_ClipRectStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->_ClipRectStack = *(global::ImGui.ImVectorImVec4.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImTextureID TextureIdStack
        {
            get
            {
                return global::ImGui.ImVectorImTextureID.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawList.__Internal*) __Instance)->_TextureIdStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->_TextureIdStack = *(global::ImGui.ImVectorImTextureID.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImVec2 Path
        {
            get
            {
                return global::ImGui.ImVectorImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawList.__Internal*) __Instance)->_Path));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->_Path = *(global::ImGui.ImVectorImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImDrawListSplitter Splitter
        {
            get
            {
                return global::ImGui.ImDrawListSplitter.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawList.__Internal*) __Instance)->_Splitter));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawList.__Internal*)__Instance)->_Splitter = *(global::ImGui.ImDrawListSplitter.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 56)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte Valid;

            [FieldOffset(8)]
            internal global::System.IntPtr CmdLists;

            [FieldOffset(16)]
            internal int CmdListsCount;

            [FieldOffset(20)]
            internal int TotalIdxCount;

            [FieldOffset(24)]
            internal int TotalVtxCount;

            [FieldOffset(28)]
            internal global::ImGui.ImVec2.__Internal DisplayPos;

            [FieldOffset(36)]
            internal global::ImGui.ImVec2.__Internal DisplaySize;

            [FieldOffset(44)]
            internal global::ImGui.ImVec2.__Internal FramebufferScale;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImDrawData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImDrawData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImDrawData __CreateInstance(global::ImGui.ImDrawData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImDrawData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawData.__Internal));
            *(global::ImGui.ImDrawData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawData(global::ImGui.ImDrawData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImDrawData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawData(global::ImGui.ImDrawData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImDrawData.__Internal*) __Instance) = *((global::ImGui.ImDrawData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImDrawData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Valid
        {
            get
            {
                return ((global::ImGui.ImDrawData.__Internal*) __Instance)->Valid != 0;
            }

            set
            {
                ((global::ImGui.ImDrawData.__Internal*)__Instance)->Valid = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGui.ImDrawList CmdLists
        {
            get
            {
                global::ImGui.ImDrawList __result0;
                if (((global::ImGui.ImDrawData.__Internal*) __Instance)->CmdLists == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImDrawList.NativeToManagedMap.ContainsKey(((global::ImGui.ImDrawData.__Internal*) __Instance)->CmdLists))
                    __result0 = (global::ImGui.ImDrawList) global::ImGui.ImDrawList.NativeToManagedMap[((global::ImGui.ImDrawData.__Internal*) __Instance)->CmdLists];
                else __result0 = global::ImGui.ImDrawList.__CreateInstance(((global::ImGui.ImDrawData.__Internal*) __Instance)->CmdLists);
                return __result0;
            }

            set
            {
                var __value = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                ((global::ImGui.ImDrawData.__Internal*)__Instance)->CmdLists = new global::System.IntPtr(&__value);
            }
        }

        public int CmdListsCount
        {
            get
            {
                return ((global::ImGui.ImDrawData.__Internal*) __Instance)->CmdListsCount;
            }

            set
            {
                ((global::ImGui.ImDrawData.__Internal*)__Instance)->CmdListsCount = value;
            }
        }

        public int TotalIdxCount
        {
            get
            {
                return ((global::ImGui.ImDrawData.__Internal*) __Instance)->TotalIdxCount;
            }

            set
            {
                ((global::ImGui.ImDrawData.__Internal*)__Instance)->TotalIdxCount = value;
            }
        }

        public int TotalVtxCount
        {
            get
            {
                return ((global::ImGui.ImDrawData.__Internal*) __Instance)->TotalVtxCount;
            }

            set
            {
                ((global::ImGui.ImDrawData.__Internal*)__Instance)->TotalVtxCount = value;
            }
        }

        public global::ImGui.ImVec2 DisplayPos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawData.__Internal*) __Instance)->DisplayPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawData.__Internal*)__Instance)->DisplayPos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 DisplaySize
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawData.__Internal*) __Instance)->DisplaySize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawData.__Internal*)__Instance)->DisplaySize = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 FramebufferScale
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawData.__Internal*) __Instance)->FramebufferScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawData.__Internal*)__Instance)->FramebufferScale = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontConfig : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 136)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr FontData;

            [FieldOffset(8)]
            internal int FontDataSize;

            [FieldOffset(12)]
            internal byte FontDataOwnedByAtlas;

            [FieldOffset(16)]
            internal int FontNo;

            [FieldOffset(20)]
            internal float SizePixels;

            [FieldOffset(24)]
            internal int OversampleH;

            [FieldOffset(28)]
            internal int OversampleV;

            [FieldOffset(32)]
            internal byte PixelSnapH;

            [FieldOffset(36)]
            internal global::ImGui.ImVec2.__Internal GlyphExtraSpacing;

            [FieldOffset(44)]
            internal global::ImGui.ImVec2.__Internal GlyphOffset;

            [FieldOffset(56)]
            internal global::System.IntPtr GlyphRanges;

            [FieldOffset(64)]
            internal float GlyphMinAdvanceX;

            [FieldOffset(68)]
            internal float GlyphMaxAdvanceX;

            [FieldOffset(72)]
            internal byte MergeMode;

            [FieldOffset(76)]
            internal uint RasterizerFlags;

            [FieldOffset(80)]
            internal float RasterizerMultiply;

            [FieldOffset(84)]
            internal ushort EllipsisChar;

            [FieldOffset(86)]
            internal fixed sbyte Name[40];

            [FieldOffset(128)]
            internal global::System.IntPtr DstFont;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImFontConfig@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFontConfig> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFontConfig>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImFontConfig __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImFontConfig(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImFontConfig __CreateInstance(global::ImGui.ImFontConfig.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImFontConfig(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImFontConfig.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontConfig.__Internal));
            *(global::ImGui.ImFontConfig.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontConfig(global::ImGui.ImFontConfig.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFontConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImFontConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontConfig(global::ImGui.ImFontConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImFontConfig.__Internal*) __Instance) = *((global::ImGui.ImFontConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImFontConfig __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::System.IntPtr FontData
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->FontData;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->FontData = (global::System.IntPtr) value;
            }
        }

        public int FontDataSize
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->FontDataSize;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->FontDataSize = value;
            }
        }

        public bool FontDataOwnedByAtlas
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->FontDataOwnedByAtlas != 0;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->FontDataOwnedByAtlas = (byte) (value ? 1 : 0);
            }
        }

        public int FontNo
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->FontNo;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->FontNo = value;
            }
        }

        public float SizePixels
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->SizePixels;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->SizePixels = value;
            }
        }

        public int OversampleH
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->OversampleH;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->OversampleH = value;
            }
        }

        public int OversampleV
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->OversampleV;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->OversampleV = value;
            }
        }

        public bool PixelSnapH
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->PixelSnapH != 0;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->PixelSnapH = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGui.ImVec2 GlyphExtraSpacing
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFontConfig.__Internal*) __Instance)->GlyphExtraSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->GlyphExtraSpacing = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 GlyphOffset
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFontConfig.__Internal*) __Instance)->GlyphOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->GlyphOffset = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public ushort* GlyphRanges
        {
            get
            {
                return (ushort*) ((global::ImGui.ImFontConfig.__Internal*) __Instance)->GlyphRanges;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->GlyphRanges = (global::System.IntPtr) value;
            }
        }

        public float GlyphMinAdvanceX
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->GlyphMinAdvanceX;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->GlyphMinAdvanceX = value;
            }
        }

        public float GlyphMaxAdvanceX
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->GlyphMaxAdvanceX;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->GlyphMaxAdvanceX = value;
            }
        }

        public bool MergeMode
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->MergeMode != 0;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->MergeMode = (byte) (value ? 1 : 0);
            }
        }

        public uint RasterizerFlags
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->RasterizerFlags;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->RasterizerFlags = value;
            }
        }

        public float RasterizerMultiply
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->RasterizerMultiply;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->RasterizerMultiply = value;
            }
        }

        public ushort EllipsisChar
        {
            get
            {
                return ((global::ImGui.ImFontConfig.__Internal*) __Instance)->EllipsisChar;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->EllipsisChar = value;
            }
        }

        public sbyte[] Name
        {
            get
            {
                sbyte[] __value = null;
                if (((global::ImGui.ImFontConfig.__Internal*) __Instance)->Name != null)
                {
                    __value = new sbyte[40];
                    for (int i = 0; i < 40; i++)
                        __value[i] = ((global::ImGui.ImFontConfig.__Internal*) __Instance)->Name[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 40; i++)
                        ((global::ImGui.ImFontConfig.__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public global::ImGui.ImFont DstFont
        {
            get
            {
                global::ImGui.ImFont __result0;
                if (((global::ImGui.ImFontConfig.__Internal*) __Instance)->DstFont == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(((global::ImGui.ImFontConfig.__Internal*) __Instance)->DstFont))
                    __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[((global::ImGui.ImFontConfig.__Internal*) __Instance)->DstFont];
                else __result0 = global::ImGui.ImFont.__CreateInstance(((global::ImGui.ImFontConfig.__Internal*) __Instance)->DstFont);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImFontConfig.__Internal*)__Instance)->DstFont = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontGlyph : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort Codepoint;

            [FieldOffset(4)]
            internal float AdvanceX;

            [FieldOffset(8)]
            internal float X0;

            [FieldOffset(12)]
            internal float Y0;

            [FieldOffset(16)]
            internal float X1;

            [FieldOffset(20)]
            internal float Y1;

            [FieldOffset(24)]
            internal float U0;

            [FieldOffset(28)]
            internal float V0;

            [FieldOffset(32)]
            internal float U1;

            [FieldOffset(36)]
            internal float V1;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImFontGlyph@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFontGlyph> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFontGlyph>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImFontGlyph __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImFontGlyph(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImFontGlyph __CreateInstance(global::ImGui.ImFontGlyph.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImFontGlyph(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImFontGlyph.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontGlyph.__Internal));
            *(global::ImGui.ImFontGlyph.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontGlyph(global::ImGui.ImFontGlyph.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFontGlyph(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImFontGlyph()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontGlyph(global::ImGui.ImFontGlyph _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImFontGlyph.__Internal*) __Instance) = *((global::ImGui.ImFontGlyph.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImFontGlyph __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Codepoint
        {
            get
            {
                return ((global::ImGui.ImFontGlyph.__Internal*) __Instance)->Codepoint;
            }

            set
            {
                ((global::ImGui.ImFontGlyph.__Internal*)__Instance)->Codepoint = value;
            }
        }

        public float AdvanceX
        {
            get
            {
                return ((global::ImGui.ImFontGlyph.__Internal*) __Instance)->AdvanceX;
            }

            set
            {
                ((global::ImGui.ImFontGlyph.__Internal*)__Instance)->AdvanceX = value;
            }
        }

        public float X0
        {
            get
            {
                return ((global::ImGui.ImFontGlyph.__Internal*) __Instance)->X0;
            }

            set
            {
                ((global::ImGui.ImFontGlyph.__Internal*)__Instance)->X0 = value;
            }
        }

        public float Y0
        {
            get
            {
                return ((global::ImGui.ImFontGlyph.__Internal*) __Instance)->Y0;
            }

            set
            {
                ((global::ImGui.ImFontGlyph.__Internal*)__Instance)->Y0 = value;
            }
        }

        public float X1
        {
            get
            {
                return ((global::ImGui.ImFontGlyph.__Internal*) __Instance)->X1;
            }

            set
            {
                ((global::ImGui.ImFontGlyph.__Internal*)__Instance)->X1 = value;
            }
        }

        public float Y1
        {
            get
            {
                return ((global::ImGui.ImFontGlyph.__Internal*) __Instance)->Y1;
            }

            set
            {
                ((global::ImGui.ImFontGlyph.__Internal*)__Instance)->Y1 = value;
            }
        }

        public float U0
        {
            get
            {
                return ((global::ImGui.ImFontGlyph.__Internal*) __Instance)->U0;
            }

            set
            {
                ((global::ImGui.ImFontGlyph.__Internal*)__Instance)->U0 = value;
            }
        }

        public float V0
        {
            get
            {
                return ((global::ImGui.ImFontGlyph.__Internal*) __Instance)->V0;
            }

            set
            {
                ((global::ImGui.ImFontGlyph.__Internal*)__Instance)->V0 = value;
            }
        }

        public float U1
        {
            get
            {
                return ((global::ImGui.ImFontGlyph.__Internal*) __Instance)->U1;
            }

            set
            {
                ((global::ImGui.ImFontGlyph.__Internal*)__Instance)->U1 = value;
            }
        }

        public float V1
        {
            get
            {
                return ((global::ImGui.ImFontGlyph.__Internal*) __Instance)->V1;
            }

            set
            {
                ((global::ImGui.ImFontGlyph.__Internal*)__Instance)->V1 = value;
            }
        }
    }

    public unsafe partial class ImFontGlyphRangesBuilder : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVectorImU32.__Internal UsedChars;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImFontGlyphRangesBuilder@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFontGlyphRangesBuilder> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFontGlyphRangesBuilder>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImFontGlyphRangesBuilder __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImFontGlyphRangesBuilder(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImFontGlyphRangesBuilder __CreateInstance(global::ImGui.ImFontGlyphRangesBuilder.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImFontGlyphRangesBuilder(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImFontGlyphRangesBuilder.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontGlyphRangesBuilder.__Internal));
            *(global::ImGui.ImFontGlyphRangesBuilder.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontGlyphRangesBuilder(global::ImGui.ImFontGlyphRangesBuilder.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFontGlyphRangesBuilder(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImFontGlyphRangesBuilder()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontGlyphRangesBuilder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontGlyphRangesBuilder(global::ImGui.ImFontGlyphRangesBuilder _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontGlyphRangesBuilder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImFontGlyphRangesBuilder.__Internal*) __Instance) = *((global::ImGui.ImFontGlyphRangesBuilder.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImFontGlyphRangesBuilder __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVectorImU32 UsedChars
        {
            get
            {
                return global::ImGui.ImVectorImU32.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFontGlyphRangesBuilder.__Internal*) __Instance)->UsedChars));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFontGlyphRangesBuilder.__Internal*)__Instance)->UsedChars = *(global::ImGui.ImVectorImU32.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontAtlasCustomRect : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint ID;

            [FieldOffset(4)]
            internal ushort Width;

            [FieldOffset(6)]
            internal ushort Height;

            [FieldOffset(8)]
            internal ushort X;

            [FieldOffset(10)]
            internal ushort Y;

            [FieldOffset(12)]
            internal float GlyphAdvanceX;

            [FieldOffset(16)]
            internal global::ImGui.ImVec2.__Internal GlyphOffset;

            [FieldOffset(24)]
            internal global::System.IntPtr Font;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImFontAtlasCustomRect@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFontAtlasCustomRect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFontAtlasCustomRect>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImFontAtlasCustomRect __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImFontAtlasCustomRect(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImFontAtlasCustomRect __CreateInstance(global::ImGui.ImFontAtlasCustomRect.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImFontAtlasCustomRect(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImFontAtlasCustomRect.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontAtlasCustomRect.__Internal));
            *(global::ImGui.ImFontAtlasCustomRect.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontAtlasCustomRect(global::ImGui.ImFontAtlasCustomRect.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFontAtlasCustomRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImFontAtlasCustomRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontAtlasCustomRect(global::ImGui.ImFontAtlasCustomRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance) = *((global::ImGui.ImFontAtlasCustomRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImFontAtlasCustomRect __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance)->ID;
            }

            set
            {
                ((global::ImGui.ImFontAtlasCustomRect.__Internal*)__Instance)->ID = value;
            }
        }

        public ushort Width
        {
            get
            {
                return ((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance)->Width;
            }

            set
            {
                ((global::ImGui.ImFontAtlasCustomRect.__Internal*)__Instance)->Width = value;
            }
        }

        public ushort Height
        {
            get
            {
                return ((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance)->Height;
            }

            set
            {
                ((global::ImGui.ImFontAtlasCustomRect.__Internal*)__Instance)->Height = value;
            }
        }

        public ushort X
        {
            get
            {
                return ((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance)->X;
            }

            set
            {
                ((global::ImGui.ImFontAtlasCustomRect.__Internal*)__Instance)->X = value;
            }
        }

        public ushort Y
        {
            get
            {
                return ((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance)->Y;
            }

            set
            {
                ((global::ImGui.ImFontAtlasCustomRect.__Internal*)__Instance)->Y = value;
            }
        }

        public float GlyphAdvanceX
        {
            get
            {
                return ((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance)->GlyphAdvanceX;
            }

            set
            {
                ((global::ImGui.ImFontAtlasCustomRect.__Internal*)__Instance)->GlyphAdvanceX = value;
            }
        }

        public global::ImGui.ImVec2 GlyphOffset
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance)->GlyphOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFontAtlasCustomRect.__Internal*)__Instance)->GlyphOffset = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImFont Font
        {
            get
            {
                global::ImGui.ImFont __result0;
                if (((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance)->Font == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance)->Font))
                    __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance)->Font];
                else __result0 = global::ImGui.ImFont.__CreateInstance(((global::ImGui.ImFontAtlasCustomRect.__Internal*) __Instance)->Font);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImFontAtlasCustomRect.__Internal*)__Instance)->Font = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontAtlas : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 120)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte Locked;

            [FieldOffset(4)]
            internal int Flags;

            [FieldOffset(8)]
            internal global::System.IntPtr TexID;

            [FieldOffset(16)]
            internal int TexDesiredWidth;

            [FieldOffset(20)]
            internal int TexGlyphPadding;

            [FieldOffset(24)]
            internal global::System.IntPtr TexPixelsAlpha8;

            [FieldOffset(32)]
            internal global::System.IntPtr TexPixelsRGBA32;

            [FieldOffset(40)]
            internal int TexWidth;

            [FieldOffset(44)]
            internal int TexHeight;

            [FieldOffset(48)]
            internal global::ImGui.ImVec2.__Internal TexUvScale;

            [FieldOffset(56)]
            internal global::ImGui.ImVec2.__Internal TexUvWhitePixel;

            [FieldOffset(64)]
            internal global::ImGui.ImVectorImFontPtr.__Internal Fonts;

            [FieldOffset(80)]
            internal global::ImGui.ImVectorImFontAtlasCustomRect.__Internal CustomRects;

            [FieldOffset(96)]
            internal global::ImGui.ImVectorImFontConfig.__Internal ConfigData;

            [FieldOffset(112)]
            internal fixed int CustomRectIds[1];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImFontAtlas@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFontAtlas> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFontAtlas>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImFontAtlas __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImFontAtlas(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImFontAtlas __CreateInstance(global::ImGui.ImFontAtlas.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImFontAtlas(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImFontAtlas.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontAtlas.__Internal));
            *(global::ImGui.ImFontAtlas.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontAtlas(global::ImGui.ImFontAtlas.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFontAtlas(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImFontAtlas()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontAtlas.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontAtlas(global::ImGui.ImFontAtlas _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFontAtlas.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImFontAtlas.__Internal*) __Instance) = *((global::ImGui.ImFontAtlas.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImFontAtlas __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Locked
        {
            get
            {
                return ((global::ImGui.ImFontAtlas.__Internal*) __Instance)->Locked != 0;
            }

            set
            {
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->Locked = (byte) (value ? 1 : 0);
            }
        }

        public int Flags
        {
            get
            {
                return ((global::ImGui.ImFontAtlas.__Internal*) __Instance)->Flags;
            }

            set
            {
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->Flags = value;
            }
        }

        public global::System.IntPtr TexID
        {
            get
            {
                return ((global::ImGui.ImFontAtlas.__Internal*) __Instance)->TexID;
            }

            set
            {
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->TexID = (global::System.IntPtr) value;
            }
        }

        public int TexDesiredWidth
        {
            get
            {
                return ((global::ImGui.ImFontAtlas.__Internal*) __Instance)->TexDesiredWidth;
            }

            set
            {
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->TexDesiredWidth = value;
            }
        }

        public int TexGlyphPadding
        {
            get
            {
                return ((global::ImGui.ImFontAtlas.__Internal*) __Instance)->TexGlyphPadding;
            }

            set
            {
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->TexGlyphPadding = value;
            }
        }

        public byte* TexPixelsAlpha8
        {
            get
            {
                return (byte*) ((global::ImGui.ImFontAtlas.__Internal*) __Instance)->TexPixelsAlpha8;
            }

            set
            {
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->TexPixelsAlpha8 = (global::System.IntPtr) value;
            }
        }

        public uint* TexPixelsRGBA32
        {
            get
            {
                return (uint*) ((global::ImGui.ImFontAtlas.__Internal*) __Instance)->TexPixelsRGBA32;
            }

            set
            {
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->TexPixelsRGBA32 = (global::System.IntPtr) value;
            }
        }

        public int TexWidth
        {
            get
            {
                return ((global::ImGui.ImFontAtlas.__Internal*) __Instance)->TexWidth;
            }

            set
            {
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->TexWidth = value;
            }
        }

        public int TexHeight
        {
            get
            {
                return ((global::ImGui.ImFontAtlas.__Internal*) __Instance)->TexHeight;
            }

            set
            {
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->TexHeight = value;
            }
        }

        public global::ImGui.ImVec2 TexUvScale
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFontAtlas.__Internal*) __Instance)->TexUvScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->TexUvScale = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 TexUvWhitePixel
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFontAtlas.__Internal*) __Instance)->TexUvWhitePixel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->TexUvWhitePixel = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImFontPtr Fonts
        {
            get
            {
                return global::ImGui.ImVectorImFontPtr.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFontAtlas.__Internal*) __Instance)->Fonts));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->Fonts = *(global::ImGui.ImVectorImFontPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImFontAtlasCustomRect CustomRects
        {
            get
            {
                return global::ImGui.ImVectorImFontAtlasCustomRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFontAtlas.__Internal*) __Instance)->CustomRects));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->CustomRects = *(global::ImGui.ImVectorImFontAtlasCustomRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImFontConfig ConfigData
        {
            get
            {
                return global::ImGui.ImVectorImFontConfig.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFontAtlas.__Internal*) __Instance)->ConfigData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->ConfigData = *(global::ImGui.ImVectorImFontConfig.__Internal*) value.__Instance;
            }
        }

        public int[] CustomRectIds
        {
            get
            {
                int[] __value = null;
                if (((global::ImGui.ImFontAtlas.__Internal*) __Instance)->CustomRectIds != null)
                {
                    __value = new int[1];
                    for (int i = 0; i < 1; i++)
                        __value[i] = ((global::ImGui.ImFontAtlas.__Internal*) __Instance)->CustomRectIds[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((global::ImGui.ImFontAtlas.__Internal*)__Instance)->CustomRectIds[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImFont : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 112)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVector_float.__Internal IndexAdvanceX;

            [FieldOffset(16)]
            internal float FallbackAdvanceX;

            [FieldOffset(20)]
            internal float FontSize;

            [FieldOffset(24)]
            internal global::ImGui.ImVectorImWchar.__Internal IndexLookup;

            [FieldOffset(40)]
            internal global::ImGui.ImVectorImFontGlyph.__Internal Glyphs;

            [FieldOffset(56)]
            internal global::System.IntPtr FallbackGlyph;

            [FieldOffset(64)]
            internal global::ImGui.ImVec2.__Internal DisplayOffset;

            [FieldOffset(72)]
            internal global::System.IntPtr ContainerAtlas;

            [FieldOffset(80)]
            internal global::System.IntPtr ConfigData;

            [FieldOffset(88)]
            internal short ConfigDataCount;

            [FieldOffset(90)]
            internal ushort FallbackChar;

            [FieldOffset(92)]
            internal ushort EllipsisChar;

            [FieldOffset(94)]
            internal byte DirtyLookupTables;

            [FieldOffset(96)]
            internal float Scale;

            [FieldOffset(100)]
            internal float Ascent;

            [FieldOffset(104)]
            internal float Descent;

            [FieldOffset(108)]
            internal int MetricsTotalSurface;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImFont@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFont> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImFont>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImFont __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImFont(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImFont __CreateInstance(global::ImGui.ImFont.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImFont(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImFont.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFont.__Internal));
            *(global::ImGui.ImFont.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFont(global::ImGui.ImFont.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFont(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImFont()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFont.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFont(global::ImGui.ImFont _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImFont.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImFont.__Internal*) __Instance) = *((global::ImGui.ImFont.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImFont __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVector_float IndexAdvanceX
        {
            get
            {
                return global::ImGui.ImVector_float.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFont.__Internal*) __Instance)->IndexAdvanceX));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFont.__Internal*)__Instance)->IndexAdvanceX = *(global::ImGui.ImVector_float.__Internal*) value.__Instance;
            }
        }

        public float FallbackAdvanceX
        {
            get
            {
                return ((global::ImGui.ImFont.__Internal*) __Instance)->FallbackAdvanceX;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->FallbackAdvanceX = value;
            }
        }

        public float FontSize
        {
            get
            {
                return ((global::ImGui.ImFont.__Internal*) __Instance)->FontSize;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->FontSize = value;
            }
        }

        public global::ImGui.ImVectorImWchar IndexLookup
        {
            get
            {
                return global::ImGui.ImVectorImWchar.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFont.__Internal*) __Instance)->IndexLookup));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFont.__Internal*)__Instance)->IndexLookup = *(global::ImGui.ImVectorImWchar.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImFontGlyph Glyphs
        {
            get
            {
                return global::ImGui.ImVectorImFontGlyph.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFont.__Internal*) __Instance)->Glyphs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFont.__Internal*)__Instance)->Glyphs = *(global::ImGui.ImVectorImFontGlyph.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImFontGlyph FallbackGlyph
        {
            get
            {
                global::ImGui.ImFontGlyph __result0;
                if (((global::ImGui.ImFont.__Internal*) __Instance)->FallbackGlyph == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFontGlyph.NativeToManagedMap.ContainsKey(((global::ImGui.ImFont.__Internal*) __Instance)->FallbackGlyph))
                    __result0 = (global::ImGui.ImFontGlyph) global::ImGui.ImFontGlyph.NativeToManagedMap[((global::ImGui.ImFont.__Internal*) __Instance)->FallbackGlyph];
                else __result0 = global::ImGui.ImFontGlyph.__CreateInstance(((global::ImGui.ImFont.__Internal*) __Instance)->FallbackGlyph);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->FallbackGlyph = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImVec2 DisplayOffset
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImFont.__Internal*) __Instance)->DisplayOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImFont.__Internal*)__Instance)->DisplayOffset = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImFontAtlas ContainerAtlas
        {
            get
            {
                global::ImGui.ImFontAtlas __result0;
                if (((global::ImGui.ImFont.__Internal*) __Instance)->ContainerAtlas == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFontAtlas.NativeToManagedMap.ContainsKey(((global::ImGui.ImFont.__Internal*) __Instance)->ContainerAtlas))
                    __result0 = (global::ImGui.ImFontAtlas) global::ImGui.ImFontAtlas.NativeToManagedMap[((global::ImGui.ImFont.__Internal*) __Instance)->ContainerAtlas];
                else __result0 = global::ImGui.ImFontAtlas.__CreateInstance(((global::ImGui.ImFont.__Internal*) __Instance)->ContainerAtlas);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->ContainerAtlas = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImFontConfig ConfigData
        {
            get
            {
                global::ImGui.ImFontConfig __result0;
                if (((global::ImGui.ImFont.__Internal*) __Instance)->ConfigData == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFontConfig.NativeToManagedMap.ContainsKey(((global::ImGui.ImFont.__Internal*) __Instance)->ConfigData))
                    __result0 = (global::ImGui.ImFontConfig) global::ImGui.ImFontConfig.NativeToManagedMap[((global::ImGui.ImFont.__Internal*) __Instance)->ConfigData];
                else __result0 = global::ImGui.ImFontConfig.__CreateInstance(((global::ImGui.ImFont.__Internal*) __Instance)->ConfigData);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->ConfigData = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public short ConfigDataCount
        {
            get
            {
                return ((global::ImGui.ImFont.__Internal*) __Instance)->ConfigDataCount;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->ConfigDataCount = value;
            }
        }

        public ushort FallbackChar
        {
            get
            {
                return ((global::ImGui.ImFont.__Internal*) __Instance)->FallbackChar;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->FallbackChar = value;
            }
        }

        public ushort EllipsisChar
        {
            get
            {
                return ((global::ImGui.ImFont.__Internal*) __Instance)->EllipsisChar;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->EllipsisChar = value;
            }
        }

        public bool DirtyLookupTables
        {
            get
            {
                return ((global::ImGui.ImFont.__Internal*) __Instance)->DirtyLookupTables != 0;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->DirtyLookupTables = (byte) (value ? 1 : 0);
            }
        }

        public float Scale
        {
            get
            {
                return ((global::ImGui.ImFont.__Internal*) __Instance)->Scale;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->Scale = value;
            }
        }

        public float Ascent
        {
            get
            {
                return ((global::ImGui.ImFont.__Internal*) __Instance)->Ascent;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->Ascent = value;
            }
        }

        public float Descent
        {
            get
            {
                return ((global::ImGui.ImFont.__Internal*) __Instance)->Descent;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->Descent = value;
            }
        }

        public int MetricsTotalSurface
        {
            get
            {
                return ((global::ImGui.ImFont.__Internal*) __Instance)->MetricsTotalSurface;
            }

            set
            {
                ((global::ImGui.ImFont.__Internal*)__Instance)->MetricsTotalSurface = value;
            }
        }
    }

    public unsafe partial class ImBoolVector : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVector_int.__Internal Storage;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImBoolVector@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImBoolVector> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImBoolVector>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImBoolVector __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImBoolVector(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImBoolVector __CreateInstance(global::ImGui.ImBoolVector.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImBoolVector(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImBoolVector.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImBoolVector.__Internal));
            *(global::ImGui.ImBoolVector.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImBoolVector(global::ImGui.ImBoolVector.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImBoolVector(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImBoolVector()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImBoolVector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImBoolVector(global::ImGui.ImBoolVector _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImBoolVector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImBoolVector.__Internal*) __Instance) = *((global::ImGui.ImBoolVector.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImBoolVector __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVector_int Storage
        {
            get
            {
                return global::ImGui.ImVector_int.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImBoolVector.__Internal*) __Instance)->Storage));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImBoolVector.__Internal*)__Instance)->Storage = *(global::ImGui.ImVector_int.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVec1 : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float x;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVec1@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVec1> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVec1>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVec1 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVec1(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVec1 __CreateInstance(global::ImGui.ImVec1.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVec1(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVec1.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec1.__Internal));
            *(global::ImGui.ImVec1.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec1(global::ImGui.ImVec1.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVec1(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVec1()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec1.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVec1(global::ImGui.ImVec1 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec1.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVec1.__Internal*) __Instance) = *((global::ImGui.ImVec1.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVec1 __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((global::ImGui.ImVec1.__Internal*) __Instance)->x;
            }

            set
            {
                ((global::ImGui.ImVec1.__Internal*)__Instance)->x = value;
            }
        }
    }

    public unsafe partial class ImVec2ih : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal short x;

            [FieldOffset(2)]
            internal short y;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImVec2ih@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVec2ih> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImVec2ih>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImVec2ih __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImVec2ih(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImVec2ih __CreateInstance(global::ImGui.ImVec2ih.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImVec2ih(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImVec2ih.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec2ih.__Internal));
            *(global::ImGui.ImVec2ih.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec2ih(global::ImGui.ImVec2ih.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVec2ih(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImVec2ih()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec2ih.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVec2ih(global::ImGui.ImVec2ih _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImVec2ih.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImVec2ih.__Internal*) __Instance) = *((global::ImGui.ImVec2ih.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImVec2ih __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public short X
        {
            get
            {
                return ((global::ImGui.ImVec2ih.__Internal*) __Instance)->x;
            }

            set
            {
                ((global::ImGui.ImVec2ih.__Internal*)__Instance)->x = value;
            }
        }

        public short Y
        {
            get
            {
                return ((global::ImGui.ImVec2ih.__Internal*) __Instance)->y;
            }

            set
            {
                ((global::ImGui.ImVec2ih.__Internal*)__Instance)->y = value;
            }
        }
    }

    public unsafe partial class ImRect : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVec2.__Internal Min;

            [FieldOffset(8)]
            internal global::ImGui.ImVec2.__Internal Max;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImRect@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImRect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImRect>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImRect __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImRect(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImRect __CreateInstance(global::ImGui.ImRect.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImRect(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImRect.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImRect.__Internal));
            *(global::ImGui.ImRect.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImRect(global::ImGui.ImRect.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImRect(global::ImGui.ImRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImRect.__Internal*) __Instance) = *((global::ImGui.ImRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImRect __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVec2 Min
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImRect.__Internal*) __Instance)->Min));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImRect.__Internal*)__Instance)->Min = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 Max
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImRect.__Internal*) __Instance)->Max));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImRect.__Internal*)__Instance)->Max = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiDataTypeInfo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ulong Size;

            [FieldOffset(8)]
            internal global::System.IntPtr PrintFmt;

            [FieldOffset(16)]
            internal global::System.IntPtr ScanFmt;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiDataTypeInfo@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiDataTypeInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiDataTypeInfo>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiDataTypeInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiDataTypeInfo(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiDataTypeInfo __CreateInstance(global::ImGui.ImGuiDataTypeInfo.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiDataTypeInfo(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiDataTypeInfo.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiDataTypeInfo.__Internal));
            *(global::ImGui.ImGuiDataTypeInfo.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiDataTypeInfo(global::ImGui.ImGuiDataTypeInfo.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiDataTypeInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiDataTypeInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiDataTypeInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiDataTypeInfo(global::ImGui.ImGuiDataTypeInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiDataTypeInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiDataTypeInfo.__Internal*) __Instance) = *((global::ImGui.ImGuiDataTypeInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiDataTypeInfo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Size
        {
            get
            {
                return ((global::ImGui.ImGuiDataTypeInfo.__Internal*) __Instance)->Size;
            }

            set
            {
                ((global::ImGui.ImGuiDataTypeInfo.__Internal*)__Instance)->Size = value;
            }
        }

        public string PrintFmt
        {
            get
            {
                if (((global::ImGui.ImGuiDataTypeInfo.__Internal*) __Instance)->PrintFmt == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::ImGui.ImGuiDataTypeInfo.__Internal*) __Instance)->PrintFmt;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::ImGui.ImGuiDataTypeInfo.__Internal*) __Instance)->PrintFmt, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::ImGui.ImGuiDataTypeInfo.__Internal*)__Instance)->PrintFmt = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string ScanFmt
        {
            get
            {
                if (((global::ImGui.ImGuiDataTypeInfo.__Internal*) __Instance)->ScanFmt == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::ImGui.ImGuiDataTypeInfo.__Internal*) __Instance)->ScanFmt;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::ImGui.ImGuiDataTypeInfo.__Internal*) __Instance)->ScanFmt, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::ImGui.ImGuiDataTypeInfo.__Internal*)__Instance)->ScanFmt = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class ImGuiColorMod : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Col;

            [FieldOffset(4)]
            internal global::ImGui.ImVec4.__Internal BackupValue;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiColorMod@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiColorMod> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiColorMod>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiColorMod __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiColorMod(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiColorMod __CreateInstance(global::ImGui.ImGuiColorMod.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiColorMod(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiColorMod.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiColorMod.__Internal));
            *(global::ImGui.ImGuiColorMod.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiColorMod(global::ImGui.ImGuiColorMod.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiColorMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiColorMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiColorMod(global::ImGui.ImGuiColorMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiColorMod.__Internal*) __Instance) = *((global::ImGui.ImGuiColorMod.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiColorMod __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Col
        {
            get
            {
                return ((global::ImGui.ImGuiColorMod.__Internal*) __Instance)->Col;
            }

            set
            {
                ((global::ImGui.ImGuiColorMod.__Internal*)__Instance)->Col = value;
            }
        }

        public global::ImGui.ImVec4 BackupValue
        {
            get
            {
                return global::ImGui.ImVec4.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiColorMod.__Internal*) __Instance)->BackupValue));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiColorMod.__Internal*)__Instance)->BackupValue = *(global::ImGui.ImVec4.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStyleMod : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int VarIdx;

            [FieldOffset(4)]
            internal fixed int BackupInt[2];

            [FieldOffset(4)]
            internal fixed float BackupFloat[2];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiStyleMod@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiStyleMod> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiStyleMod>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiStyleMod __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiStyleMod(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiStyleMod __CreateInstance(global::ImGui.ImGuiStyleMod.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiStyleMod(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiStyleMod.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStyleMod.__Internal));
            *(global::ImGui.ImGuiStyleMod.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStyleMod(global::ImGui.ImGuiStyleMod.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiStyleMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiStyleMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiStyleMod(global::ImGui.ImGuiStyleMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiStyleMod.__Internal*) __Instance) = *((global::ImGui.ImGuiStyleMod.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiStyleMod __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int VarIdx
        {
            get
            {
                return ((global::ImGui.ImGuiStyleMod.__Internal*) __Instance)->VarIdx;
            }

            set
            {
                ((global::ImGui.ImGuiStyleMod.__Internal*)__Instance)->VarIdx = value;
            }
        }

        public int[] BackupInt
        {
            get
            {
                int[] __value = null;
                if (((global::ImGui.ImGuiStyleMod.__Internal*) __Instance)->BackupInt != null)
                {
                    __value = new int[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = ((global::ImGui.ImGuiStyleMod.__Internal*) __Instance)->BackupInt[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((global::ImGui.ImGuiStyleMod.__Internal*)__Instance)->BackupInt[i] = value[i];
                }
            }
        }

        public float[] BackupFloat
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiStyleMod.__Internal*) __Instance)->BackupFloat != null)
                {
                    __value = new float[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = ((global::ImGui.ImGuiStyleMod.__Internal*) __Instance)->BackupFloat[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((global::ImGui.ImGuiStyleMod.__Internal*)__Instance)->BackupFloat[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiGroupData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 44)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVec2.__Internal BackupCursorPos;

            [FieldOffset(8)]
            internal global::ImGui.ImVec2.__Internal BackupCursorMaxPos;

            [FieldOffset(16)]
            internal global::ImGui.ImVec1.__Internal BackupIndent;

            [FieldOffset(20)]
            internal global::ImGui.ImVec1.__Internal BackupGroupOffset;

            [FieldOffset(24)]
            internal global::ImGui.ImVec2.__Internal BackupCurrLineSize;

            [FieldOffset(32)]
            internal float BackupCurrLineTextBaseOffset;

            [FieldOffset(36)]
            internal uint BackupActiveIdIsAlive;

            [FieldOffset(40)]
            internal byte BackupActiveIdPreviousFrameIsAlive;

            [FieldOffset(41)]
            internal byte EmitItem;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiGroupData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiGroupData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiGroupData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiGroupData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiGroupData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiGroupData __CreateInstance(global::ImGui.ImGuiGroupData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiGroupData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiGroupData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiGroupData.__Internal));
            *(global::ImGui.ImGuiGroupData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiGroupData(global::ImGui.ImGuiGroupData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiGroupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiGroupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiGroupData(global::ImGui.ImGuiGroupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiGroupData.__Internal*) __Instance) = *((global::ImGui.ImGuiGroupData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiGroupData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVec2 BackupCursorPos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiGroupData.__Internal*) __Instance)->BackupCursorPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiGroupData.__Internal*)__Instance)->BackupCursorPos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 BackupCursorMaxPos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiGroupData.__Internal*) __Instance)->BackupCursorMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiGroupData.__Internal*)__Instance)->BackupCursorMaxPos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec1 BackupIndent
        {
            get
            {
                return global::ImGui.ImVec1.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiGroupData.__Internal*) __Instance)->BackupIndent));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiGroupData.__Internal*)__Instance)->BackupIndent = *(global::ImGui.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec1 BackupGroupOffset
        {
            get
            {
                return global::ImGui.ImVec1.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiGroupData.__Internal*) __Instance)->BackupGroupOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiGroupData.__Internal*)__Instance)->BackupGroupOffset = *(global::ImGui.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 BackupCurrLineSize
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiGroupData.__Internal*) __Instance)->BackupCurrLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiGroupData.__Internal*)__Instance)->BackupCurrLineSize = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float BackupCurrLineTextBaseOffset
        {
            get
            {
                return ((global::ImGui.ImGuiGroupData.__Internal*) __Instance)->BackupCurrLineTextBaseOffset;
            }

            set
            {
                ((global::ImGui.ImGuiGroupData.__Internal*)__Instance)->BackupCurrLineTextBaseOffset = value;
            }
        }

        public uint BackupActiveIdIsAlive
        {
            get
            {
                return ((global::ImGui.ImGuiGroupData.__Internal*) __Instance)->BackupActiveIdIsAlive;
            }

            set
            {
                ((global::ImGui.ImGuiGroupData.__Internal*)__Instance)->BackupActiveIdIsAlive = value;
            }
        }

        public bool BackupActiveIdPreviousFrameIsAlive
        {
            get
            {
                return ((global::ImGui.ImGuiGroupData.__Internal*) __Instance)->BackupActiveIdPreviousFrameIsAlive != 0;
            }

            set
            {
                ((global::ImGui.ImGuiGroupData.__Internal*)__Instance)->BackupActiveIdPreviousFrameIsAlive = (byte) (value ? 1 : 0);
            }
        }

        public bool EmitItem
        {
            get
            {
                return ((global::ImGui.ImGuiGroupData.__Internal*) __Instance)->EmitItem != 0;
            }

            set
            {
                ((global::ImGui.ImGuiGroupData.__Internal*)__Instance)->EmitItem = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiMenuColumns : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float Spacing;

            [FieldOffset(4)]
            internal float Width;

            [FieldOffset(8)]
            internal float NextWidth;

            [FieldOffset(12)]
            internal fixed float Pos[3];

            [FieldOffset(24)]
            internal fixed float NextWidths[3];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiMenuColumns@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiMenuColumns> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiMenuColumns>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiMenuColumns __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiMenuColumns(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiMenuColumns __CreateInstance(global::ImGui.ImGuiMenuColumns.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiMenuColumns(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiMenuColumns.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiMenuColumns.__Internal));
            *(global::ImGui.ImGuiMenuColumns.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiMenuColumns(global::ImGui.ImGuiMenuColumns.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiMenuColumns(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiMenuColumns()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiMenuColumns.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiMenuColumns(global::ImGui.ImGuiMenuColumns _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiMenuColumns.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiMenuColumns.__Internal*) __Instance) = *((global::ImGui.ImGuiMenuColumns.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiMenuColumns __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Spacing
        {
            get
            {
                return ((global::ImGui.ImGuiMenuColumns.__Internal*) __Instance)->Spacing;
            }

            set
            {
                ((global::ImGui.ImGuiMenuColumns.__Internal*)__Instance)->Spacing = value;
            }
        }

        public float Width
        {
            get
            {
                return ((global::ImGui.ImGuiMenuColumns.__Internal*) __Instance)->Width;
            }

            set
            {
                ((global::ImGui.ImGuiMenuColumns.__Internal*)__Instance)->Width = value;
            }
        }

        public float NextWidth
        {
            get
            {
                return ((global::ImGui.ImGuiMenuColumns.__Internal*) __Instance)->NextWidth;
            }

            set
            {
                ((global::ImGui.ImGuiMenuColumns.__Internal*)__Instance)->NextWidth = value;
            }
        }

        public float[] Pos
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiMenuColumns.__Internal*) __Instance)->Pos != null)
                {
                    __value = new float[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::ImGui.ImGuiMenuColumns.__Internal*) __Instance)->Pos[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::ImGui.ImGuiMenuColumns.__Internal*)__Instance)->Pos[i] = value[i];
                }
            }
        }

        public float[] NextWidths
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiMenuColumns.__Internal*) __Instance)->NextWidths != null)
                {
                    __value = new float[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::ImGui.ImGuiMenuColumns.__Internal*) __Instance)->NextWidths[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::ImGui.ImGuiMenuColumns.__Internal*)__Instance)->NextWidths[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiInputTextState : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 3728)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint ID;

            [FieldOffset(4)]
            internal int CurLenW;

            [FieldOffset(8)]
            internal int CurLenA;

            [FieldOffset(16)]
            internal global::ImGui.ImVectorImWchar.__Internal TextW;

            [FieldOffset(32)]
            internal global::ImGui.ImVector_char.__Internal TextA;

            [FieldOffset(48)]
            internal global::ImGui.ImVector_char.__Internal InitialTextA;

            [FieldOffset(64)]
            internal byte TextAIsValid;

            [FieldOffset(68)]
            internal int BufCapacityA;

            [FieldOffset(72)]
            internal float ScrollX;

            [FieldOffset(76)]
            internal global::ImGui.STB_TexteditState.__Internal Stb;

            [FieldOffset(3696)]
            internal float CursorAnim;

            [FieldOffset(3700)]
            internal byte CursorFollow;

            [FieldOffset(3701)]
            internal byte SelectedAllMouseLock;

            [FieldOffset(3704)]
            internal int UserFlags;

            [FieldOffset(3712)]
            internal global::System.IntPtr UserCallback;

            [FieldOffset(3720)]
            internal global::System.IntPtr UserCallbackData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiInputTextState@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiInputTextState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiInputTextState>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiInputTextState __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiInputTextState(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiInputTextState __CreateInstance(global::ImGui.ImGuiInputTextState.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiInputTextState(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiInputTextState.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiInputTextState.__Internal));
            *(global::ImGui.ImGuiInputTextState.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputTextState(global::ImGui.ImGuiInputTextState.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiInputTextState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiInputTextState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiInputTextState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiInputTextState(global::ImGui.ImGuiInputTextState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiInputTextState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiInputTextState.__Internal*) __Instance) = *((global::ImGui.ImGuiInputTextState.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiInputTextState __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->ID;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->ID = value;
            }
        }

        public int CurLenW
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->CurLenW;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->CurLenW = value;
            }
        }

        public int CurLenA
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->CurLenA;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->CurLenA = value;
            }
        }

        public global::ImGui.ImVectorImWchar TextW
        {
            get
            {
                return global::ImGui.ImVectorImWchar.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->TextW));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->TextW = *(global::ImGui.ImVectorImWchar.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVector_char TextA
        {
            get
            {
                return global::ImGui.ImVector_char.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->TextA));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->TextA = *(global::ImGui.ImVector_char.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVector_char InitialTextA
        {
            get
            {
                return global::ImGui.ImVector_char.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->InitialTextA));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->InitialTextA = *(global::ImGui.ImVector_char.__Internal*) value.__Instance;
            }
        }

        public bool TextAIsValid
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->TextAIsValid != 0;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->TextAIsValid = (byte) (value ? 1 : 0);
            }
        }

        public int BufCapacityA
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->BufCapacityA;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->BufCapacityA = value;
            }
        }

        public float ScrollX
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->ScrollX;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->ScrollX = value;
            }
        }

        public global::ImGui.STB_TexteditState Stb
        {
            get
            {
                return global::ImGui.STB_TexteditState.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->Stb));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->Stb = *(global::ImGui.STB_TexteditState.__Internal*) value.__Instance;
            }
        }

        public float CursorAnim
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->CursorAnim;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->CursorAnim = value;
            }
        }

        public bool CursorFollow
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->CursorFollow != 0;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->CursorFollow = (byte) (value ? 1 : 0);
            }
        }

        public bool SelectedAllMouseLock
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->SelectedAllMouseLock != 0;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->SelectedAllMouseLock = (byte) (value ? 1 : 0);
            }
        }

        public int UserFlags
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->UserFlags;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->UserFlags = value;
            }
        }

        public global::ImGui.ImGuiInputTextCallback UserCallback
        {
            get
            {
                var __ptr0 = ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->UserCallback;
                return __ptr0 == IntPtr.Zero? null : (global::ImGui.ImGuiInputTextCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGui.ImGuiInputTextCallback));
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->UserCallback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr UserCallbackData
        {
            get
            {
                return ((global::ImGui.ImGuiInputTextState.__Internal*) __Instance)->UserCallbackData;
            }

            set
            {
                ((global::ImGui.ImGuiInputTextState.__Internal*)__Instance)->UserCallbackData = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImGuiWindowSettings : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint ID;

            [FieldOffset(4)]
            internal global::ImGui.ImVec2ih.__Internal Pos;

            [FieldOffset(8)]
            internal global::ImGui.ImVec2ih.__Internal Size;

            [FieldOffset(12)]
            internal byte Collapsed;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiWindowSettings@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiWindowSettings> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiWindowSettings>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiWindowSettings __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiWindowSettings(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiWindowSettings __CreateInstance(global::ImGui.ImGuiWindowSettings.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiWindowSettings(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiWindowSettings.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiWindowSettings.__Internal));
            *(global::ImGui.ImGuiWindowSettings.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindowSettings(global::ImGui.ImGuiWindowSettings.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiWindowSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiWindowSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiWindowSettings(global::ImGui.ImGuiWindowSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiWindowSettings.__Internal*) __Instance) = *((global::ImGui.ImGuiWindowSettings.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiWindowSettings __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((global::ImGui.ImGuiWindowSettings.__Internal*) __Instance)->ID;
            }

            set
            {
                ((global::ImGui.ImGuiWindowSettings.__Internal*)__Instance)->ID = value;
            }
        }

        public global::ImGui.ImVec2ih Pos
        {
            get
            {
                return global::ImGui.ImVec2ih.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowSettings.__Internal*) __Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowSettings.__Internal*)__Instance)->Pos = *(global::ImGui.ImVec2ih.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2ih Size
        {
            get
            {
                return global::ImGui.ImVec2ih.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowSettings.__Internal*) __Instance)->Size));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowSettings.__Internal*)__Instance)->Size = *(global::ImGui.ImVec2ih.__Internal*) value.__Instance;
            }
        }

        public bool Collapsed
        {
            get
            {
                return ((global::ImGui.ImGuiWindowSettings.__Internal*) __Instance)->Collapsed != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindowSettings.__Internal*)__Instance)->Collapsed = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiSettingsHandler : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr TypeName;

            [FieldOffset(8)]
            internal uint TypeHash;

            [FieldOffset(16)]
            internal global::System.IntPtr ReadOpenFn;

            [FieldOffset(24)]
            internal global::System.IntPtr ReadLineFn;

            [FieldOffset(32)]
            internal global::System.IntPtr WriteAllFn;

            [FieldOffset(40)]
            internal global::System.IntPtr UserData;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiSettingsHandler@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiSettingsHandler> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiSettingsHandler>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiSettingsHandler __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiSettingsHandler(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiSettingsHandler __CreateInstance(global::ImGui.ImGuiSettingsHandler.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiSettingsHandler(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiSettingsHandler.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiSettingsHandler.__Internal));
            *(global::ImGui.ImGuiSettingsHandler.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiSettingsHandler(global::ImGui.ImGuiSettingsHandler.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiSettingsHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiSettingsHandler()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiSettingsHandler(global::ImGui.ImGuiSettingsHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiSettingsHandler.__Internal*) __Instance) = *((global::ImGui.ImGuiSettingsHandler.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiSettingsHandler __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string TypeName
        {
            get
            {
                if (((global::ImGui.ImGuiSettingsHandler.__Internal*) __Instance)->TypeName == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::ImGui.ImGuiSettingsHandler.__Internal*) __Instance)->TypeName;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::ImGui.ImGuiSettingsHandler.__Internal*) __Instance)->TypeName, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::ImGui.ImGuiSettingsHandler.__Internal*)__Instance)->TypeName = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public uint TypeHash
        {
            get
            {
                return ((global::ImGui.ImGuiSettingsHandler.__Internal*) __Instance)->TypeHash;
            }

            set
            {
                ((global::ImGui.ImGuiSettingsHandler.__Internal*)__Instance)->TypeHash = value;
            }
        }

        public global::ImGui.Delegates.Func_IntPtr_IntPtr_IntPtr_string ReadOpenFn
        {
            get
            {
                var __ptr0 = ((global::ImGui.ImGuiSettingsHandler.__Internal*) __Instance)->ReadOpenFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGui.Delegates.Func_IntPtr_IntPtr_IntPtr_string) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGui.Delegates.Func_IntPtr_IntPtr_IntPtr_string));
            }

            set
            {
                ((global::ImGui.ImGuiSettingsHandler.__Internal*)__Instance)->ReadOpenFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::ImGui.Delegates.Action_IntPtr_IntPtr_IntPtr_string ReadLineFn
        {
            get
            {
                var __ptr0 = ((global::ImGui.ImGuiSettingsHandler.__Internal*) __Instance)->ReadLineFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGui.Delegates.Action_IntPtr_IntPtr_IntPtr_string) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGui.Delegates.Action_IntPtr_IntPtr_IntPtr_string));
            }

            set
            {
                ((global::ImGui.ImGuiSettingsHandler.__Internal*)__Instance)->ReadLineFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::ImGui.Delegates.Action_IntPtr_IntPtr_IntPtr WriteAllFn
        {
            get
            {
                var __ptr0 = ((global::ImGui.ImGuiSettingsHandler.__Internal*) __Instance)->WriteAllFn;
                return __ptr0 == IntPtr.Zero? null : (global::ImGui.Delegates.Action_IntPtr_IntPtr_IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGui.Delegates.Action_IntPtr_IntPtr_IntPtr));
            }

            set
            {
                ((global::ImGui.ImGuiSettingsHandler.__Internal*)__Instance)->WriteAllFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr UserData
        {
            get
            {
                return ((global::ImGui.ImGuiSettingsHandler.__Internal*) __Instance)->UserData;
            }

            set
            {
                ((global::ImGui.ImGuiSettingsHandler.__Internal*)__Instance)->UserData = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class ImGuiPopupData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint PopupId;

            [FieldOffset(8)]
            internal global::System.IntPtr Window;

            [FieldOffset(16)]
            internal global::System.IntPtr SourceWindow;

            [FieldOffset(24)]
            internal int OpenFrameCount;

            [FieldOffset(28)]
            internal uint OpenParentId;

            [FieldOffset(32)]
            internal global::ImGui.ImVec2.__Internal OpenPopupPos;

            [FieldOffset(40)]
            internal global::ImGui.ImVec2.__Internal OpenMousePos;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiPopupData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiPopupData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiPopupData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiPopupData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiPopupData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiPopupData __CreateInstance(global::ImGui.ImGuiPopupData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiPopupData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiPopupData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiPopupData.__Internal));
            *(global::ImGui.ImGuiPopupData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPopupData(global::ImGui.ImGuiPopupData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiPopupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiPopupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiPopupData(global::ImGui.ImGuiPopupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiPopupData.__Internal*) __Instance) = *((global::ImGui.ImGuiPopupData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiPopupData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint PopupId
        {
            get
            {
                return ((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->PopupId;
            }

            set
            {
                ((global::ImGui.ImGuiPopupData.__Internal*)__Instance)->PopupId = value;
            }
        }

        public global::ImGui.ImGuiWindow Window
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->Window == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->Window))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->Window];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->Window);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiPopupData.__Internal*)__Instance)->Window = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow SourceWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->SourceWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->SourceWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->SourceWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->SourceWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiPopupData.__Internal*)__Instance)->SourceWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int OpenFrameCount
        {
            get
            {
                return ((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->OpenFrameCount;
            }

            set
            {
                ((global::ImGui.ImGuiPopupData.__Internal*)__Instance)->OpenFrameCount = value;
            }
        }

        public uint OpenParentId
        {
            get
            {
                return ((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->OpenParentId;
            }

            set
            {
                ((global::ImGui.ImGuiPopupData.__Internal*)__Instance)->OpenParentId = value;
            }
        }

        public global::ImGui.ImVec2 OpenPopupPos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->OpenPopupPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiPopupData.__Internal*)__Instance)->OpenPopupPos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 OpenMousePos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiPopupData.__Internal*) __Instance)->OpenMousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiPopupData.__Internal*)__Instance)->OpenMousePos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiColumnData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal float OffsetNorm;

            [FieldOffset(4)]
            internal float OffsetNormBeforeResize;

            [FieldOffset(8)]
            internal int Flags;

            [FieldOffset(12)]
            internal global::ImGui.ImRect.__Internal ClipRect;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiColumnData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiColumnData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiColumnData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiColumnData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiColumnData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiColumnData __CreateInstance(global::ImGui.ImGuiColumnData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiColumnData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiColumnData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiColumnData.__Internal));
            *(global::ImGui.ImGuiColumnData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiColumnData(global::ImGui.ImGuiColumnData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiColumnData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiColumnData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiColumnData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiColumnData(global::ImGui.ImGuiColumnData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiColumnData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiColumnData.__Internal*) __Instance) = *((global::ImGui.ImGuiColumnData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiColumnData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float OffsetNorm
        {
            get
            {
                return ((global::ImGui.ImGuiColumnData.__Internal*) __Instance)->OffsetNorm;
            }

            set
            {
                ((global::ImGui.ImGuiColumnData.__Internal*)__Instance)->OffsetNorm = value;
            }
        }

        public float OffsetNormBeforeResize
        {
            get
            {
                return ((global::ImGui.ImGuiColumnData.__Internal*) __Instance)->OffsetNormBeforeResize;
            }

            set
            {
                ((global::ImGui.ImGuiColumnData.__Internal*)__Instance)->OffsetNormBeforeResize = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((global::ImGui.ImGuiColumnData.__Internal*) __Instance)->Flags;
            }

            set
            {
                ((global::ImGui.ImGuiColumnData.__Internal*)__Instance)->Flags = value;
            }
        }

        public global::ImGui.ImRect ClipRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiColumnData.__Internal*) __Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiColumnData.__Internal*)__Instance)->ClipRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiColumns : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 120)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint ID;

            [FieldOffset(4)]
            internal int Flags;

            [FieldOffset(8)]
            internal byte IsFirstFrame;

            [FieldOffset(9)]
            internal byte IsBeingResized;

            [FieldOffset(12)]
            internal int Current;

            [FieldOffset(16)]
            internal int Count;

            [FieldOffset(20)]
            internal float OffMinX;

            [FieldOffset(24)]
            internal float OffMaxX;

            [FieldOffset(28)]
            internal float LineMinY;

            [FieldOffset(32)]
            internal float LineMaxY;

            [FieldOffset(36)]
            internal float HostCursorPosY;

            [FieldOffset(40)]
            internal float HostCursorMaxPosX;

            [FieldOffset(44)]
            internal global::ImGui.ImRect.__Internal HostClipRect;

            [FieldOffset(60)]
            internal global::ImGui.ImRect.__Internal HostWorkRect;

            [FieldOffset(80)]
            internal global::ImGui.ImVectorImGuiColumnData.__Internal Columns;

            [FieldOffset(96)]
            internal global::ImGui.ImDrawListSplitter.__Internal Splitter;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiColumns@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiColumns> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiColumns>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiColumns __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiColumns(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiColumns __CreateInstance(global::ImGui.ImGuiColumns.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiColumns(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiColumns.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiColumns.__Internal));
            *(global::ImGui.ImGuiColumns.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiColumns(global::ImGui.ImGuiColumns.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiColumns(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiColumns()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiColumns.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiColumns(global::ImGui.ImGuiColumns _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiColumns.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiColumns.__Internal*) __Instance) = *((global::ImGui.ImGuiColumns.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiColumns __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->ID;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->Flags;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->Flags = value;
            }
        }

        public bool IsFirstFrame
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->IsFirstFrame != 0;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->IsFirstFrame = (byte) (value ? 1 : 0);
            }
        }

        public bool IsBeingResized
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->IsBeingResized != 0;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->IsBeingResized = (byte) (value ? 1 : 0);
            }
        }

        public int Current
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->Current;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->Current = value;
            }
        }

        public int Count
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->Count;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->Count = value;
            }
        }

        public float OffMinX
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->OffMinX;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->OffMinX = value;
            }
        }

        public float OffMaxX
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->OffMaxX;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->OffMaxX = value;
            }
        }

        public float LineMinY
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->LineMinY;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->LineMinY = value;
            }
        }

        public float LineMaxY
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->LineMaxY;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->LineMaxY = value;
            }
        }

        public float HostCursorPosY
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->HostCursorPosY;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->HostCursorPosY = value;
            }
        }

        public float HostCursorMaxPosX
        {
            get
            {
                return ((global::ImGui.ImGuiColumns.__Internal*) __Instance)->HostCursorMaxPosX;
            }

            set
            {
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->HostCursorMaxPosX = value;
            }
        }

        public global::ImGui.ImRect HostClipRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiColumns.__Internal*) __Instance)->HostClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->HostClipRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImRect HostWorkRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiColumns.__Internal*) __Instance)->HostWorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->HostWorkRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiColumnData Columns
        {
            get
            {
                return global::ImGui.ImVectorImGuiColumnData.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiColumns.__Internal*) __Instance)->Columns));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->Columns = *(global::ImGui.ImVectorImGuiColumnData.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImDrawListSplitter Splitter
        {
            get
            {
                return global::ImGui.ImDrawListSplitter.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiColumns.__Internal*) __Instance)->Splitter));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiColumns.__Internal*)__Instance)->Splitter = *(global::ImGui.ImDrawListSplitter.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawListSharedData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 208)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVec2.__Internal TexUvWhitePixel;

            [FieldOffset(8)]
            internal global::System.IntPtr Font;

            [FieldOffset(16)]
            internal float FontSize;

            [FieldOffset(20)]
            internal float CurveTessellationTol;

            [FieldOffset(24)]
            internal float CircleSegmentMaxError;

            [FieldOffset(28)]
            internal global::ImGui.ImVec4.__Internal ClipRectFullscreen;

            [FieldOffset(44)]
            internal int InitialFlags;

            [FieldOffset(48)]
            internal fixed byte CircleVtx12[96];

            [FieldOffset(144)]
            internal fixed byte CircleSegmentCounts[64];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImDrawListSharedData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawListSharedData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawListSharedData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImDrawListSharedData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawListSharedData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImDrawListSharedData __CreateInstance(global::ImGui.ImDrawListSharedData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawListSharedData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImDrawListSharedData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawListSharedData.__Internal));
            *(global::ImGui.ImDrawListSharedData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawListSharedData(global::ImGui.ImDrawListSharedData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawListSharedData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImDrawListSharedData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawListSharedData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawListSharedData(global::ImGui.ImDrawListSharedData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawListSharedData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImDrawListSharedData.__Internal*) __Instance) = *((global::ImGui.ImDrawListSharedData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImDrawListSharedData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVec2 TexUvWhitePixel
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->TexUvWhitePixel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawListSharedData.__Internal*)__Instance)->TexUvWhitePixel = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImFont Font
        {
            get
            {
                global::ImGui.ImFont __result0;
                if (((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->Font == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->Font))
                    __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->Font];
                else __result0 = global::ImGui.ImFont.__CreateInstance(((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->Font);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImDrawListSharedData.__Internal*)__Instance)->Font = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public float FontSize
        {
            get
            {
                return ((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->FontSize;
            }

            set
            {
                ((global::ImGui.ImDrawListSharedData.__Internal*)__Instance)->FontSize = value;
            }
        }

        public float CurveTessellationTol
        {
            get
            {
                return ((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->CurveTessellationTol;
            }

            set
            {
                ((global::ImGui.ImDrawListSharedData.__Internal*)__Instance)->CurveTessellationTol = value;
            }
        }

        public float CircleSegmentMaxError
        {
            get
            {
                return ((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->CircleSegmentMaxError;
            }

            set
            {
                ((global::ImGui.ImDrawListSharedData.__Internal*)__Instance)->CircleSegmentMaxError = value;
            }
        }

        public global::ImGui.ImVec4 ClipRectFullscreen
        {
            get
            {
                return global::ImGui.ImVec4.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->ClipRectFullscreen));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImDrawListSharedData.__Internal*)__Instance)->ClipRectFullscreen = *(global::ImGui.ImVec4.__Internal*) value.__Instance;
            }
        }

        public int InitialFlags
        {
            get
            {
                return ((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->InitialFlags;
            }

            set
            {
                ((global::ImGui.ImDrawListSharedData.__Internal*)__Instance)->InitialFlags = value;
            }
        }

        public global::ImGui.ImVec2[] CircleVtx12
        {
            get
            {
                global::ImGui.ImVec2[] __value = null;
                if (((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->CircleVtx12 != null)
                {
                    __value = new global::ImGui.ImVec2[12];
                    for (int i = 0; i < 12; i++)
                        __value[i] = global::ImGui.ImVec2.__CreateInstance(*((global::ImGui.ImVec2.__Internal*)&(((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->CircleVtx12[i * sizeof(global::ImGui.ImVec2.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 12)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 12; i++)
                        *(global::ImGui.ImVec2.__Internal*) &((global::ImGui.ImDrawListSharedData.__Internal*)__Instance)->CircleVtx12[i * sizeof(global::ImGui.ImVec2.__Internal)] = *(global::ImGui.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public byte[] CircleSegmentCounts
        {
            get
            {
                byte[] __value = null;
                if (((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->CircleSegmentCounts != null)
                {
                    __value = new byte[64];
                    for (int i = 0; i < 64; i++)
                        __value[i] = ((global::ImGui.ImDrawListSharedData.__Internal*) __Instance)->CircleSegmentCounts[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((global::ImGui.ImDrawListSharedData.__Internal*)__Instance)->CircleSegmentCounts[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImDrawDataBuilder : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed byte Layers[32];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImDrawDataBuilder@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawDataBuilder> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImDrawDataBuilder>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImDrawDataBuilder __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawDataBuilder(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImDrawDataBuilder __CreateInstance(global::ImGui.ImDrawDataBuilder.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImDrawDataBuilder(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImDrawDataBuilder.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawDataBuilder.__Internal));
            *(global::ImGui.ImDrawDataBuilder.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawDataBuilder(global::ImGui.ImDrawDataBuilder.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawDataBuilder(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImDrawDataBuilder()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawDataBuilder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawDataBuilder(global::ImGui.ImDrawDataBuilder _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImDrawDataBuilder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImDrawDataBuilder.__Internal*) __Instance) = *((global::ImGui.ImDrawDataBuilder.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImDrawDataBuilder __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVectorImDrawListPtr[] Layers
        {
            get
            {
                global::ImGui.ImVectorImDrawListPtr[] __value = null;
                if (((global::ImGui.ImDrawDataBuilder.__Internal*) __Instance)->Layers != null)
                {
                    __value = new global::ImGui.ImVectorImDrawListPtr[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::ImGui.ImVectorImDrawListPtr.__CreateInstance(*((global::ImGui.ImVectorImDrawListPtr.__Internal*)&(((global::ImGui.ImDrawDataBuilder.__Internal*) __Instance)->Layers[i * sizeof(global::ImGui.ImVectorImDrawListPtr.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        *(global::ImGui.ImVectorImDrawListPtr.__Internal*) &((global::ImGui.ImDrawDataBuilder.__Internal*)__Instance)->Layers[i * sizeof(global::ImGui.ImVectorImDrawListPtr.__Internal)] = *(global::ImGui.ImVectorImDrawListPtr.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class ImGuiNavMoveResult : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 48)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr Window;

            [FieldOffset(8)]
            internal uint ID;

            [FieldOffset(12)]
            internal uint FocusScopeId;

            [FieldOffset(16)]
            internal float DistBox;

            [FieldOffset(20)]
            internal float DistCenter;

            [FieldOffset(24)]
            internal float DistAxial;

            [FieldOffset(28)]
            internal global::ImGui.ImRect.__Internal RectRel;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiNavMoveResult@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiNavMoveResult> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiNavMoveResult>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiNavMoveResult __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiNavMoveResult(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiNavMoveResult __CreateInstance(global::ImGui.ImGuiNavMoveResult.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiNavMoveResult(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiNavMoveResult.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiNavMoveResult.__Internal));
            *(global::ImGui.ImGuiNavMoveResult.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiNavMoveResult(global::ImGui.ImGuiNavMoveResult.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiNavMoveResult(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiNavMoveResult()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiNavMoveResult.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiNavMoveResult(global::ImGui.ImGuiNavMoveResult _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiNavMoveResult.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiNavMoveResult.__Internal*) __Instance) = *((global::ImGui.ImGuiNavMoveResult.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiNavMoveResult __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImGuiWindow Window
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiNavMoveResult.__Internal*) __Instance)->Window == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiNavMoveResult.__Internal*) __Instance)->Window))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiNavMoveResult.__Internal*) __Instance)->Window];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiNavMoveResult.__Internal*) __Instance)->Window);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiNavMoveResult.__Internal*)__Instance)->Window = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public uint ID
        {
            get
            {
                return ((global::ImGui.ImGuiNavMoveResult.__Internal*) __Instance)->ID;
            }

            set
            {
                ((global::ImGui.ImGuiNavMoveResult.__Internal*)__Instance)->ID = value;
            }
        }

        public uint FocusScopeId
        {
            get
            {
                return ((global::ImGui.ImGuiNavMoveResult.__Internal*) __Instance)->FocusScopeId;
            }

            set
            {
                ((global::ImGui.ImGuiNavMoveResult.__Internal*)__Instance)->FocusScopeId = value;
            }
        }

        public float DistBox
        {
            get
            {
                return ((global::ImGui.ImGuiNavMoveResult.__Internal*) __Instance)->DistBox;
            }

            set
            {
                ((global::ImGui.ImGuiNavMoveResult.__Internal*)__Instance)->DistBox = value;
            }
        }

        public float DistCenter
        {
            get
            {
                return ((global::ImGui.ImGuiNavMoveResult.__Internal*) __Instance)->DistCenter;
            }

            set
            {
                ((global::ImGui.ImGuiNavMoveResult.__Internal*)__Instance)->DistCenter = value;
            }
        }

        public float DistAxial
        {
            get
            {
                return ((global::ImGui.ImGuiNavMoveResult.__Internal*) __Instance)->DistAxial;
            }

            set
            {
                ((global::ImGui.ImGuiNavMoveResult.__Internal*)__Instance)->DistAxial = value;
            }
        }

        public global::ImGui.ImRect RectRel
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiNavMoveResult.__Internal*) __Instance)->RectRel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiNavMoveResult.__Internal*)__Instance)->RectRel = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiNextWindowData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Flags;

            [FieldOffset(4)]
            internal int PosCond;

            [FieldOffset(8)]
            internal int SizeCond;

            [FieldOffset(12)]
            internal int CollapsedCond;

            [FieldOffset(16)]
            internal global::ImGui.ImVec2.__Internal PosVal;

            [FieldOffset(24)]
            internal global::ImGui.ImVec2.__Internal PosPivotVal;

            [FieldOffset(32)]
            internal global::ImGui.ImVec2.__Internal SizeVal;

            [FieldOffset(40)]
            internal global::ImGui.ImVec2.__Internal ContentSizeVal;

            [FieldOffset(48)]
            internal byte CollapsedVal;

            [FieldOffset(52)]
            internal global::ImGui.ImRect.__Internal SizeConstraintRect;

            [FieldOffset(72)]
            internal global::System.IntPtr SizeCallback;

            [FieldOffset(80)]
            internal global::System.IntPtr SizeCallbackUserData;

            [FieldOffset(88)]
            internal float BgAlphaVal;

            [FieldOffset(92)]
            internal global::ImGui.ImVec2.__Internal MenuBarOffsetMinVal;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiNextWindowData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiNextWindowData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiNextWindowData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiNextWindowData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiNextWindowData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiNextWindowData __CreateInstance(global::ImGui.ImGuiNextWindowData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiNextWindowData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiNextWindowData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiNextWindowData.__Internal));
            *(global::ImGui.ImGuiNextWindowData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiNextWindowData(global::ImGui.ImGuiNextWindowData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiNextWindowData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiNextWindowData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiNextWindowData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiNextWindowData(global::ImGui.ImGuiNextWindowData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiNextWindowData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance) = *((global::ImGui.ImGuiNextWindowData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiNextWindowData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->Flags;
            }

            set
            {
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->Flags = value;
            }
        }

        public int PosCond
        {
            get
            {
                return ((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->PosCond;
            }

            set
            {
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->PosCond = value;
            }
        }

        public int SizeCond
        {
            get
            {
                return ((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->SizeCond;
            }

            set
            {
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->SizeCond = value;
            }
        }

        public int CollapsedCond
        {
            get
            {
                return ((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->CollapsedCond;
            }

            set
            {
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->CollapsedCond = value;
            }
        }

        public global::ImGui.ImVec2 PosVal
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->PosVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->PosVal = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 PosPivotVal
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->PosPivotVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->PosPivotVal = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 SizeVal
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->SizeVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->SizeVal = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 ContentSizeVal
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->ContentSizeVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->ContentSizeVal = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool CollapsedVal
        {
            get
            {
                return ((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->CollapsedVal != 0;
            }

            set
            {
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->CollapsedVal = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGui.ImRect SizeConstraintRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->SizeConstraintRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->SizeConstraintRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiSizeCallback SizeCallback
        {
            get
            {
                var __ptr0 = ((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->SizeCallback;
                return __ptr0 == IntPtr.Zero? null : (global::ImGui.ImGuiSizeCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::ImGui.ImGuiSizeCallback));
            }

            set
            {
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->SizeCallback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::System.IntPtr SizeCallbackUserData
        {
            get
            {
                return ((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->SizeCallbackUserData;
            }

            set
            {
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->SizeCallbackUserData = (global::System.IntPtr) value;
            }
        }

        public float BgAlphaVal
        {
            get
            {
                return ((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->BgAlphaVal;
            }

            set
            {
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->BgAlphaVal = value;
            }
        }

        public global::ImGui.ImVec2 MenuBarOffsetMinVal
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiNextWindowData.__Internal*) __Instance)->MenuBarOffsetMinVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiNextWindowData.__Internal*)__Instance)->MenuBarOffsetMinVal = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiNextItemData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 20)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Flags;

            [FieldOffset(4)]
            internal float Width;

            [FieldOffset(8)]
            internal uint FocusScopeId;

            [FieldOffset(12)]
            internal int OpenCond;

            [FieldOffset(16)]
            internal byte OpenVal;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiNextItemData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiNextItemData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiNextItemData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiNextItemData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiNextItemData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiNextItemData __CreateInstance(global::ImGui.ImGuiNextItemData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiNextItemData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiNextItemData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiNextItemData.__Internal));
            *(global::ImGui.ImGuiNextItemData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiNextItemData(global::ImGui.ImGuiNextItemData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiNextItemData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiNextItemData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiNextItemData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiNextItemData(global::ImGui.ImGuiNextItemData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiNextItemData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiNextItemData.__Internal*) __Instance) = *((global::ImGui.ImGuiNextItemData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiNextItemData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((global::ImGui.ImGuiNextItemData.__Internal*) __Instance)->Flags;
            }

            set
            {
                ((global::ImGui.ImGuiNextItemData.__Internal*)__Instance)->Flags = value;
            }
        }

        public float Width
        {
            get
            {
                return ((global::ImGui.ImGuiNextItemData.__Internal*) __Instance)->Width;
            }

            set
            {
                ((global::ImGui.ImGuiNextItemData.__Internal*)__Instance)->Width = value;
            }
        }

        public uint FocusScopeId
        {
            get
            {
                return ((global::ImGui.ImGuiNextItemData.__Internal*) __Instance)->FocusScopeId;
            }

            set
            {
                ((global::ImGui.ImGuiNextItemData.__Internal*)__Instance)->FocusScopeId = value;
            }
        }

        public int OpenCond
        {
            get
            {
                return ((global::ImGui.ImGuiNextItemData.__Internal*) __Instance)->OpenCond;
            }

            set
            {
                ((global::ImGui.ImGuiNextItemData.__Internal*)__Instance)->OpenCond = value;
            }
        }

        public bool OpenVal
        {
            get
            {
                return ((global::ImGui.ImGuiNextItemData.__Internal*) __Instance)->OpenVal != 0;
            }

            set
            {
                ((global::ImGui.ImGuiNextItemData.__Internal*)__Instance)->OpenVal = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiShrinkWidthItem : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal int Index;

            [FieldOffset(4)]
            internal float Width;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiShrinkWidthItem@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiShrinkWidthItem> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiShrinkWidthItem>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiShrinkWidthItem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiShrinkWidthItem(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiShrinkWidthItem __CreateInstance(global::ImGui.ImGuiShrinkWidthItem.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiShrinkWidthItem(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiShrinkWidthItem.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiShrinkWidthItem.__Internal));
            *(global::ImGui.ImGuiShrinkWidthItem.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiShrinkWidthItem(global::ImGui.ImGuiShrinkWidthItem.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiShrinkWidthItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiShrinkWidthItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiShrinkWidthItem(global::ImGui.ImGuiShrinkWidthItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiShrinkWidthItem.__Internal*) __Instance) = *((global::ImGui.ImGuiShrinkWidthItem.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiShrinkWidthItem __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Index
        {
            get
            {
                return ((global::ImGui.ImGuiShrinkWidthItem.__Internal*) __Instance)->Index;
            }

            set
            {
                ((global::ImGui.ImGuiShrinkWidthItem.__Internal*)__Instance)->Index = value;
            }
        }

        public float Width
        {
            get
            {
                return ((global::ImGui.ImGuiShrinkWidthItem.__Internal*) __Instance)->Width;
            }

            set
            {
                ((global::ImGui.ImGuiShrinkWidthItem.__Internal*)__Instance)->Width = value;
            }
        }
    }

    public unsafe partial class ImGuiPtrOrIndex : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr Ptr;

            [FieldOffset(8)]
            internal int Index;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiPtrOrIndex@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiPtrOrIndex> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiPtrOrIndex>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiPtrOrIndex __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiPtrOrIndex(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiPtrOrIndex __CreateInstance(global::ImGui.ImGuiPtrOrIndex.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiPtrOrIndex(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiPtrOrIndex.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiPtrOrIndex.__Internal));
            *(global::ImGui.ImGuiPtrOrIndex.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPtrOrIndex(global::ImGui.ImGuiPtrOrIndex.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiPtrOrIndex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiPtrOrIndex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiPtrOrIndex(global::ImGui.ImGuiPtrOrIndex _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiPtrOrIndex.__Internal*) __Instance) = *((global::ImGui.ImGuiPtrOrIndex.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiPtrOrIndex __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::System.IntPtr Ptr
        {
            get
            {
                return ((global::ImGui.ImGuiPtrOrIndex.__Internal*) __Instance)->Ptr;
            }

            set
            {
                ((global::ImGui.ImGuiPtrOrIndex.__Internal*)__Instance)->Ptr = (global::System.IntPtr) value;
            }
        }

        public int Index
        {
            get
            {
                return ((global::ImGui.ImGuiPtrOrIndex.__Internal*) __Instance)->Index;
            }

            set
            {
                ((global::ImGui.ImGuiPtrOrIndex.__Internal*)__Instance)->Index = value;
            }
        }
    }

    public unsafe partial class ImGuiContext : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 15792)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal byte Initialized;

            [FieldOffset(1)]
            internal byte FontAtlasOwnedByContext;

            [FieldOffset(8)]
            internal global::ImGui.ImGuiIO.__Internal IO;

            [FieldOffset(5464)]
            internal global::ImGui.ImGuiStyle.__Internal Style;

            [FieldOffset(6416)]
            internal global::System.IntPtr Font;

            [FieldOffset(6424)]
            internal float FontSize;

            [FieldOffset(6428)]
            internal float FontBaseSize;

            [FieldOffset(6432)]
            internal global::ImGui.ImDrawListSharedData.__Internal DrawListSharedData;

            [FieldOffset(6640)]
            internal double Time;

            [FieldOffset(6648)]
            internal int FrameCount;

            [FieldOffset(6652)]
            internal int FrameCountEnded;

            [FieldOffset(6656)]
            internal int FrameCountRendered;

            [FieldOffset(6660)]
            internal byte WithinFrameScope;

            [FieldOffset(6661)]
            internal byte WithinFrameScopeWithImplicitWindow;

            [FieldOffset(6662)]
            internal byte WithinEndChild;

            [FieldOffset(6664)]
            internal global::ImGui.ImVectorImGuiWindowPtr.__Internal Windows;

            [FieldOffset(6680)]
            internal global::ImGui.ImVectorImGuiWindowPtr.__Internal WindowsFocusOrder;

            [FieldOffset(6696)]
            internal global::ImGui.ImVectorImGuiWindowPtr.__Internal WindowsTempSortBuffer;

            [FieldOffset(6712)]
            internal global::ImGui.ImVectorImGuiWindowPtr.__Internal CurrentWindowStack;

            [FieldOffset(6728)]
            internal global::ImGui.ImGuiStorage.__Internal WindowsById;

            [FieldOffset(6744)]
            internal int WindowsActiveCount;

            [FieldOffset(6752)]
            internal global::System.IntPtr CurrentWindow;

            [FieldOffset(6760)]
            internal global::System.IntPtr HoveredWindow;

            [FieldOffset(6768)]
            internal global::System.IntPtr HoveredRootWindow;

            [FieldOffset(6776)]
            internal global::System.IntPtr MovingWindow;

            [FieldOffset(6784)]
            internal global::System.IntPtr WheelingWindow;

            [FieldOffset(6792)]
            internal global::ImGui.ImVec2.__Internal WheelingWindowRefMousePos;

            [FieldOffset(6800)]
            internal float WheelingWindowTimer;

            [FieldOffset(6804)]
            internal uint HoveredId;

            [FieldOffset(6808)]
            internal byte HoveredIdAllowOverlap;

            [FieldOffset(6812)]
            internal uint HoveredIdPreviousFrame;

            [FieldOffset(6816)]
            internal float HoveredIdTimer;

            [FieldOffset(6820)]
            internal float HoveredIdNotActiveTimer;

            [FieldOffset(6824)]
            internal uint ActiveId;

            [FieldOffset(6828)]
            internal uint ActiveIdIsAlive;

            [FieldOffset(6832)]
            internal float ActiveIdTimer;

            [FieldOffset(6836)]
            internal byte ActiveIdIsJustActivated;

            [FieldOffset(6837)]
            internal byte ActiveIdAllowOverlap;

            [FieldOffset(6838)]
            internal byte ActiveIdHasBeenPressedBefore;

            [FieldOffset(6839)]
            internal byte ActiveIdHasBeenEditedBefore;

            [FieldOffset(6840)]
            internal byte ActiveIdHasBeenEditedThisFrame;

            [FieldOffset(6844)]
            internal uint ActiveIdUsingNavDirMask;

            [FieldOffset(6848)]
            internal uint ActiveIdUsingNavInputMask;

            [FieldOffset(6856)]
            internal ulong ActiveIdUsingKeyInputMask;

            [FieldOffset(6864)]
            internal global::ImGui.ImVec2.__Internal ActiveIdClickOffset;

            [FieldOffset(6872)]
            internal global::System.IntPtr ActiveIdWindow;

            [FieldOffset(6880)]
            internal global::ImGui.ImGuiInputSource ActiveIdSource;

            [FieldOffset(6884)]
            internal int ActiveIdMouseButton;

            [FieldOffset(6888)]
            internal uint ActiveIdPreviousFrame;

            [FieldOffset(6892)]
            internal byte ActiveIdPreviousFrameIsAlive;

            [FieldOffset(6893)]
            internal byte ActiveIdPreviousFrameHasBeenEditedBefore;

            [FieldOffset(6896)]
            internal global::System.IntPtr ActiveIdPreviousFrameWindow;

            [FieldOffset(6904)]
            internal uint LastActiveId;

            [FieldOffset(6908)]
            internal float LastActiveIdTimer;

            [FieldOffset(6912)]
            internal global::ImGui.ImGuiNextWindowData.__Internal NextWindowData;

            [FieldOffset(7016)]
            internal global::ImGui.ImGuiNextItemData.__Internal NextItemData;

            [FieldOffset(7040)]
            internal global::ImGui.ImVectorImGuiColorMod.__Internal ColorModifiers;

            [FieldOffset(7056)]
            internal global::ImGui.ImVectorImGuiStyleMod.__Internal StyleModifiers;

            [FieldOffset(7072)]
            internal global::ImGui.ImVectorImFontPtr.__Internal FontStack;

            [FieldOffset(7088)]
            internal global::ImGui.ImVectorImGuiPopupData.__Internal OpenPopupStack;

            [FieldOffset(7104)]
            internal global::ImGui.ImVectorImGuiPopupData.__Internal BeginPopupStack;

            [FieldOffset(7120)]
            internal global::System.IntPtr NavWindow;

            [FieldOffset(7128)]
            internal uint NavId;

            [FieldOffset(7132)]
            internal uint NavFocusScopeId;

            [FieldOffset(7136)]
            internal uint NavActivateId;

            [FieldOffset(7140)]
            internal uint NavActivateDownId;

            [FieldOffset(7144)]
            internal uint NavActivatePressedId;

            [FieldOffset(7148)]
            internal uint NavInputId;

            [FieldOffset(7152)]
            internal uint NavJustTabbedId;

            [FieldOffset(7156)]
            internal uint NavJustMovedToId;

            [FieldOffset(7160)]
            internal uint NavJustMovedToFocusScopeId;

            [FieldOffset(7164)]
            internal uint NavNextActivateId;

            [FieldOffset(7168)]
            internal global::ImGui.ImGuiInputSource NavInputSource;

            [FieldOffset(7172)]
            internal global::ImGui.ImRect.__Internal NavScoringRectScreen;

            [FieldOffset(7188)]
            internal int NavScoringCount;

            [FieldOffset(7192)]
            internal global::ImGui.ImGuiNavLayer NavLayer;

            [FieldOffset(7196)]
            internal int NavIdTabCounter;

            [FieldOffset(7200)]
            internal byte NavIdIsAlive;

            [FieldOffset(7201)]
            internal byte NavMousePosDirty;

            [FieldOffset(7202)]
            internal byte NavDisableHighlight;

            [FieldOffset(7203)]
            internal byte NavDisableMouseHover;

            [FieldOffset(7204)]
            internal byte NavAnyRequest;

            [FieldOffset(7205)]
            internal byte NavInitRequest;

            [FieldOffset(7206)]
            internal byte NavInitRequestFromMove;

            [FieldOffset(7208)]
            internal uint NavInitResultId;

            [FieldOffset(7212)]
            internal global::ImGui.ImRect.__Internal NavInitResultRectRel;

            [FieldOffset(7228)]
            internal byte NavMoveFromClampedRefRect;

            [FieldOffset(7229)]
            internal byte NavMoveRequest;

            [FieldOffset(7232)]
            internal int NavMoveRequestFlags;

            [FieldOffset(7236)]
            internal global::ImGui.ImGuiNavForward NavMoveRequestForward;

            [FieldOffset(7240)]
            internal int NavMoveDir;

            [FieldOffset(7244)]
            internal int NavMoveDirLast;

            [FieldOffset(7248)]
            internal int NavMoveClipDir;

            [FieldOffset(7256)]
            internal global::ImGui.ImGuiNavMoveResult.__Internal NavMoveResultLocal;

            [FieldOffset(7304)]
            internal global::ImGui.ImGuiNavMoveResult.__Internal NavMoveResultLocalVisibleSet;

            [FieldOffset(7352)]
            internal global::ImGui.ImGuiNavMoveResult.__Internal NavMoveResultOther;

            [FieldOffset(7400)]
            internal global::System.IntPtr NavWindowingTarget;

            [FieldOffset(7408)]
            internal global::System.IntPtr NavWindowingTargetAnim;

            [FieldOffset(7416)]
            internal global::System.IntPtr NavWindowingList;

            [FieldOffset(7424)]
            internal float NavWindowingTimer;

            [FieldOffset(7428)]
            internal float NavWindowingHighlightAlpha;

            [FieldOffset(7432)]
            internal byte NavWindowingToggleLayer;

            [FieldOffset(7440)]
            internal global::System.IntPtr FocusRequestCurrWindow;

            [FieldOffset(7448)]
            internal global::System.IntPtr FocusRequestNextWindow;

            [FieldOffset(7456)]
            internal int FocusRequestCurrCounterRegular;

            [FieldOffset(7460)]
            internal int FocusRequestCurrCounterTabStop;

            [FieldOffset(7464)]
            internal int FocusRequestNextCounterRegular;

            [FieldOffset(7468)]
            internal int FocusRequestNextCounterTabStop;

            [FieldOffset(7472)]
            internal byte FocusTabPressed;

            [FieldOffset(7480)]
            internal global::ImGui.ImDrawData.__Internal DrawData;

            [FieldOffset(7536)]
            internal global::ImGui.ImDrawDataBuilder.__Internal DrawDataBuilder;

            [FieldOffset(7568)]
            internal float DimBgRatio;

            [FieldOffset(7576)]
            internal global::ImGui.ImDrawList.__Internal BackgroundDrawList;

            [FieldOffset(7744)]
            internal global::ImGui.ImDrawList.__Internal ForegroundDrawList;

            [FieldOffset(7912)]
            internal int MouseCursor;

            [FieldOffset(7916)]
            internal byte DragDropActive;

            [FieldOffset(7917)]
            internal byte DragDropWithinSourceOrTarget;

            [FieldOffset(7920)]
            internal int DragDropSourceFlags;

            [FieldOffset(7924)]
            internal int DragDropSourceFrameCount;

            [FieldOffset(7928)]
            internal int DragDropMouseButton;

            [FieldOffset(7936)]
            internal global::ImGui.ImGuiPayload.__Internal DragDropPayload;

            [FieldOffset(8000)]
            internal global::ImGui.ImRect.__Internal DragDropTargetRect;

            [FieldOffset(8016)]
            internal uint DragDropTargetId;

            [FieldOffset(8020)]
            internal int DragDropAcceptFlags;

            [FieldOffset(8024)]
            internal float DragDropAcceptIdCurrRectSurface;

            [FieldOffset(8028)]
            internal uint DragDropAcceptIdCurr;

            [FieldOffset(8032)]
            internal uint DragDropAcceptIdPrev;

            [FieldOffset(8036)]
            internal int DragDropAcceptFrameCount;

            [FieldOffset(8040)]
            internal global::ImGui.ImVector_unsigned_char.__Internal DragDropPayloadBufHeap;

            [FieldOffset(8056)]
            internal fixed byte DragDropPayloadBufLocal[16];

            [FieldOffset(8072)]
            internal global::System.IntPtr CurrentTabBar;

            [FieldOffset(8080)]
            internal global::ImGui.ImPoolImGuiTabBar.__Internal TabBars;

            [FieldOffset(8120)]
            internal global::ImGui.ImVectorImGuiPtrOrIndex.__Internal CurrentTabBarStack;

            [FieldOffset(8136)]
            internal global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal ShrinkWidthBuffer;

            [FieldOffset(8152)]
            internal global::ImGui.ImVec2.__Internal LastValidMousePos;

            [FieldOffset(8160)]
            internal global::ImGui.ImGuiInputTextState.__Internal InputTextState;

            [FieldOffset(11888)]
            internal global::ImGui.ImFont.__Internal InputTextPasswordFont;

            [FieldOffset(12000)]
            internal uint TempInputTextId;

            [FieldOffset(12004)]
            internal int ColorEditOptions;

            [FieldOffset(12008)]
            internal float ColorEditLastHue;

            [FieldOffset(12012)]
            internal float ColorEditLastSat;

            [FieldOffset(12016)]
            internal fixed float ColorEditLastColor[3];

            [FieldOffset(12028)]
            internal global::ImGui.ImVec4.__Internal ColorPickerRef;

            [FieldOffset(12044)]
            internal byte DragCurrentAccumDirty;

            [FieldOffset(12048)]
            internal float DragCurrentAccum;

            [FieldOffset(12052)]
            internal float DragSpeedDefaultRatio;

            [FieldOffset(12056)]
            internal float ScrollbarClickDeltaToGrabCenter;

            [FieldOffset(12060)]
            internal int TooltipOverrideCount;

            [FieldOffset(12064)]
            internal global::ImGui.ImVector_char.__Internal PrivateClipboard;

            [FieldOffset(12080)]
            internal global::ImGui.ImVec2.__Internal PlatformImePos;

            [FieldOffset(12088)]
            internal global::ImGui.ImVec2.__Internal PlatformImeLastPos;

            [FieldOffset(12096)]
            internal byte SettingsLoaded;

            [FieldOffset(12100)]
            internal float SettingsDirtyTimer;

            [FieldOffset(12104)]
            internal global::ImGui.ImGuiTextBuffer.__Internal SettingsIniData;

            [FieldOffset(12120)]
            internal global::ImGui.ImVectorImGuiSettingsHandler.__Internal SettingsHandlers;

            [FieldOffset(12136)]
            internal global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal SettingsWindows;

            [FieldOffset(12152)]
            internal byte LogEnabled;

            [FieldOffset(12156)]
            internal global::ImGui.ImGuiLogType LogType;

            [FieldOffset(12160)]
            internal global::System.IntPtr LogFile;

            [FieldOffset(12168)]
            internal global::ImGui.ImGuiTextBuffer.__Internal LogBuffer;

            [FieldOffset(12184)]
            internal float LogLinePosY;

            [FieldOffset(12188)]
            internal byte LogLineFirstItem;

            [FieldOffset(12192)]
            internal int LogDepthRef;

            [FieldOffset(12196)]
            internal int LogDepthToExpand;

            [FieldOffset(12200)]
            internal int LogDepthToExpandDefault;

            [FieldOffset(12204)]
            internal byte DebugItemPickerActive;

            [FieldOffset(12208)]
            internal uint DebugItemPickerBreakId;

            [FieldOffset(12212)]
            internal fixed float FramerateSecPerFrame[120];

            [FieldOffset(12692)]
            internal int FramerateSecPerFrameIdx;

            [FieldOffset(12696)]
            internal float FramerateSecPerFrameAccum;

            [FieldOffset(12700)]
            internal int WantCaptureMouseNextFrame;

            [FieldOffset(12704)]
            internal int WantCaptureKeyboardNextFrame;

            [FieldOffset(12708)]
            internal int WantTextInputNextFrame;

            [FieldOffset(12712)]
            internal fixed sbyte TempBuffer[3073];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiContext@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiContext>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiContext __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiContext(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiContext __CreateInstance(global::ImGui.ImGuiContext.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiContext(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiContext.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiContext.__Internal));
            *(global::ImGui.ImGuiContext.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiContext(global::ImGui.ImGuiContext.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiContext()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiContext.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiContext(global::ImGui.ImGuiContext _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiContext.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiContext.__Internal*) __Instance) = *((global::ImGui.ImGuiContext.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiContext __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Initialized
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->Initialized != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->Initialized = (byte) (value ? 1 : 0);
            }
        }

        public bool FontAtlasOwnedByContext
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FontAtlasOwnedByContext != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FontAtlasOwnedByContext = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGui.ImGuiIO IO
        {
            get
            {
                return global::ImGui.ImGuiIO.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->IO));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->IO = *(global::ImGui.ImGuiIO.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiStyle Style
        {
            get
            {
                return global::ImGui.ImGuiStyle.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->Style));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->Style = *(global::ImGui.ImGuiStyle.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImFont Font
        {
            get
            {
                global::ImGui.ImFont __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->Font == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->Font))
                    __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->Font];
                else __result0 = global::ImGui.ImFont.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->Font);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->Font = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public float FontSize
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FontSize;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FontSize = value;
            }
        }

        public float FontBaseSize
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FontBaseSize;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FontBaseSize = value;
            }
        }

        public global::ImGui.ImDrawListSharedData DrawListSharedData
        {
            get
            {
                return global::ImGui.ImDrawListSharedData.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->DrawListSharedData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DrawListSharedData = *(global::ImGui.ImDrawListSharedData.__Internal*) value.__Instance;
            }
        }

        public double Time
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->Time;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->Time = value;
            }
        }

        public int FrameCount
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FrameCount;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FrameCount = value;
            }
        }

        public int FrameCountEnded
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FrameCountEnded;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FrameCountEnded = value;
            }
        }

        public int FrameCountRendered
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FrameCountRendered;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FrameCountRendered = value;
            }
        }

        public bool WithinFrameScope
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->WithinFrameScope != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WithinFrameScope = (byte) (value ? 1 : 0);
            }
        }

        public bool WithinFrameScopeWithImplicitWindow
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->WithinFrameScopeWithImplicitWindow != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WithinFrameScopeWithImplicitWindow = (byte) (value ? 1 : 0);
            }
        }

        public bool WithinEndChild
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->WithinEndChild != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WithinEndChild = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGui.ImVectorImGuiWindowPtr Windows
        {
            get
            {
                return global::ImGui.ImVectorImGuiWindowPtr.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->Windows));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->Windows = *(global::ImGui.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiWindowPtr WindowsFocusOrder
        {
            get
            {
                return global::ImGui.ImVectorImGuiWindowPtr.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->WindowsFocusOrder));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WindowsFocusOrder = *(global::ImGui.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiWindowPtr WindowsTempSortBuffer
        {
            get
            {
                return global::ImGui.ImVectorImGuiWindowPtr.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->WindowsTempSortBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WindowsTempSortBuffer = *(global::ImGui.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiWindowPtr CurrentWindowStack
        {
            get
            {
                return global::ImGui.ImVectorImGuiWindowPtr.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->CurrentWindowStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->CurrentWindowStack = *(global::ImGui.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiStorage WindowsById
        {
            get
            {
                return global::ImGui.ImGuiStorage.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->WindowsById));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WindowsById = *(global::ImGui.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public int WindowsActiveCount
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->WindowsActiveCount;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WindowsActiveCount = value;
            }
        }

        public global::ImGui.ImGuiWindow CurrentWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->CurrentWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->CurrentWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->CurrentWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->CurrentWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->CurrentWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow HoveredWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->HoveredWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow HoveredRootWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredRootWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredRootWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredRootWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredRootWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->HoveredRootWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow MovingWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->MovingWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->MovingWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->MovingWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->MovingWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->MovingWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow WheelingWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->WheelingWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->WheelingWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->WheelingWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->WheelingWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WheelingWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImVec2 WheelingWindowRefMousePos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->WheelingWindowRefMousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WheelingWindowRefMousePos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float WheelingWindowTimer
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->WheelingWindowTimer;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WheelingWindowTimer = value;
            }
        }

        public uint HoveredId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->HoveredId = value;
            }
        }

        public bool HoveredIdAllowOverlap
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredIdAllowOverlap != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->HoveredIdAllowOverlap = (byte) (value ? 1 : 0);
            }
        }

        public uint HoveredIdPreviousFrame
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredIdPreviousFrame;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->HoveredIdPreviousFrame = value;
            }
        }

        public float HoveredIdTimer
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredIdTimer;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->HoveredIdTimer = value;
            }
        }

        public float HoveredIdNotActiveTimer
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->HoveredIdNotActiveTimer;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->HoveredIdNotActiveTimer = value;
            }
        }

        public uint ActiveId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveId = value;
            }
        }

        public uint ActiveIdIsAlive
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdIsAlive;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdIsAlive = value;
            }
        }

        public float ActiveIdTimer
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdTimer;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdTimer = value;
            }
        }

        public bool ActiveIdIsJustActivated
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdIsJustActivated != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdIsJustActivated = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdAllowOverlap
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdAllowOverlap != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdAllowOverlap = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdHasBeenPressedBefore
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdHasBeenPressedBefore != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdHasBeenPressedBefore = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdHasBeenEditedBefore
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdHasBeenEditedBefore != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdHasBeenEditedBefore = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdHasBeenEditedThisFrame
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdHasBeenEditedThisFrame != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdHasBeenEditedThisFrame = (byte) (value ? 1 : 0);
            }
        }

        public uint ActiveIdUsingNavDirMask
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdUsingNavDirMask;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdUsingNavDirMask = value;
            }
        }

        public uint ActiveIdUsingNavInputMask
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdUsingNavInputMask;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdUsingNavInputMask = value;
            }
        }

        public ulong ActiveIdUsingKeyInputMask
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdUsingKeyInputMask;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdUsingKeyInputMask = value;
            }
        }

        public global::ImGui.ImVec2 ActiveIdClickOffset
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdClickOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdClickOffset = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow ActiveIdWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiInputSource ActiveIdSource
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdSource;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdSource = value;
            }
        }

        public int ActiveIdMouseButton
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdMouseButton;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdMouseButton = value;
            }
        }

        public uint ActiveIdPreviousFrame
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdPreviousFrame;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdPreviousFrame = value;
            }
        }

        public bool ActiveIdPreviousFrameIsAlive
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdPreviousFrameIsAlive != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdPreviousFrameIsAlive = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdPreviousFrameHasBeenEditedBefore
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdPreviousFrameHasBeenEditedBefore != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdPreviousFrameHasBeenEditedBefore = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGui.ImGuiWindow ActiveIdPreviousFrameWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdPreviousFrameWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdPreviousFrameWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdPreviousFrameWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->ActiveIdPreviousFrameWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ActiveIdPreviousFrameWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public uint LastActiveId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->LastActiveId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LastActiveId = value;
            }
        }

        public float LastActiveIdTimer
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->LastActiveIdTimer;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LastActiveIdTimer = value;
            }
        }

        public global::ImGui.ImGuiNextWindowData NextWindowData
        {
            get
            {
                return global::ImGui.ImGuiNextWindowData.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->NextWindowData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NextWindowData = *(global::ImGui.ImGuiNextWindowData.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiNextItemData NextItemData
        {
            get
            {
                return global::ImGui.ImGuiNextItemData.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->NextItemData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NextItemData = *(global::ImGui.ImGuiNextItemData.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiColorMod ColorModifiers
        {
            get
            {
                return global::ImGui.ImVectorImGuiColorMod.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->ColorModifiers));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ColorModifiers = *(global::ImGui.ImVectorImGuiColorMod.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiStyleMod StyleModifiers
        {
            get
            {
                return global::ImGui.ImVectorImGuiStyleMod.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->StyleModifiers));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->StyleModifiers = *(global::ImGui.ImVectorImGuiStyleMod.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImFontPtr FontStack
        {
            get
            {
                return global::ImGui.ImVectorImFontPtr.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->FontStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FontStack = *(global::ImGui.ImVectorImFontPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiPopupData OpenPopupStack
        {
            get
            {
                return global::ImGui.ImVectorImGuiPopupData.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->OpenPopupStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->OpenPopupStack = *(global::ImGui.ImVectorImGuiPopupData.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiPopupData BeginPopupStack
        {
            get
            {
                return global::ImGui.ImVectorImGuiPopupData.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->BeginPopupStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->BeginPopupStack = *(global::ImGui.ImVectorImGuiPopupData.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow NavWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public uint NavId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavId = value;
            }
        }

        public uint NavFocusScopeId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavFocusScopeId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavFocusScopeId = value;
            }
        }

        public uint NavActivateId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavActivateId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavActivateId = value;
            }
        }

        public uint NavActivateDownId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavActivateDownId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavActivateDownId = value;
            }
        }

        public uint NavActivatePressedId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavActivatePressedId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavActivatePressedId = value;
            }
        }

        public uint NavInputId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavInputId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavInputId = value;
            }
        }

        public uint NavJustTabbedId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavJustTabbedId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavJustTabbedId = value;
            }
        }

        public uint NavJustMovedToId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavJustMovedToId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavJustMovedToId = value;
            }
        }

        public uint NavJustMovedToFocusScopeId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavJustMovedToFocusScopeId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavJustMovedToFocusScopeId = value;
            }
        }

        public uint NavNextActivateId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavNextActivateId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavNextActivateId = value;
            }
        }

        public global::ImGui.ImGuiInputSource NavInputSource
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavInputSource;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavInputSource = value;
            }
        }

        public global::ImGui.ImRect NavScoringRectScreen
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavScoringRectScreen));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavScoringRectScreen = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public int NavScoringCount
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavScoringCount;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavScoringCount = value;
            }
        }

        public global::ImGui.ImGuiNavLayer NavLayer
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavLayer;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavLayer = value;
            }
        }

        public int NavIdTabCounter
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavIdTabCounter;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavIdTabCounter = value;
            }
        }

        public bool NavIdIsAlive
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavIdIsAlive != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavIdIsAlive = (byte) (value ? 1 : 0);
            }
        }

        public bool NavMousePosDirty
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavMousePosDirty != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavMousePosDirty = (byte) (value ? 1 : 0);
            }
        }

        public bool NavDisableHighlight
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavDisableHighlight != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavDisableHighlight = (byte) (value ? 1 : 0);
            }
        }

        public bool NavDisableMouseHover
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavDisableMouseHover != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavDisableMouseHover = (byte) (value ? 1 : 0);
            }
        }

        public bool NavAnyRequest
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavAnyRequest != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavAnyRequest = (byte) (value ? 1 : 0);
            }
        }

        public bool NavInitRequest
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavInitRequest != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavInitRequest = (byte) (value ? 1 : 0);
            }
        }

        public bool NavInitRequestFromMove
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavInitRequestFromMove != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavInitRequestFromMove = (byte) (value ? 1 : 0);
            }
        }

        public uint NavInitResultId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavInitResultId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavInitResultId = value;
            }
        }

        public global::ImGui.ImRect NavInitResultRectRel
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavInitResultRectRel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavInitResultRectRel = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public bool NavMoveFromClampedRefRect
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavMoveFromClampedRefRect != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavMoveFromClampedRefRect = (byte) (value ? 1 : 0);
            }
        }

        public bool NavMoveRequest
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavMoveRequest != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavMoveRequest = (byte) (value ? 1 : 0);
            }
        }

        public int NavMoveRequestFlags
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavMoveRequestFlags;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavMoveRequestFlags = value;
            }
        }

        public global::ImGui.ImGuiNavForward NavMoveRequestForward
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavMoveRequestForward;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavMoveRequestForward = value;
            }
        }

        public int NavMoveDir
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavMoveDir;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavMoveDir = value;
            }
        }

        public int NavMoveDirLast
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavMoveDirLast;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavMoveDirLast = value;
            }
        }

        public int NavMoveClipDir
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavMoveClipDir;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavMoveClipDir = value;
            }
        }

        public global::ImGui.ImGuiNavMoveResult NavMoveResultLocal
        {
            get
            {
                return global::ImGui.ImGuiNavMoveResult.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavMoveResultLocal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavMoveResultLocal = *(global::ImGui.ImGuiNavMoveResult.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiNavMoveResult NavMoveResultLocalVisibleSet
        {
            get
            {
                return global::ImGui.ImGuiNavMoveResult.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavMoveResultLocalVisibleSet));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavMoveResultLocalVisibleSet = *(global::ImGui.ImGuiNavMoveResult.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiNavMoveResult NavMoveResultOther
        {
            get
            {
                return global::ImGui.ImGuiNavMoveResult.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavMoveResultOther));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavMoveResultOther = *(global::ImGui.ImGuiNavMoveResult.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow NavWindowingTarget
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingTarget == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingTarget))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingTarget];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingTarget);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavWindowingTarget = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow NavWindowingTargetAnim
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingTargetAnim == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingTargetAnim))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingTargetAnim];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingTargetAnim);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavWindowingTargetAnim = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow NavWindowingList
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingList == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingList))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingList];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingList);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavWindowingList = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public float NavWindowingTimer
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingTimer;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavWindowingTimer = value;
            }
        }

        public float NavWindowingHighlightAlpha
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingHighlightAlpha;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavWindowingHighlightAlpha = value;
            }
        }

        public bool NavWindowingToggleLayer
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->NavWindowingToggleLayer != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->NavWindowingToggleLayer = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGui.ImGuiWindow FocusRequestCurrWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestCurrWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestCurrWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestCurrWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestCurrWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FocusRequestCurrWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow FocusRequestNextWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestNextWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestNextWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestNextWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestNextWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FocusRequestNextWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int FocusRequestCurrCounterRegular
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestCurrCounterRegular;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FocusRequestCurrCounterRegular = value;
            }
        }

        public int FocusRequestCurrCounterTabStop
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestCurrCounterTabStop;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FocusRequestCurrCounterTabStop = value;
            }
        }

        public int FocusRequestNextCounterRegular
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestNextCounterRegular;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FocusRequestNextCounterRegular = value;
            }
        }

        public int FocusRequestNextCounterTabStop
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusRequestNextCounterTabStop;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FocusRequestNextCounterTabStop = value;
            }
        }

        public bool FocusTabPressed
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FocusTabPressed != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FocusTabPressed = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGui.ImDrawData DrawData
        {
            get
            {
                return global::ImGui.ImDrawData.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->DrawData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DrawData = *(global::ImGui.ImDrawData.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImDrawDataBuilder DrawDataBuilder
        {
            get
            {
                return global::ImGui.ImDrawDataBuilder.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->DrawDataBuilder));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DrawDataBuilder = *(global::ImGui.ImDrawDataBuilder.__Internal*) value.__Instance;
            }
        }

        public float DimBgRatio
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DimBgRatio;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DimBgRatio = value;
            }
        }

        public global::ImGui.ImDrawList BackgroundDrawList
        {
            get
            {
                return global::ImGui.ImDrawList.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->BackgroundDrawList));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->BackgroundDrawList = *(global::ImGui.ImDrawList.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImDrawList ForegroundDrawList
        {
            get
            {
                return global::ImGui.ImDrawList.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->ForegroundDrawList));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ForegroundDrawList = *(global::ImGui.ImDrawList.__Internal*) value.__Instance;
            }
        }

        public int MouseCursor
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->MouseCursor;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->MouseCursor = value;
            }
        }

        public bool DragDropActive
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropActive != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropActive = (byte) (value ? 1 : 0);
            }
        }

        public bool DragDropWithinSourceOrTarget
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropWithinSourceOrTarget != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropWithinSourceOrTarget = (byte) (value ? 1 : 0);
            }
        }

        public int DragDropSourceFlags
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropSourceFlags;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropSourceFlags = value;
            }
        }

        public int DragDropSourceFrameCount
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropSourceFrameCount;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropSourceFrameCount = value;
            }
        }

        public int DragDropMouseButton
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropMouseButton;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropMouseButton = value;
            }
        }

        public global::ImGui.ImGuiPayload DragDropPayload
        {
            get
            {
                return global::ImGui.ImGuiPayload.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropPayload));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropPayload = *(global::ImGui.ImGuiPayload.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImRect DragDropTargetRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropTargetRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropTargetRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public uint DragDropTargetId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropTargetId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropTargetId = value;
            }
        }

        public int DragDropAcceptFlags
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropAcceptFlags;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropAcceptFlags = value;
            }
        }

        public float DragDropAcceptIdCurrRectSurface
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropAcceptIdCurrRectSurface;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropAcceptIdCurrRectSurface = value;
            }
        }

        public uint DragDropAcceptIdCurr
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropAcceptIdCurr;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropAcceptIdCurr = value;
            }
        }

        public uint DragDropAcceptIdPrev
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropAcceptIdPrev;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropAcceptIdPrev = value;
            }
        }

        public int DragDropAcceptFrameCount
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropAcceptFrameCount;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropAcceptFrameCount = value;
            }
        }

        public global::ImGui.ImVector_unsigned_char DragDropPayloadBufHeap
        {
            get
            {
                return global::ImGui.ImVector_unsigned_char.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropPayloadBufHeap));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropPayloadBufHeap = *(global::ImGui.ImVector_unsigned_char.__Internal*) value.__Instance;
            }
        }

        public byte[] DragDropPayloadBufLocal
        {
            get
            {
                byte[] __value = null;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropPayloadBufLocal != null)
                {
                    __value = new byte[16];
                    for (int i = 0; i < 16; i++)
                        __value[i] = ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragDropPayloadBufLocal[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragDropPayloadBufLocal[i] = value[i];
                }
            }
        }

        public global::ImGui.ImGuiTabBar CurrentTabBar
        {
            get
            {
                global::ImGui.ImGuiTabBar __result0;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->CurrentTabBar == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiTabBar.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiContext.__Internal*) __Instance)->CurrentTabBar))
                    __result0 = (global::ImGui.ImGuiTabBar) global::ImGui.ImGuiTabBar.NativeToManagedMap[((global::ImGui.ImGuiContext.__Internal*) __Instance)->CurrentTabBar];
                else __result0 = global::ImGui.ImGuiTabBar.__CreateInstance(((global::ImGui.ImGuiContext.__Internal*) __Instance)->CurrentTabBar);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->CurrentTabBar = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImPoolImGuiTabBar TabBars
        {
            get
            {
                return global::ImGui.ImPoolImGuiTabBar.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->TabBars));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->TabBars = *(global::ImGui.ImPoolImGuiTabBar.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiPtrOrIndex CurrentTabBarStack
        {
            get
            {
                return global::ImGui.ImVectorImGuiPtrOrIndex.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->CurrentTabBarStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->CurrentTabBarStack = *(global::ImGui.ImVectorImGuiPtrOrIndex.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiShrinkWidthItem ShrinkWidthBuffer
        {
            get
            {
                return global::ImGui.ImVectorImGuiShrinkWidthItem.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->ShrinkWidthBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ShrinkWidthBuffer = *(global::ImGui.ImVectorImGuiShrinkWidthItem.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 LastValidMousePos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->LastValidMousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LastValidMousePos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiInputTextState InputTextState
        {
            get
            {
                return global::ImGui.ImGuiInputTextState.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->InputTextState));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->InputTextState = *(global::ImGui.ImGuiInputTextState.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImFont InputTextPasswordFont
        {
            get
            {
                return global::ImGui.ImFont.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->InputTextPasswordFont));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->InputTextPasswordFont = *(global::ImGui.ImFont.__Internal*) value.__Instance;
            }
        }

        public uint TempInputTextId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->TempInputTextId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->TempInputTextId = value;
            }
        }

        public int ColorEditOptions
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ColorEditOptions;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ColorEditOptions = value;
            }
        }

        public float ColorEditLastHue
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ColorEditLastHue;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ColorEditLastHue = value;
            }
        }

        public float ColorEditLastSat
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ColorEditLastSat;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ColorEditLastSat = value;
            }
        }

        public float[] ColorEditLastColor
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->ColorEditLastColor != null)
                {
                    __value = new float[3];
                    for (int i = 0; i < 3; i++)
                        __value[i] = ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ColorEditLastColor[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ColorEditLastColor[i] = value[i];
                }
            }
        }

        public global::ImGui.ImVec4 ColorPickerRef
        {
            get
            {
                return global::ImGui.ImVec4.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->ColorPickerRef));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ColorPickerRef = *(global::ImGui.ImVec4.__Internal*) value.__Instance;
            }
        }

        public bool DragCurrentAccumDirty
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragCurrentAccumDirty != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragCurrentAccumDirty = (byte) (value ? 1 : 0);
            }
        }

        public float DragCurrentAccum
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragCurrentAccum;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragCurrentAccum = value;
            }
        }

        public float DragSpeedDefaultRatio
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DragSpeedDefaultRatio;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DragSpeedDefaultRatio = value;
            }
        }

        public float ScrollbarClickDeltaToGrabCenter
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->ScrollbarClickDeltaToGrabCenter;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->ScrollbarClickDeltaToGrabCenter = value;
            }
        }

        public int TooltipOverrideCount
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->TooltipOverrideCount;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->TooltipOverrideCount = value;
            }
        }

        public global::ImGui.ImVector_char PrivateClipboard
        {
            get
            {
                return global::ImGui.ImVector_char.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->PrivateClipboard));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->PrivateClipboard = *(global::ImGui.ImVector_char.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 PlatformImePos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->PlatformImePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->PlatformImePos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 PlatformImeLastPos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->PlatformImeLastPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->PlatformImeLastPos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool SettingsLoaded
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->SettingsLoaded != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->SettingsLoaded = (byte) (value ? 1 : 0);
            }
        }

        public float SettingsDirtyTimer
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->SettingsDirtyTimer;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->SettingsDirtyTimer = value;
            }
        }

        public global::ImGui.ImGuiTextBuffer SettingsIniData
        {
            get
            {
                return global::ImGui.ImGuiTextBuffer.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->SettingsIniData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->SettingsIniData = *(global::ImGui.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiSettingsHandler SettingsHandlers
        {
            get
            {
                return global::ImGui.ImVectorImGuiSettingsHandler.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->SettingsHandlers));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->SettingsHandlers = *(global::ImGui.ImVectorImGuiSettingsHandler.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImChunkStreamImGuiWindowSettings SettingsWindows
        {
            get
            {
                return global::ImGui.ImChunkStreamImGuiWindowSettings.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->SettingsWindows));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->SettingsWindows = *(global::ImGui.ImChunkStreamImGuiWindowSettings.__Internal*) value.__Instance;
            }
        }

        public bool LogEnabled
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->LogEnabled != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LogEnabled = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGui.ImGuiLogType LogType
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->LogType;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LogType = value;
            }
        }

        public global::System.IntPtr LogFile
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->LogFile;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LogFile = value;
            }
        }

        public global::ImGui.ImGuiTextBuffer LogBuffer
        {
            get
            {
                return global::ImGui.ImGuiTextBuffer.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiContext.__Internal*) __Instance)->LogBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LogBuffer = *(global::ImGui.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }

        public float LogLinePosY
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->LogLinePosY;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LogLinePosY = value;
            }
        }

        public bool LogLineFirstItem
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->LogLineFirstItem != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LogLineFirstItem = (byte) (value ? 1 : 0);
            }
        }

        public int LogDepthRef
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->LogDepthRef;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LogDepthRef = value;
            }
        }

        public int LogDepthToExpand
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->LogDepthToExpand;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LogDepthToExpand = value;
            }
        }

        public int LogDepthToExpandDefault
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->LogDepthToExpandDefault;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->LogDepthToExpandDefault = value;
            }
        }

        public bool DebugItemPickerActive
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DebugItemPickerActive != 0;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DebugItemPickerActive = (byte) (value ? 1 : 0);
            }
        }

        public uint DebugItemPickerBreakId
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->DebugItemPickerBreakId;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->DebugItemPickerBreakId = value;
            }
        }

        public float[] FramerateSecPerFrame
        {
            get
            {
                float[] __value = null;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->FramerateSecPerFrame != null)
                {
                    __value = new float[120];
                    for (int i = 0; i < 120; i++)
                        __value[i] = ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FramerateSecPerFrame[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 120; i++)
                        ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FramerateSecPerFrame[i] = value[i];
                }
            }
        }

        public int FramerateSecPerFrameIdx
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FramerateSecPerFrameIdx;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FramerateSecPerFrameIdx = value;
            }
        }

        public float FramerateSecPerFrameAccum
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->FramerateSecPerFrameAccum;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->FramerateSecPerFrameAccum = value;
            }
        }

        public int WantCaptureMouseNextFrame
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->WantCaptureMouseNextFrame;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WantCaptureMouseNextFrame = value;
            }
        }

        public int WantCaptureKeyboardNextFrame
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->WantCaptureKeyboardNextFrame;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WantCaptureKeyboardNextFrame = value;
            }
        }

        public int WantTextInputNextFrame
        {
            get
            {
                return ((global::ImGui.ImGuiContext.__Internal*) __Instance)->WantTextInputNextFrame;
            }

            set
            {
                ((global::ImGui.ImGuiContext.__Internal*)__Instance)->WantTextInputNextFrame = value;
            }
        }

        public sbyte[] TempBuffer
        {
            get
            {
                sbyte[] __value = null;
                if (((global::ImGui.ImGuiContext.__Internal*) __Instance)->TempBuffer != null)
                {
                    __value = new sbyte[3073];
                    for (int i = 0; i < 3073; i++)
                        __value[i] = ((global::ImGui.ImGuiContext.__Internal*) __Instance)->TempBuffer[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3073; i++)
                        ((global::ImGui.ImGuiContext.__Internal*)__Instance)->TempBuffer[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiWindowTempData : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 328)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVec2.__Internal CursorPos;

            [FieldOffset(8)]
            internal global::ImGui.ImVec2.__Internal CursorPosPrevLine;

            [FieldOffset(16)]
            internal global::ImGui.ImVec2.__Internal CursorStartPos;

            [FieldOffset(24)]
            internal global::ImGui.ImVec2.__Internal CursorMaxPos;

            [FieldOffset(32)]
            internal global::ImGui.ImVec2.__Internal CurrLineSize;

            [FieldOffset(40)]
            internal global::ImGui.ImVec2.__Internal PrevLineSize;

            [FieldOffset(48)]
            internal float CurrLineTextBaseOffset;

            [FieldOffset(52)]
            internal float PrevLineTextBaseOffset;

            [FieldOffset(56)]
            internal global::ImGui.ImVec1.__Internal Indent;

            [FieldOffset(60)]
            internal global::ImGui.ImVec1.__Internal ColumnsOffset;

            [FieldOffset(64)]
            internal global::ImGui.ImVec1.__Internal GroupOffset;

            [FieldOffset(68)]
            internal uint LastItemId;

            [FieldOffset(72)]
            internal int LastItemStatusFlags;

            [FieldOffset(76)]
            internal global::ImGui.ImRect.__Internal LastItemRect;

            [FieldOffset(92)]
            internal global::ImGui.ImRect.__Internal LastItemDisplayRect;

            [FieldOffset(108)]
            internal global::ImGui.ImGuiNavLayer NavLayerCurrent;

            [FieldOffset(112)]
            internal int NavLayerCurrentMask;

            [FieldOffset(116)]
            internal int NavLayerActiveMask;

            [FieldOffset(120)]
            internal int NavLayerActiveMaskNext;

            [FieldOffset(124)]
            internal uint NavFocusScopeIdCurrent;

            [FieldOffset(128)]
            internal byte NavHideHighlightOneFrame;

            [FieldOffset(129)]
            internal byte NavHasScroll;

            [FieldOffset(130)]
            internal byte MenuBarAppending;

            [FieldOffset(132)]
            internal global::ImGui.ImVec2.__Internal MenuBarOffset;

            [FieldOffset(140)]
            internal global::ImGui.ImGuiMenuColumns.__Internal MenuColumns;

            [FieldOffset(176)]
            internal int TreeDepth;

            [FieldOffset(180)]
            internal uint TreeJumpToParentOnPopMask;

            [FieldOffset(184)]
            internal global::ImGui.ImVectorImGuiWindowPtr.__Internal ChildWindows;

            [FieldOffset(200)]
            internal global::System.IntPtr StateStorage;

            [FieldOffset(208)]
            internal global::System.IntPtr CurrentColumns;

            [FieldOffset(216)]
            internal int LayoutType;

            [FieldOffset(220)]
            internal int ParentLayoutType;

            [FieldOffset(224)]
            internal int FocusCounterRegular;

            [FieldOffset(228)]
            internal int FocusCounterTabStop;

            [FieldOffset(232)]
            internal int ItemFlags;

            [FieldOffset(236)]
            internal float ItemWidth;

            [FieldOffset(240)]
            internal float TextWrapPos;

            [FieldOffset(248)]
            internal global::ImGui.ImVectorImGuiItemFlags.__Internal ItemFlagsStack;

            [FieldOffset(264)]
            internal global::ImGui.ImVector_float.__Internal ItemWidthStack;

            [FieldOffset(280)]
            internal global::ImGui.ImVector_float.__Internal TextWrapPosStack;

            [FieldOffset(296)]
            internal global::ImGui.ImVectorImGuiGroupData.__Internal GroupStack;

            [FieldOffset(312)]
            internal fixed short StackSizesBackup[6];

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiWindowTempData@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiWindowTempData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiWindowTempData>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiWindowTempData __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiWindowTempData(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiWindowTempData __CreateInstance(global::ImGui.ImGuiWindowTempData.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiWindowTempData(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiWindowTempData.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiWindowTempData.__Internal));
            *(global::ImGui.ImGuiWindowTempData.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindowTempData(global::ImGui.ImGuiWindowTempData.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiWindowTempData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiWindowTempData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiWindowTempData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiWindowTempData(global::ImGui.ImGuiWindowTempData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiWindowTempData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance) = *((global::ImGui.ImGuiWindowTempData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiWindowTempData __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVec2 CursorPos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->CursorPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->CursorPos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 CursorPosPrevLine
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->CursorPosPrevLine));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->CursorPosPrevLine = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 CursorStartPos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->CursorStartPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->CursorStartPos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 CursorMaxPos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->CursorMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->CursorMaxPos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 CurrLineSize
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->CurrLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->CurrLineSize = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 PrevLineSize
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->PrevLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->PrevLineSize = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float CurrLineTextBaseOffset
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->CurrLineTextBaseOffset;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->CurrLineTextBaseOffset = value;
            }
        }

        public float PrevLineTextBaseOffset
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->PrevLineTextBaseOffset;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->PrevLineTextBaseOffset = value;
            }
        }

        public global::ImGui.ImVec1 Indent
        {
            get
            {
                return global::ImGui.ImVec1.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->Indent));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->Indent = *(global::ImGui.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec1 ColumnsOffset
        {
            get
            {
                return global::ImGui.ImVec1.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->ColumnsOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->ColumnsOffset = *(global::ImGui.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec1 GroupOffset
        {
            get
            {
                return global::ImGui.ImVec1.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->GroupOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->GroupOffset = *(global::ImGui.ImVec1.__Internal*) value.__Instance;
            }
        }

        public uint LastItemId
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->LastItemId;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->LastItemId = value;
            }
        }

        public int LastItemStatusFlags
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->LastItemStatusFlags;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->LastItemStatusFlags = value;
            }
        }

        public global::ImGui.ImRect LastItemRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->LastItemRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->LastItemRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImRect LastItemDisplayRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->LastItemDisplayRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->LastItemDisplayRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiNavLayer NavLayerCurrent
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->NavLayerCurrent;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->NavLayerCurrent = value;
            }
        }

        public int NavLayerCurrentMask
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->NavLayerCurrentMask;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->NavLayerCurrentMask = value;
            }
        }

        public int NavLayerActiveMask
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->NavLayerActiveMask;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->NavLayerActiveMask = value;
            }
        }

        public int NavLayerActiveMaskNext
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->NavLayerActiveMaskNext;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->NavLayerActiveMaskNext = value;
            }
        }

        public uint NavFocusScopeIdCurrent
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->NavFocusScopeIdCurrent;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->NavFocusScopeIdCurrent = value;
            }
        }

        public bool NavHideHighlightOneFrame
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->NavHideHighlightOneFrame != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->NavHideHighlightOneFrame = (byte) (value ? 1 : 0);
            }
        }

        public bool NavHasScroll
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->NavHasScroll != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->NavHasScroll = (byte) (value ? 1 : 0);
            }
        }

        public bool MenuBarAppending
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->MenuBarAppending != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->MenuBarAppending = (byte) (value ? 1 : 0);
            }
        }

        public global::ImGui.ImVec2 MenuBarOffset
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->MenuBarOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->MenuBarOffset = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiMenuColumns MenuColumns
        {
            get
            {
                return global::ImGui.ImGuiMenuColumns.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->MenuColumns));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->MenuColumns = *(global::ImGui.ImGuiMenuColumns.__Internal*) value.__Instance;
            }
        }

        public int TreeDepth
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->TreeDepth;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->TreeDepth = value;
            }
        }

        public uint TreeJumpToParentOnPopMask
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->TreeJumpToParentOnPopMask;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->TreeJumpToParentOnPopMask = value;
            }
        }

        public global::ImGui.ImVectorImGuiWindowPtr ChildWindows
        {
            get
            {
                return global::ImGui.ImVectorImGuiWindowPtr.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->ChildWindows));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->ChildWindows = *(global::ImGui.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiStorage StateStorage
        {
            get
            {
                global::ImGui.ImGuiStorage __result0;
                if (((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->StateStorage == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiStorage.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->StateStorage))
                    __result0 = (global::ImGui.ImGuiStorage) global::ImGui.ImGuiStorage.NativeToManagedMap[((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->StateStorage];
                else __result0 = global::ImGui.ImGuiStorage.__CreateInstance(((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->StateStorage);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->StateStorage = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiColumns CurrentColumns
        {
            get
            {
                global::ImGui.ImGuiColumns __result0;
                if (((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->CurrentColumns == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiColumns.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->CurrentColumns))
                    __result0 = (global::ImGui.ImGuiColumns) global::ImGui.ImGuiColumns.NativeToManagedMap[((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->CurrentColumns];
                else __result0 = global::ImGui.ImGuiColumns.__CreateInstance(((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->CurrentColumns);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->CurrentColumns = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int LayoutType
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->LayoutType;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->LayoutType = value;
            }
        }

        public int ParentLayoutType
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->ParentLayoutType;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->ParentLayoutType = value;
            }
        }

        public int FocusCounterRegular
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->FocusCounterRegular;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->FocusCounterRegular = value;
            }
        }

        public int FocusCounterTabStop
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->FocusCounterTabStop;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->FocusCounterTabStop = value;
            }
        }

        public int ItemFlags
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->ItemFlags;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->ItemFlags = value;
            }
        }

        public float ItemWidth
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->ItemWidth;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->ItemWidth = value;
            }
        }

        public float TextWrapPos
        {
            get
            {
                return ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->TextWrapPos;
            }

            set
            {
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->TextWrapPos = value;
            }
        }

        public global::ImGui.ImVectorImGuiItemFlags ItemFlagsStack
        {
            get
            {
                return global::ImGui.ImVectorImGuiItemFlags.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->ItemFlagsStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->ItemFlagsStack = *(global::ImGui.ImVectorImGuiItemFlags.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVector_float ItemWidthStack
        {
            get
            {
                return global::ImGui.ImVector_float.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->ItemWidthStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->ItemWidthStack = *(global::ImGui.ImVector_float.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVector_float TextWrapPosStack
        {
            get
            {
                return global::ImGui.ImVector_float.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->TextWrapPosStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->TextWrapPosStack = *(global::ImGui.ImVector_float.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiGroupData GroupStack
        {
            get
            {
                return global::ImGui.ImVectorImGuiGroupData.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->GroupStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->GroupStack = *(global::ImGui.ImVectorImGuiGroupData.__Internal*) value.__Instance;
            }
        }

        public short[] StackSizesBackup
        {
            get
            {
                short[] __value = null;
                if (((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->StackSizesBackup != null)
                {
                    __value = new short[6];
                    for (int i = 0; i < 6; i++)
                        __value[i] = ((global::ImGui.ImGuiWindowTempData.__Internal*) __Instance)->StackSizesBackup[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((global::ImGui.ImGuiWindowTempData.__Internal*)__Instance)->StackSizesBackup[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiWindow : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 960)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr Name;

            [FieldOffset(8)]
            internal uint ID;

            [FieldOffset(12)]
            internal int Flags;

            [FieldOffset(16)]
            internal global::ImGui.ImVec2.__Internal Pos;

            [FieldOffset(24)]
            internal global::ImGui.ImVec2.__Internal Size;

            [FieldOffset(32)]
            internal global::ImGui.ImVec2.__Internal SizeFull;

            [FieldOffset(40)]
            internal global::ImGui.ImVec2.__Internal ContentSize;

            [FieldOffset(48)]
            internal global::ImGui.ImVec2.__Internal ContentSizeExplicit;

            [FieldOffset(56)]
            internal global::ImGui.ImVec2.__Internal WindowPadding;

            [FieldOffset(64)]
            internal float WindowRounding;

            [FieldOffset(68)]
            internal float WindowBorderSize;

            [FieldOffset(72)]
            internal int NameBufLen;

            [FieldOffset(76)]
            internal uint MoveId;

            [FieldOffset(80)]
            internal uint ChildId;

            [FieldOffset(84)]
            internal global::ImGui.ImVec2.__Internal Scroll;

            [FieldOffset(92)]
            internal global::ImGui.ImVec2.__Internal ScrollMax;

            [FieldOffset(100)]
            internal global::ImGui.ImVec2.__Internal ScrollTarget;

            [FieldOffset(108)]
            internal global::ImGui.ImVec2.__Internal ScrollTargetCenterRatio;

            [FieldOffset(116)]
            internal global::ImGui.ImVec2.__Internal ScrollbarSizes;

            [FieldOffset(124)]
            internal byte ScrollbarX;

            [FieldOffset(125)]
            internal byte ScrollbarY;

            [FieldOffset(126)]
            internal byte Active;

            [FieldOffset(127)]
            internal byte WasActive;

            [FieldOffset(128)]
            internal byte WriteAccessed;

            [FieldOffset(129)]
            internal byte Collapsed;

            [FieldOffset(130)]
            internal byte WantCollapseToggle;

            [FieldOffset(131)]
            internal byte SkipItems;

            [FieldOffset(132)]
            internal byte Appearing;

            [FieldOffset(133)]
            internal byte Hidden;

            [FieldOffset(134)]
            internal byte IsFallbackWindow;

            [FieldOffset(135)]
            internal byte HasCloseButton;

            [FieldOffset(136)]
            internal sbyte ResizeBorderHeld;

            [FieldOffset(138)]
            internal short BeginCount;

            [FieldOffset(140)]
            internal short BeginOrderWithinParent;

            [FieldOffset(142)]
            internal short BeginOrderWithinContext;

            [FieldOffset(144)]
            internal uint PopupId;

            [FieldOffset(148)]
            internal sbyte AutoFitFramesX;

            [FieldOffset(149)]
            internal sbyte AutoFitFramesY;

            [FieldOffset(150)]
            internal sbyte AutoFitChildAxises;

            [FieldOffset(151)]
            internal byte AutoFitOnlyGrows;

            [FieldOffset(152)]
            internal int AutoPosLastDirection;

            [FieldOffset(156)]
            internal int HiddenFramesCanSkipItems;

            [FieldOffset(160)]
            internal int HiddenFramesCannotSkipItems;

            [FieldOffset(164)]
            internal int SetWindowPosAllowFlags;

            [FieldOffset(168)]
            internal int SetWindowSizeAllowFlags;

            [FieldOffset(172)]
            internal int SetWindowCollapsedAllowFlags;

            [FieldOffset(176)]
            internal global::ImGui.ImVec2.__Internal SetWindowPosVal;

            [FieldOffset(184)]
            internal global::ImGui.ImVec2.__Internal SetWindowPosPivot;

            [FieldOffset(192)]
            internal global::ImGui.ImVectorImGuiID.__Internal IDStack;

            [FieldOffset(208)]
            internal global::ImGui.ImGuiWindowTempData.__Internal DC;

            [FieldOffset(536)]
            internal global::ImGui.ImRect.__Internal OuterRectClipped;

            [FieldOffset(552)]
            internal global::ImGui.ImRect.__Internal InnerRect;

            [FieldOffset(568)]
            internal global::ImGui.ImRect.__Internal InnerClipRect;

            [FieldOffset(584)]
            internal global::ImGui.ImRect.__Internal WorkRect;

            [FieldOffset(600)]
            internal global::ImGui.ImRect.__Internal ClipRect;

            [FieldOffset(616)]
            internal global::ImGui.ImRect.__Internal ContentRegionRect;

            [FieldOffset(632)]
            internal int LastFrameActive;

            [FieldOffset(636)]
            internal float LastTimeActive;

            [FieldOffset(640)]
            internal float ItemWidthDefault;

            [FieldOffset(648)]
            internal global::ImGui.ImGuiStorage.__Internal StateStorage;

            [FieldOffset(664)]
            internal global::ImGui.ImVectorImGuiColumns.__Internal ColumnsStorage;

            [FieldOffset(680)]
            internal float FontWindowScale;

            [FieldOffset(684)]
            internal int SettingsOffset;

            [FieldOffset(688)]
            internal global::System.IntPtr DrawList;

            [FieldOffset(696)]
            internal global::ImGui.ImDrawList.__Internal DrawListInst;

            [FieldOffset(864)]
            internal global::System.IntPtr ParentWindow;

            [FieldOffset(872)]
            internal global::System.IntPtr RootWindow;

            [FieldOffset(880)]
            internal global::System.IntPtr RootWindowForTitleBarHighlight;

            [FieldOffset(888)]
            internal global::System.IntPtr RootWindowForNav;

            [FieldOffset(896)]
            internal global::System.IntPtr NavLastChildNavWindow;

            [FieldOffset(904)]
            internal fixed uint NavLastIds[2];

            [FieldOffset(912)]
            internal fixed byte NavRectRel[32];

            [FieldOffset(944)]
            internal byte MemoryCompacted;

            [FieldOffset(948)]
            internal int MemoryDrawListIdxCapacity;

            [FieldOffset(952)]
            internal int MemoryDrawListVtxCapacity;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiWindow@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiWindow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiWindow>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiWindow __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiWindow(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiWindow __CreateInstance(global::ImGui.ImGuiWindow.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiWindow(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiWindow.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiWindow.__Internal));
            *(global::ImGui.ImGuiWindow.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindow(global::ImGui.ImGuiWindow.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiWindow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiWindow()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiWindow.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiWindow(global::ImGui.ImGuiWindow _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiWindow.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiWindow.__Internal*) __Instance) = *((global::ImGui.ImGuiWindow.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiWindow __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* Name
        {
            get
            {
                return (sbyte*) ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->Name;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->Name = (global::System.IntPtr) value;
            }
        }

        public uint ID
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ID;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->Flags;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->Flags = value;
            }
        }

        public global::ImGui.ImVec2 Pos
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->Pos = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 Size
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->Size));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->Size = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 SizeFull
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->SizeFull));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->SizeFull = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 ContentSize
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ContentSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ContentSize = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 ContentSizeExplicit
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ContentSizeExplicit));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ContentSizeExplicit = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 WindowPadding
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->WindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->WindowPadding = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float WindowRounding
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->WindowRounding;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->WindowRounding = value;
            }
        }

        public float WindowBorderSize
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->WindowBorderSize;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->WindowBorderSize = value;
            }
        }

        public int NameBufLen
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->NameBufLen;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->NameBufLen = value;
            }
        }

        public uint MoveId
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->MoveId;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->MoveId = value;
            }
        }

        public uint ChildId
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ChildId;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ChildId = value;
            }
        }

        public global::ImGui.ImVec2 Scroll
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->Scroll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->Scroll = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 ScrollMax
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ScrollMax));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ScrollMax = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 ScrollTarget
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ScrollTarget));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ScrollTarget = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 ScrollTargetCenterRatio
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ScrollTargetCenterRatio));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ScrollTargetCenterRatio = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 ScrollbarSizes
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ScrollbarSizes));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ScrollbarSizes = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool ScrollbarX
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ScrollbarX != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ScrollbarX = (byte) (value ? 1 : 0);
            }
        }

        public bool ScrollbarY
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ScrollbarY != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ScrollbarY = (byte) (value ? 1 : 0);
            }
        }

        public bool Active
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->Active != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->Active = (byte) (value ? 1 : 0);
            }
        }

        public bool WasActive
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->WasActive != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->WasActive = (byte) (value ? 1 : 0);
            }
        }

        public bool WriteAccessed
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->WriteAccessed != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->WriteAccessed = (byte) (value ? 1 : 0);
            }
        }

        public bool Collapsed
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->Collapsed != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->Collapsed = (byte) (value ? 1 : 0);
            }
        }

        public bool WantCollapseToggle
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->WantCollapseToggle != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->WantCollapseToggle = (byte) (value ? 1 : 0);
            }
        }

        public bool SkipItems
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->SkipItems != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->SkipItems = (byte) (value ? 1 : 0);
            }
        }

        public bool Appearing
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->Appearing != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->Appearing = (byte) (value ? 1 : 0);
            }
        }

        public bool Hidden
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->Hidden != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->Hidden = (byte) (value ? 1 : 0);
            }
        }

        public bool IsFallbackWindow
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->IsFallbackWindow != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->IsFallbackWindow = (byte) (value ? 1 : 0);
            }
        }

        public bool HasCloseButton
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->HasCloseButton != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->HasCloseButton = (byte) (value ? 1 : 0);
            }
        }

        public sbyte ResizeBorderHeld
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ResizeBorderHeld;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ResizeBorderHeld = value;
            }
        }

        public short BeginCount
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->BeginCount;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->BeginCount = value;
            }
        }

        public short BeginOrderWithinParent
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->BeginOrderWithinParent;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->BeginOrderWithinParent = value;
            }
        }

        public short BeginOrderWithinContext
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->BeginOrderWithinContext;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->BeginOrderWithinContext = value;
            }
        }

        public uint PopupId
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->PopupId;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->PopupId = value;
            }
        }

        public sbyte AutoFitFramesX
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->AutoFitFramesX;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->AutoFitFramesX = value;
            }
        }

        public sbyte AutoFitFramesY
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->AutoFitFramesY;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->AutoFitFramesY = value;
            }
        }

        public sbyte AutoFitChildAxises
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->AutoFitChildAxises;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->AutoFitChildAxises = value;
            }
        }

        public bool AutoFitOnlyGrows
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->AutoFitOnlyGrows != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->AutoFitOnlyGrows = (byte) (value ? 1 : 0);
            }
        }

        public int AutoPosLastDirection
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->AutoPosLastDirection;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->AutoPosLastDirection = value;
            }
        }

        public int HiddenFramesCanSkipItems
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->HiddenFramesCanSkipItems;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->HiddenFramesCanSkipItems = value;
            }
        }

        public int HiddenFramesCannotSkipItems
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->HiddenFramesCannotSkipItems;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->HiddenFramesCannotSkipItems = value;
            }
        }

        public int SetWindowPosAllowFlags
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->SetWindowPosAllowFlags;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->SetWindowPosAllowFlags = value;
            }
        }

        public int SetWindowSizeAllowFlags
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->SetWindowSizeAllowFlags;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->SetWindowSizeAllowFlags = value;
            }
        }

        public int SetWindowCollapsedAllowFlags
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->SetWindowCollapsedAllowFlags;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->SetWindowCollapsedAllowFlags = value;
            }
        }

        public global::ImGui.ImVec2 SetWindowPosVal
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->SetWindowPosVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->SetWindowPosVal = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVec2 SetWindowPosPivot
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->SetWindowPosPivot));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->SetWindowPosPivot = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiID IDStack
        {
            get
            {
                return global::ImGui.ImVectorImGuiID.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->IDStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->IDStack = *(global::ImGui.ImVectorImGuiID.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindowTempData DC
        {
            get
            {
                return global::ImGui.ImGuiWindowTempData.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->DC));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->DC = *(global::ImGui.ImGuiWindowTempData.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImRect OuterRectClipped
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->OuterRectClipped));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->OuterRectClipped = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImRect InnerRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->InnerRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->InnerRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImRect InnerClipRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->InnerClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->InnerClipRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImRect WorkRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->WorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->WorkRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImRect ClipRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ClipRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImRect ContentRegionRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ContentRegionRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ContentRegionRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public int LastFrameActive
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->LastFrameActive;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->LastFrameActive = value;
            }
        }

        public float LastTimeActive
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->LastTimeActive;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->LastTimeActive = value;
            }
        }

        public float ItemWidthDefault
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ItemWidthDefault;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ItemWidthDefault = value;
            }
        }

        public global::ImGui.ImGuiStorage StateStorage
        {
            get
            {
                return global::ImGui.ImGuiStorage.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->StateStorage));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->StateStorage = *(global::ImGui.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImVectorImGuiColumns ColumnsStorage
        {
            get
            {
                return global::ImGui.ImVectorImGuiColumns.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ColumnsStorage));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ColumnsStorage = *(global::ImGui.ImVectorImGuiColumns.__Internal*) value.__Instance;
            }
        }

        public float FontWindowScale
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->FontWindowScale;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->FontWindowScale = value;
            }
        }

        public int SettingsOffset
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->SettingsOffset;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->SettingsOffset = value;
            }
        }

        public global::ImGui.ImDrawList DrawList
        {
            get
            {
                global::ImGui.ImDrawList __result0;
                if (((global::ImGui.ImGuiWindow.__Internal*) __Instance)->DrawList == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImDrawList.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->DrawList))
                    __result0 = (global::ImGui.ImDrawList) global::ImGui.ImDrawList.NativeToManagedMap[((global::ImGui.ImGuiWindow.__Internal*) __Instance)->DrawList];
                else __result0 = global::ImGui.ImDrawList.__CreateInstance(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->DrawList);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->DrawList = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImDrawList DrawListInst
        {
            get
            {
                return global::ImGui.ImDrawList.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiWindow.__Internal*) __Instance)->DrawListInst));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->DrawListInst = *(global::ImGui.ImDrawList.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow ParentWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ParentWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ParentWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ParentWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->ParentWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->ParentWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow RootWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->RootWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow RootWindowForTitleBarHighlight
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindowForTitleBarHighlight == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindowForTitleBarHighlight))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindowForTitleBarHighlight];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindowForTitleBarHighlight);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->RootWindowForTitleBarHighlight = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow RootWindowForNav
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindowForNav == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindowForNav))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindowForNav];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->RootWindowForNav);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->RootWindowForNav = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public global::ImGui.ImGuiWindow NavLastChildNavWindow
        {
            get
            {
                global::ImGui.ImGuiWindow __result0;
                if (((global::ImGui.ImGuiWindow.__Internal*) __Instance)->NavLastChildNavWindow == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->NavLastChildNavWindow))
                    __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[((global::ImGui.ImGuiWindow.__Internal*) __Instance)->NavLastChildNavWindow];
                else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->NavLastChildNavWindow);
                return __result0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->NavLastChildNavWindow = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public uint[] NavLastIds
        {
            get
            {
                uint[] __value = null;
                if (((global::ImGui.ImGuiWindow.__Internal*) __Instance)->NavLastIds != null)
                {
                    __value = new uint[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->NavLastIds[i];
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->NavLastIds[i] = value[i];
                }
            }
        }

        public global::ImGui.ImRect[] NavRectRel
        {
            get
            {
                global::ImGui.ImRect[] __value = null;
                if (((global::ImGui.ImGuiWindow.__Internal*) __Instance)->NavRectRel != null)
                {
                    __value = new global::ImGui.ImRect[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::ImGui.ImRect.__CreateInstance(*((global::ImGui.ImRect.__Internal*)&(((global::ImGui.ImGuiWindow.__Internal*) __Instance)->NavRectRel[i * sizeof(global::ImGui.ImRect.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        *(global::ImGui.ImRect.__Internal*) &((global::ImGui.ImGuiWindow.__Internal*)__Instance)->NavRectRel[i * sizeof(global::ImGui.ImRect.__Internal)] = *(global::ImGui.ImRect.__Internal*)value[i].__Instance;
                }
            }
        }

        public bool MemoryCompacted
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->MemoryCompacted != 0;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->MemoryCompacted = (byte) (value ? 1 : 0);
            }
        }

        public int MemoryDrawListIdxCapacity
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->MemoryDrawListIdxCapacity;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->MemoryDrawListIdxCapacity = value;
            }
        }

        public int MemoryDrawListVtxCapacity
        {
            get
            {
                return ((global::ImGui.ImGuiWindow.__Internal*) __Instance)->MemoryDrawListVtxCapacity;
            }

            set
            {
                ((global::ImGui.ImGuiWindow.__Internal*)__Instance)->MemoryDrawListVtxCapacity = value;
            }
        }
    }

    public unsafe partial class ImGuiItemHoveredDataBackup : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint LastItemId;

            [FieldOffset(4)]
            internal int LastItemStatusFlags;

            [FieldOffset(8)]
            internal global::ImGui.ImRect.__Internal LastItemRect;

            [FieldOffset(24)]
            internal global::ImGui.ImRect.__Internal LastItemDisplayRect;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiItemHoveredDataBackup@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiItemHoveredDataBackup> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiItemHoveredDataBackup>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiItemHoveredDataBackup __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiItemHoveredDataBackup(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiItemHoveredDataBackup __CreateInstance(global::ImGui.ImGuiItemHoveredDataBackup.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiItemHoveredDataBackup(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiItemHoveredDataBackup.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiItemHoveredDataBackup.__Internal));
            *(global::ImGui.ImGuiItemHoveredDataBackup.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiItemHoveredDataBackup(global::ImGui.ImGuiItemHoveredDataBackup.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiItemHoveredDataBackup(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiItemHoveredDataBackup()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiItemHoveredDataBackup.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiItemHoveredDataBackup(global::ImGui.ImGuiItemHoveredDataBackup _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiItemHoveredDataBackup.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiItemHoveredDataBackup.__Internal*) __Instance) = *((global::ImGui.ImGuiItemHoveredDataBackup.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiItemHoveredDataBackup __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint LastItemId
        {
            get
            {
                return ((global::ImGui.ImGuiItemHoveredDataBackup.__Internal*) __Instance)->LastItemId;
            }

            set
            {
                ((global::ImGui.ImGuiItemHoveredDataBackup.__Internal*)__Instance)->LastItemId = value;
            }
        }

        public int LastItemStatusFlags
        {
            get
            {
                return ((global::ImGui.ImGuiItemHoveredDataBackup.__Internal*) __Instance)->LastItemStatusFlags;
            }

            set
            {
                ((global::ImGui.ImGuiItemHoveredDataBackup.__Internal*)__Instance)->LastItemStatusFlags = value;
            }
        }

        public global::ImGui.ImRect LastItemRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiItemHoveredDataBackup.__Internal*) __Instance)->LastItemRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiItemHoveredDataBackup.__Internal*)__Instance)->LastItemRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImRect LastItemDisplayRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiItemHoveredDataBackup.__Internal*) __Instance)->LastItemDisplayRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiItemHoveredDataBackup.__Internal*)__Instance)->LastItemDisplayRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiTabItem : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint ID;

            [FieldOffset(4)]
            internal int Flags;

            [FieldOffset(8)]
            internal int LastFrameVisible;

            [FieldOffset(12)]
            internal int LastFrameSelected;

            [FieldOffset(16)]
            internal int NameOffset;

            [FieldOffset(20)]
            internal float Offset;

            [FieldOffset(24)]
            internal float Width;

            [FieldOffset(28)]
            internal float ContentWidth;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiTabItem@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiTabItem> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiTabItem>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiTabItem __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiTabItem(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiTabItem __CreateInstance(global::ImGui.ImGuiTabItem.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiTabItem(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiTabItem.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTabItem.__Internal));
            *(global::ImGui.ImGuiTabItem.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTabItem(global::ImGui.ImGuiTabItem.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiTabItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiTabItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTabItem(global::ImGui.ImGuiTabItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiTabItem.__Internal*) __Instance) = *((global::ImGui.ImGuiTabItem.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiTabItem __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((global::ImGui.ImGuiTabItem.__Internal*) __Instance)->ID;
            }

            set
            {
                ((global::ImGui.ImGuiTabItem.__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((global::ImGui.ImGuiTabItem.__Internal*) __Instance)->Flags;
            }

            set
            {
                ((global::ImGui.ImGuiTabItem.__Internal*)__Instance)->Flags = value;
            }
        }

        public int LastFrameVisible
        {
            get
            {
                return ((global::ImGui.ImGuiTabItem.__Internal*) __Instance)->LastFrameVisible;
            }

            set
            {
                ((global::ImGui.ImGuiTabItem.__Internal*)__Instance)->LastFrameVisible = value;
            }
        }

        public int LastFrameSelected
        {
            get
            {
                return ((global::ImGui.ImGuiTabItem.__Internal*) __Instance)->LastFrameSelected;
            }

            set
            {
                ((global::ImGui.ImGuiTabItem.__Internal*)__Instance)->LastFrameSelected = value;
            }
        }

        public int NameOffset
        {
            get
            {
                return ((global::ImGui.ImGuiTabItem.__Internal*) __Instance)->NameOffset;
            }

            set
            {
                ((global::ImGui.ImGuiTabItem.__Internal*)__Instance)->NameOffset = value;
            }
        }

        public float Offset
        {
            get
            {
                return ((global::ImGui.ImGuiTabItem.__Internal*) __Instance)->Offset;
            }

            set
            {
                ((global::ImGui.ImGuiTabItem.__Internal*)__Instance)->Offset = value;
            }
        }

        public float Width
        {
            get
            {
                return ((global::ImGui.ImGuiTabItem.__Internal*) __Instance)->Width;
            }

            set
            {
                ((global::ImGui.ImGuiTabItem.__Internal*)__Instance)->Width = value;
            }
        }

        public float ContentWidth
        {
            get
            {
                return ((global::ImGui.ImGuiTabItem.__Internal*) __Instance)->ContentWidth;
            }

            set
            {
                ((global::ImGui.ImGuiTabItem.__Internal*)__Instance)->ContentWidth = value;
            }
        }
    }

    public unsafe partial class ImGuiTabBar : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 128)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ImGui.ImVectorImGuiTabItem.__Internal Tabs;

            [FieldOffset(16)]
            internal uint ID;

            [FieldOffset(20)]
            internal uint SelectedTabId;

            [FieldOffset(24)]
            internal uint NextSelectedTabId;

            [FieldOffset(28)]
            internal uint VisibleTabId;

            [FieldOffset(32)]
            internal int CurrFrameVisible;

            [FieldOffset(36)]
            internal int PrevFrameVisible;

            [FieldOffset(40)]
            internal global::ImGui.ImRect.__Internal BarRect;

            [FieldOffset(56)]
            internal float LastTabContentHeight;

            [FieldOffset(60)]
            internal float OffsetMax;

            [FieldOffset(64)]
            internal float OffsetMaxIdeal;

            [FieldOffset(68)]
            internal float OffsetNextTab;

            [FieldOffset(72)]
            internal float ScrollingAnim;

            [FieldOffset(76)]
            internal float ScrollingTarget;

            [FieldOffset(80)]
            internal float ScrollingTargetDistToVisibility;

            [FieldOffset(84)]
            internal float ScrollingSpeed;

            [FieldOffset(88)]
            internal int Flags;

            [FieldOffset(92)]
            internal uint ReorderRequestTabId;

            [FieldOffset(96)]
            internal sbyte ReorderRequestDir;

            [FieldOffset(97)]
            internal byte WantLayout;

            [FieldOffset(98)]
            internal byte VisibleTabWasSubmitted;

            [FieldOffset(100)]
            internal short LastTabItemIdx;

            [FieldOffset(104)]
            internal global::ImGui.ImVec2.__Internal FramePadding;

            [FieldOffset(112)]
            internal global::ImGui.ImGuiTextBuffer.__Internal TabsNames;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiTabBar@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiTabBar> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiTabBar>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiTabBar __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiTabBar(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiTabBar __CreateInstance(global::ImGui.ImGuiTabBar.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiTabBar(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiTabBar.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTabBar.__Internal));
            *(global::ImGui.ImGuiTabBar.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTabBar(global::ImGui.ImGuiTabBar.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiTabBar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiTabBar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTabBar(global::ImGui.ImGuiTabBar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiTabBar.__Internal*) __Instance) = *((global::ImGui.ImGuiTabBar.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiTabBar __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::ImGui.ImVectorImGuiTabItem Tabs
        {
            get
            {
                return global::ImGui.ImVectorImGuiTabItem.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->Tabs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->Tabs = *(global::ImGui.ImVectorImGuiTabItem.__Internal*) value.__Instance;
            }
        }

        public uint ID
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->ID;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->ID = value;
            }
        }

        public uint SelectedTabId
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->SelectedTabId;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->SelectedTabId = value;
            }
        }

        public uint NextSelectedTabId
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->NextSelectedTabId;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->NextSelectedTabId = value;
            }
        }

        public uint VisibleTabId
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->VisibleTabId;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->VisibleTabId = value;
            }
        }

        public int CurrFrameVisible
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->CurrFrameVisible;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->CurrFrameVisible = value;
            }
        }

        public int PrevFrameVisible
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->PrevFrameVisible;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->PrevFrameVisible = value;
            }
        }

        public global::ImGui.ImRect BarRect
        {
            get
            {
                return global::ImGui.ImRect.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->BarRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->BarRect = *(global::ImGui.ImRect.__Internal*) value.__Instance;
            }
        }

        public float LastTabContentHeight
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->LastTabContentHeight;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->LastTabContentHeight = value;
            }
        }

        public float OffsetMax
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->OffsetMax;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->OffsetMax = value;
            }
        }

        public float OffsetMaxIdeal
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->OffsetMaxIdeal;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->OffsetMaxIdeal = value;
            }
        }

        public float OffsetNextTab
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->OffsetNextTab;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->OffsetNextTab = value;
            }
        }

        public float ScrollingAnim
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->ScrollingAnim;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->ScrollingAnim = value;
            }
        }

        public float ScrollingTarget
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->ScrollingTarget;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->ScrollingTarget = value;
            }
        }

        public float ScrollingTargetDistToVisibility
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->ScrollingTargetDistToVisibility;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->ScrollingTargetDistToVisibility = value;
            }
        }

        public float ScrollingSpeed
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->ScrollingSpeed;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->ScrollingSpeed = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->Flags;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->Flags = value;
            }
        }

        public uint ReorderRequestTabId
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->ReorderRequestTabId;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->ReorderRequestTabId = value;
            }
        }

        public sbyte ReorderRequestDir
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->ReorderRequestDir;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->ReorderRequestDir = value;
            }
        }

        public bool WantLayout
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->WantLayout != 0;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->WantLayout = (byte) (value ? 1 : 0);
            }
        }

        public bool VisibleTabWasSubmitted
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->VisibleTabWasSubmitted != 0;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->VisibleTabWasSubmitted = (byte) (value ? 1 : 0);
            }
        }

        public short LastTabItemIdx
        {
            get
            {
                return ((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->LastTabItemIdx;
            }

            set
            {
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->LastTabItemIdx = value;
            }
        }

        public global::ImGui.ImVec2 FramePadding
        {
            get
            {
                return global::ImGui.ImVec2.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->FramePadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->FramePadding = *(global::ImGui.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::ImGui.ImGuiTextBuffer TabsNames
        {
            get
            {
                return global::ImGui.ImGuiTextBuffer.__CreateInstance(new global::System.IntPtr(&((global::ImGui.ImGuiTabBar.__Internal*) __Instance)->TabsNames));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((global::ImGui.ImGuiTabBar.__Internal*)__Instance)->TabsNames = *(global::ImGui.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiTextRange : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::System.IntPtr b;

            [FieldOffset(8)]
            internal global::System.IntPtr e;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiTextRange@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiTextRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiTextRange>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiTextRange __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiTextRange(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiTextRange __CreateInstance(global::ImGui.ImGuiTextRange.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiTextRange(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiTextRange.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTextRange.__Internal));
            *(global::ImGui.ImGuiTextRange.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextRange(global::ImGui.ImGuiTextRange.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiTextRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiTextRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTextRange(global::ImGui.ImGuiTextRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiTextRange.__Internal*) __Instance) = *((global::ImGui.ImGuiTextRange.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiTextRange __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string B
        {
            get
            {
                if (((global::ImGui.ImGuiTextRange.__Internal*) __Instance)->b == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::ImGui.ImGuiTextRange.__Internal*) __Instance)->b;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::ImGui.ImGuiTextRange.__Internal*) __Instance)->b, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::ImGui.ImGuiTextRange.__Internal*)__Instance)->b = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string E
        {
            get
            {
                if (((global::ImGui.ImGuiTextRange.__Internal*) __Instance)->e == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) ((global::ImGui.ImGuiTextRange.__Internal*) __Instance)->e;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::ImGui.ImGuiTextRange.__Internal*) __Instance)->e, __length);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((global::ImGui.ImGuiTextRange.__Internal*)__Instance)->e = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class ImGuiStoragePair : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint key;

            [FieldOffset(8)]
            internal int val_i;

            [FieldOffset(8)]
            internal float val_f;

            [FieldOffset(8)]
            internal global::System.IntPtr val_p;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0ImGuiStoragePair@@QEAA@AEBU0@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiStoragePair> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ImGuiStoragePair>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ImGuiStoragePair __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiStoragePair(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ImGuiStoragePair __CreateInstance(global::ImGui.ImGuiStoragePair.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ImGuiStoragePair(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ImGuiStoragePair.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStoragePair.__Internal));
            *(global::ImGui.ImGuiStoragePair.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStoragePair(global::ImGui.ImGuiStoragePair.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiStoragePair(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public ImGuiStoragePair()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiStoragePair(global::ImGui.ImGuiStoragePair _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ImGui.ImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::ImGui.ImGuiStoragePair.__Internal*) __Instance) = *((global::ImGui.ImGuiStoragePair.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::ImGui.ImGuiStoragePair __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Key
        {
            get
            {
                return ((global::ImGui.ImGuiStoragePair.__Internal*) __Instance)->key;
            }

            set
            {
                ((global::ImGui.ImGuiStoragePair.__Internal*)__Instance)->key = value;
            }
        }

        public int ValI
        {
            get
            {
                return ((global::ImGui.ImGuiStoragePair.__Internal*) __Instance)->val_i;
            }

            set
            {
                ((global::ImGui.ImGuiStoragePair.__Internal*)__Instance)->val_i = value;
            }
        }

        public float ValF
        {
            get
            {
                return ((global::ImGui.ImGuiStoragePair.__Internal*) __Instance)->val_f;
            }

            set
            {
                ((global::ImGui.ImGuiStoragePair.__Internal*)__Instance)->val_f = value;
            }
        }

        public global::System.IntPtr ValP
        {
            get
            {
                return ((global::ImGui.ImGuiStoragePair.__Internal*) __Instance)->val_p;
            }

            set
            {
                ((global::ImGui.ImGuiStoragePair.__Internal*)__Instance)->val_p = (global::System.IntPtr) value;
            }
        }
    }

    public unsafe partial class cimgui
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec2_ImVec2Nil")]
            internal static extern global::System.IntPtr ImVec2ImVec2Nil();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec2_destroy")]
            internal static extern void ImVec2_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec2_ImVec2Float")]
            internal static extern global::System.IntPtr ImVec2ImVec2Float(float _x, float _y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec4_ImVec4Nil")]
            internal static extern global::System.IntPtr ImVec4ImVec4Nil();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec4_destroy")]
            internal static extern void ImVec4_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec4_ImVec4Float")]
            internal static extern global::System.IntPtr ImVec4ImVec4Float(float _x, float _y, float _z, float _w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCreateContext")]
            internal static extern global::System.IntPtr CreateContext(global::System.IntPtr shared_font_atlas);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDestroyContext")]
            internal static extern void DestroyContext(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetCurrentContext")]
            internal static extern global::System.IntPtr GetCurrentContext();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetCurrentContext")]
            internal static extern void SetCurrentContext(global::System.IntPtr ctx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDebugCheckVersionAndDataLayout")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DebugCheckVersionAndDataLayout([MarshalAs(UnmanagedType.LPUTF8Str)] string version_str, ulong sz_io, ulong sz_style, ulong sz_vec2, ulong sz_vec4, ulong sz_drawvert, ulong sz_drawidx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetIO")]
            internal static extern global::System.IntPtr GetIO();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetStyle")]
            internal static extern global::System.IntPtr GetStyle();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igNewFrame")]
            internal static extern void NewFrame();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndFrame")]
            internal static extern void EndFrame();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRender")]
            internal static extern void Render();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetDrawData")]
            internal static extern global::System.IntPtr GetDrawData();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igShowDemoWindow")]
            internal static extern void ShowDemoWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igShowAboutWindow")]
            internal static extern void ShowAboutWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igShowMetricsWindow")]
            internal static extern void ShowMetricsWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igShowStyleEditor")]
            internal static extern void ShowStyleEditor(global::System.IntPtr @ref);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igShowStyleSelector")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ShowStyleSelector([MarshalAs(UnmanagedType.LPUTF8Str)] string label);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igShowFontSelector")]
            internal static extern void ShowFontSelector([MarshalAs(UnmanagedType.LPUTF8Str)] string label);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igShowUserGuide")]
            internal static extern void ShowUserGuide();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetVersion")]
            internal static extern global::System.IntPtr GetVersion();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igStyleColorsDark")]
            internal static extern void StyleColorsDark(global::System.IntPtr dst);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igStyleColorsClassic")]
            internal static extern void StyleColorsClassic(global::System.IntPtr dst);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igStyleColorsLight")]
            internal static extern void StyleColorsLight(global::System.IntPtr dst);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBegin")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Begin([MarshalAs(UnmanagedType.LPUTF8Str)] string name, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEnd")]
            internal static extern void End();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginChildStr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginChildStr([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, global::ImGui.ImVec2.__Internal size, bool border, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginChildID")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginChildID(uint id, global::ImGui.ImVec2.__Internal size, bool border, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndChild")]
            internal static extern void EndChild();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsWindowAppearing")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsWindowAppearing();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsWindowCollapsed")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsWindowCollapsed();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsWindowFocused")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsWindowFocused(int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsWindowHovered")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsWindowHovered(int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetWindowDrawList")]
            internal static extern global::System.IntPtr GetWindowDrawList();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetWindowPos")]
            internal static extern void GetWindowPos(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetWindowSize")]
            internal static extern void GetWindowSize(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetWindowWidth")]
            internal static extern float GetWindowWidth();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetWindowHeight")]
            internal static extern float GetWindowHeight();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetNextWindowPos")]
            internal static extern void SetNextWindowPos(global::ImGui.ImVec2.__Internal pos, int cond, global::ImGui.ImVec2.__Internal pivot);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetNextWindowSize")]
            internal static extern void SetNextWindowSize(global::ImGui.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetNextWindowSizeConstraints")]
            internal static extern void SetNextWindowSizeConstraints(global::ImGui.ImVec2.__Internal size_min, global::ImGui.ImVec2.__Internal size_max, global::System.IntPtr custom_callback, global::System.IntPtr custom_callback_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetNextWindowContentSize")]
            internal static extern void SetNextWindowContentSize(global::ImGui.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetNextWindowCollapsed")]
            internal static extern void SetNextWindowCollapsed(bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetNextWindowFocus")]
            internal static extern void SetNextWindowFocus();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetNextWindowBgAlpha")]
            internal static extern void SetNextWindowBgAlpha(float alpha);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowPosVec2")]
            internal static extern void SetWindowPosVec2(global::ImGui.ImVec2.__Internal pos, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowSizeVec2")]
            internal static extern void SetWindowSizeVec2(global::ImGui.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowCollapsedBool")]
            internal static extern void SetWindowCollapsedBool(bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowFocusNil")]
            internal static extern void SetWindowFocusNil();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowFontScale")]
            internal static extern void SetWindowFontScale(float scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowPosStr")]
            internal static extern void SetWindowPosStr([MarshalAs(UnmanagedType.LPUTF8Str)] string name, global::ImGui.ImVec2.__Internal pos, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowSizeStr")]
            internal static extern void SetWindowSizeStr([MarshalAs(UnmanagedType.LPUTF8Str)] string name, global::ImGui.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowCollapsedStr")]
            internal static extern void SetWindowCollapsedStr([MarshalAs(UnmanagedType.LPUTF8Str)] string name, bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowFocusStr")]
            internal static extern void SetWindowFocusStr([MarshalAs(UnmanagedType.LPUTF8Str)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetContentRegionMax")]
            internal static extern void GetContentRegionMax(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetContentRegionAvail")]
            internal static extern void GetContentRegionAvail(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetWindowContentRegionMin")]
            internal static extern void GetWindowContentRegionMin(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetWindowContentRegionMax")]
            internal static extern void GetWindowContentRegionMax(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetWindowContentRegionWidth")]
            internal static extern float GetWindowContentRegionWidth();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetScrollX")]
            internal static extern float GetScrollX();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetScrollY")]
            internal static extern float GetScrollY();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetScrollMaxX")]
            internal static extern float GetScrollMaxX();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetScrollMaxY")]
            internal static extern float GetScrollMaxY();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetScrollXFloat")]
            internal static extern void SetScrollXFloat(float scroll_x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetScrollYFloat")]
            internal static extern void SetScrollYFloat(float scroll_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetScrollHereX")]
            internal static extern void SetScrollHereX(float center_x_ratio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetScrollHereY")]
            internal static extern void SetScrollHereY(float center_y_ratio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetScrollFromPosXFloat")]
            internal static extern void SetScrollFromPosXFloat(float local_x, float center_x_ratio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetScrollFromPosYFloat")]
            internal static extern void SetScrollFromPosYFloat(float local_y, float center_y_ratio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushFont")]
            internal static extern void PushFont(global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopFont")]
            internal static extern void PopFont();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushStyleColorU32")]
            internal static extern void PushStyleColorU32(int idx, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushStyleColorVec4")]
            internal static extern void PushStyleColorVec4(int idx, global::System.IntPtr col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopStyleColor")]
            internal static extern void PopStyleColor(int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushStyleVarFloat")]
            internal static extern void PushStyleVarFloat(int idx, float val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushStyleVarVec2")]
            internal static extern void PushStyleVarVec2(int idx, global::ImGui.ImVec2.__Internal val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopStyleVar")]
            internal static extern void PopStyleVar(int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetStyleColorVec4")]
            internal static extern global::System.IntPtr GetStyleColorVec4(int idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetFont")]
            internal static extern global::System.IntPtr GetFont();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetFontSize")]
            internal static extern float GetFontSize();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetFontTexUvWhitePixel")]
            internal static extern void GetFontTexUvWhitePixel(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetColorU32Col")]
            internal static extern uint GetColorU32Col(int idx, float alpha_mul);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetColorU32Vec4")]
            internal static extern uint GetColorU32Vec4(global::System.IntPtr col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetColorU32U32")]
            internal static extern uint GetColorU32U32(uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushItemWidth")]
            internal static extern void PushItemWidth(float item_width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopItemWidth")]
            internal static extern void PopItemWidth();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetNextItemWidth")]
            internal static extern void SetNextItemWidth(float item_width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCalcItemWidth")]
            internal static extern float CalcItemWidth();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushTextWrapPos")]
            internal static extern void PushTextWrapPos(float wrap_local_pos_x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopTextWrapPos")]
            internal static extern void PopTextWrapPos();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushAllowKeyboardFocus")]
            internal static extern void PushAllowKeyboardFocus(bool allow_keyboard_focus);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopAllowKeyboardFocus")]
            internal static extern void PopAllowKeyboardFocus();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushButtonRepeat")]
            internal static extern void PushButtonRepeat(bool repeat);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopButtonRepeat")]
            internal static extern void PopButtonRepeat();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSeparator")]
            internal static extern void Separator();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSameLine")]
            internal static extern void SameLine(float offset_from_start_x, float spacing);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igNewLine")]
            internal static extern void NewLine();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSpacing")]
            internal static extern void Spacing();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDummy")]
            internal static extern void Dummy(global::ImGui.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIndent")]
            internal static extern void Indent(float indent_w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igUnindent")]
            internal static extern void Unindent(float indent_w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginGroup")]
            internal static extern void BeginGroup();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndGroup")]
            internal static extern void EndGroup();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetCursorPos")]
            internal static extern void GetCursorPos(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetCursorPosX")]
            internal static extern float GetCursorPosX();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetCursorPosY")]
            internal static extern float GetCursorPosY();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetCursorPos")]
            internal static extern void SetCursorPos(global::ImGui.ImVec2.__Internal local_pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetCursorPosX")]
            internal static extern void SetCursorPosX(float local_x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetCursorPosY")]
            internal static extern void SetCursorPosY(float local_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetCursorStartPos")]
            internal static extern void GetCursorStartPos(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetCursorScreenPos")]
            internal static extern void GetCursorScreenPos(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetCursorScreenPos")]
            internal static extern void SetCursorScreenPos(global::ImGui.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igAlignTextToFramePadding")]
            internal static extern void AlignTextToFramePadding();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetTextLineHeight")]
            internal static extern float GetTextLineHeight();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetTextLineHeightWithSpacing")]
            internal static extern float GetTextLineHeightWithSpacing();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetFrameHeight")]
            internal static extern float GetFrameHeight();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetFrameHeightWithSpacing")]
            internal static extern float GetFrameHeightWithSpacing();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushIDStr")]
            internal static extern void PushIDStr([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushIDStrStr")]
            internal static extern void PushIDStrStr([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id_begin, [MarshalAs(UnmanagedType.LPUTF8Str)] string str_id_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushIDPtr")]
            internal static extern void PushIDPtr(global::System.IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushIDInt")]
            internal static extern void PushIDInt(int int_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopID")]
            internal static extern void PopID();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetIDStr")]
            internal static extern uint GetIDStr([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetIDStrStr")]
            internal static extern uint GetIDStrStr([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id_begin, [MarshalAs(UnmanagedType.LPUTF8Str)] string str_id_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetIDPtr")]
            internal static extern uint GetIDPtr(global::System.IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTextUnformatted")]
            internal static extern void TextUnformatted([MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igText")]
            internal static extern void Text([MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTextColored")]
            internal static extern void TextColored(global::System.IntPtr col, [MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTextDisabled")]
            internal static extern void TextDisabled([MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTextWrapped")]
            internal static extern void TextWrapped([MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLabelText")]
            internal static extern void LabelText([MarshalAs(UnmanagedType.LPUTF8Str)] string label, [MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBulletText")]
            internal static extern void BulletText([MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Button([MarshalAs(UnmanagedType.LPUTF8Str)] string label, global::ImGui.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSmallButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SmallButton([MarshalAs(UnmanagedType.LPUTF8Str)] string label);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInvisibleButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InvisibleButton([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, global::ImGui.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igArrowButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ArrowButton([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, int dir);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImage")]
            internal static extern void Image(global::System.IntPtr user_texture_id, global::ImGui.ImVec2.__Internal size, global::ImGui.ImVec2.__Internal uv0, global::ImGui.ImVec2.__Internal uv1, global::System.IntPtr tint_col, global::System.IntPtr border_col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImageButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImageButton(global::System.IntPtr user_texture_id, global::ImGui.ImVec2.__Internal size, global::ImGui.ImVec2.__Internal uv0, global::ImGui.ImVec2.__Internal uv1, int frame_padding, global::System.IntPtr bg_col, global::System.IntPtr tint_col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCheckbox")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Checkbox([MarshalAs(UnmanagedType.LPUTF8Str)] string label, bool* v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCheckboxFlags")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CheckboxFlags([MarshalAs(UnmanagedType.LPUTF8Str)] string label, uint* flags, uint flags_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRadioButtonBool")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RadioButtonBool([MarshalAs(UnmanagedType.LPUTF8Str)] string label, bool active);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRadioButtonIntPtr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RadioButtonIntPtr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int* v, int v_button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igProgressBar")]
            internal static extern void ProgressBar(float fraction, global::ImGui.ImVec2.__Internal size_arg, [MarshalAs(UnmanagedType.LPUTF8Str)] string overlay);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBullet")]
            internal static extern void Bullet();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginCombo")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginCombo([MarshalAs(UnmanagedType.LPUTF8Str)] string label, [MarshalAs(UnmanagedType.LPUTF8Str)] string preview_value, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndCombo")]
            internal static extern void EndCombo();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igComboStr_arr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ComboStr_arr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int* current_item, [MarshalAs(UnmanagedType.LPArray)] string[] items, int items_count, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igComboStr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ComboStr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int* current_item, [MarshalAs(UnmanagedType.LPUTF8Str)] string items_separated_by_zeros, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igComboFnPtr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ComboFnPtr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int* current_item, global::System.IntPtr items_getter, global::System.IntPtr data, int items_count, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragFloat")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragFloat([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float* v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragFloat2")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragFloat2([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragFloat3")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragFloat3([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragFloat4")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragFloat4([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragFloatRange2")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragFloatRange2([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, [MarshalAs(UnmanagedType.LPUTF8Str)] string format_max, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragInt")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragInt([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int* v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragInt2")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragInt2([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragInt3")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragInt3([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragInt4")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragInt4([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragIntRange2")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragIntRange2([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, [MarshalAs(UnmanagedType.LPUTF8Str)] string format_max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragScalar")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragScalar([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int data_type, global::System.IntPtr p_data, float v_speed, global::System.IntPtr p_min, global::System.IntPtr p_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragScalarN")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragScalarN([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int data_type, global::System.IntPtr p_data, int components, float v_speed, global::System.IntPtr p_min, global::System.IntPtr p_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderFloat")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderFloat([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float* v, float v_min, float v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderFloat2")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderFloat2([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderFloat3")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderFloat3([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderFloat4")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderFloat4([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderAngle")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderAngle([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float* v_rad, float v_degrees_min, float v_degrees_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderInt")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderInt([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int* v, int v_min, int v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderInt2")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderInt2([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderInt3")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderInt3([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderInt4")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderInt4([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderScalar")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderScalar([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int data_type, global::System.IntPtr p_data, global::System.IntPtr p_min, global::System.IntPtr p_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderScalarN")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderScalarN([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int data_type, global::System.IntPtr p_data, int components, global::System.IntPtr p_min, global::System.IntPtr p_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igVSliderFloat")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool VSliderFloat([MarshalAs(UnmanagedType.LPUTF8Str)] string label, global::ImGui.ImVec2.__Internal size, float* v, float v_min, float v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igVSliderInt")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool VSliderInt([MarshalAs(UnmanagedType.LPUTF8Str)] string label, global::ImGui.ImVec2.__Internal size, int* v, int v_min, int v_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igVSliderScalar")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool VSliderScalar([MarshalAs(UnmanagedType.LPUTF8Str)] string label, global::ImGui.ImVec2.__Internal size, int data_type, global::System.IntPtr p_data, global::System.IntPtr p_min, global::System.IntPtr p_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputText")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputText([MarshalAs(UnmanagedType.LPUTF8Str)] string label, sbyte* buf, ulong buf_size, int flags, global::System.IntPtr callback, global::System.IntPtr user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputTextMultiline")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputTextMultiline([MarshalAs(UnmanagedType.LPUTF8Str)] string label, sbyte* buf, ulong buf_size, global::ImGui.ImVec2.__Internal size, int flags, global::System.IntPtr callback, global::System.IntPtr user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputTextWithHint")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputTextWithHint([MarshalAs(UnmanagedType.LPUTF8Str)] string label, [MarshalAs(UnmanagedType.LPUTF8Str)] string hint, sbyte* buf, ulong buf_size, int flags, global::System.IntPtr callback, global::System.IntPtr user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputFloat")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputFloat([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float* v, float step, float step_fast, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputFloat2")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputFloat2([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] v, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputFloat3")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputFloat3([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] v, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputFloat4")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputFloat4([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] v, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputInt")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputInt([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int* v, int step, int step_fast, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputInt2")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputInt2([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputInt3")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputInt3([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputInt4")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputInt4([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputDouble")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputDouble([MarshalAs(UnmanagedType.LPUTF8Str)] string label, double* v, double step, double step_fast, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputScalar")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputScalar([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int data_type, global::System.IntPtr p_data, global::System.IntPtr p_step, global::System.IntPtr p_step_fast, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputScalarN")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputScalarN([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int data_type, global::System.IntPtr p_data, int components, global::System.IntPtr p_step, global::System.IntPtr p_step_fast, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorEdit3")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ColorEdit3([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorEdit4")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ColorEdit4([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorPicker3")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ColorPicker3([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorPicker4")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ColorPicker4([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float[] col, int flags, float* ref_col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ColorButton([MarshalAs(UnmanagedType.LPUTF8Str)] string desc_id, global::System.IntPtr col, int flags, global::ImGui.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetColorEditOptions")]
            internal static extern void SetColorEditOptions(int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreeNodeStr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TreeNodeStr([MarshalAs(UnmanagedType.LPUTF8Str)] string label);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreeNodeStrStr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TreeNodeStrStr([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, [MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreeNodePtr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TreeNodePtr(global::System.IntPtr ptr_id, [MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreeNodeExStr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TreeNodeExStr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreeNodeExStrStr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TreeNodeExStrStr([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, int flags, [MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreeNodeExPtr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TreeNodeExPtr(global::System.IntPtr ptr_id, int flags, [MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreePushStr")]
            internal static extern void TreePushStr([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreePushPtr")]
            internal static extern void TreePushPtr(global::System.IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreePop")]
            internal static extern void TreePop();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetTreeNodeToLabelSpacing")]
            internal static extern float GetTreeNodeToLabelSpacing();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCollapsingHeaderTreeNodeFlags")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CollapsingHeaderTreeNodeFlags([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCollapsingHeaderBoolPtr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CollapsingHeaderBoolPtr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetNextItemOpen")]
            internal static extern void SetNextItemOpen(bool is_open, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSelectableBool")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SelectableBool([MarshalAs(UnmanagedType.LPUTF8Str)] string label, bool selected, int flags, global::ImGui.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSelectableBoolPtr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SelectableBoolPtr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, bool* p_selected, int flags, global::ImGui.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igListBoxStr_arr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ListBoxStr_arr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int* current_item, [MarshalAs(UnmanagedType.LPArray)] string[] items, int items_count, int height_in_items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igListBoxFnPtr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ListBoxFnPtr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int* current_item, global::System.IntPtr items_getter, global::System.IntPtr data, int items_count, int height_in_items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igListBoxHeaderVec2")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ListBoxHeaderVec2([MarshalAs(UnmanagedType.LPUTF8Str)] string label, global::ImGui.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igListBoxHeaderInt")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ListBoxHeaderInt([MarshalAs(UnmanagedType.LPUTF8Str)] string label, int items_count, int height_in_items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igListBoxFooter")]
            internal static extern void ListBoxFooter();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPlotLinesFloatPtr")]
            internal static extern void PlotLinesFloatPtr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float* values, int values_count, int values_offset, [MarshalAs(UnmanagedType.LPUTF8Str)] string overlay_text, float scale_min, float scale_max, global::ImGui.ImVec2.__Internal graph_size, int stride);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPlotLinesFnPtr")]
            internal static extern void PlotLinesFnPtr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, global::System.IntPtr values_getter, global::System.IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.LPUTF8Str)] string overlay_text, float scale_min, float scale_max, global::ImGui.ImVec2.__Internal graph_size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPlotHistogramFloatPtr")]
            internal static extern void PlotHistogramFloatPtr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, float* values, int values_count, int values_offset, [MarshalAs(UnmanagedType.LPUTF8Str)] string overlay_text, float scale_min, float scale_max, global::ImGui.ImVec2.__Internal graph_size, int stride);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPlotHistogramFnPtr")]
            internal static extern void PlotHistogramFnPtr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, global::System.IntPtr values_getter, global::System.IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.LPUTF8Str)] string overlay_text, float scale_min, float scale_max, global::ImGui.ImVec2.__Internal graph_size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igValueBool")]
            internal static extern void ValueBool([MarshalAs(UnmanagedType.LPUTF8Str)] string prefix, bool b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igValueInt")]
            internal static extern void ValueInt([MarshalAs(UnmanagedType.LPUTF8Str)] string prefix, int v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igValueUint")]
            internal static extern void ValueUint([MarshalAs(UnmanagedType.LPUTF8Str)] string prefix, uint v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igValueFloat")]
            internal static extern void ValueFloat([MarshalAs(UnmanagedType.LPUTF8Str)] string prefix, float v, [MarshalAs(UnmanagedType.LPUTF8Str)] string float_format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginMenuBar")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginMenuBar();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndMenuBar")]
            internal static extern void EndMenuBar();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginMainMenuBar")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginMainMenuBar();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndMainMenuBar")]
            internal static extern void EndMainMenuBar();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginMenu")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginMenu([MarshalAs(UnmanagedType.LPUTF8Str)] string label, bool enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndMenu")]
            internal static extern void EndMenu();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igMenuItemBool")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool MenuItemBool([MarshalAs(UnmanagedType.LPUTF8Str)] string label, [MarshalAs(UnmanagedType.LPUTF8Str)] string shortcut, bool selected, bool enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igMenuItemBoolPtr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool MenuItemBoolPtr([MarshalAs(UnmanagedType.LPUTF8Str)] string label, [MarshalAs(UnmanagedType.LPUTF8Str)] string shortcut, bool* p_selected, bool enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginTooltip")]
            internal static extern void BeginTooltip();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndTooltip")]
            internal static extern void EndTooltip();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetTooltip")]
            internal static extern void SetTooltip([MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igOpenPopup")]
            internal static extern void OpenPopup([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginPopup")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginPopup([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginPopupContextItem")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginPopupContextItem([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, int mouse_button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginPopupContextWindow")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginPopupContextWindow([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, int mouse_button, bool also_over_items);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginPopupContextVoid")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginPopupContextVoid([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, int mouse_button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginPopupModal")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginPopupModal([MarshalAs(UnmanagedType.LPUTF8Str)] string name, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndPopup")]
            internal static extern void EndPopup();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igOpenPopupOnItemClick")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OpenPopupOnItemClick([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, int mouse_button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsPopupOpenStr")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPopupOpenStr([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCloseCurrentPopup")]
            internal static extern void CloseCurrentPopup();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColumns")]
            internal static extern void Columns(int count, [MarshalAs(UnmanagedType.LPUTF8Str)] string id, bool border);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igNextColumn")]
            internal static extern void NextColumn();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetColumnIndex")]
            internal static extern int GetColumnIndex();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetColumnWidth")]
            internal static extern float GetColumnWidth(int column_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetColumnWidth")]
            internal static extern void SetColumnWidth(int column_index, float width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetColumnOffset")]
            internal static extern float GetColumnOffset(int column_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetColumnOffset")]
            internal static extern void SetColumnOffset(int column_index, float offset_x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetColumnsCount")]
            internal static extern int GetColumnsCount();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginTabBar")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginTabBar([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndTabBar")]
            internal static extern void EndTabBar();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginTabItem")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginTabItem([MarshalAs(UnmanagedType.LPUTF8Str)] string label, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndTabItem")]
            internal static extern void EndTabItem();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetTabItemClosed")]
            internal static extern void SetTabItemClosed([MarshalAs(UnmanagedType.LPUTF8Str)] string tab_or_docked_window_label);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLogToTTY")]
            internal static extern void LogToTTY(int auto_open_depth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLogToFile")]
            internal static extern void LogToFile(int auto_open_depth, [MarshalAs(UnmanagedType.LPUTF8Str)] string filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLogToClipboard")]
            internal static extern void LogToClipboard(int auto_open_depth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLogFinish")]
            internal static extern void LogFinish();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLogButtons")]
            internal static extern void LogButtons();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginDragDropSource")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropSource(int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetDragDropPayload")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SetDragDropPayload([MarshalAs(UnmanagedType.LPUTF8Str)] string type, global::System.IntPtr data, ulong sz, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndDragDropSource")]
            internal static extern void EndDragDropSource();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginDragDropTarget")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropTarget();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igAcceptDragDropPayload")]
            internal static extern global::System.IntPtr AcceptDragDropPayload([MarshalAs(UnmanagedType.LPUTF8Str)] string type, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndDragDropTarget")]
            internal static extern void EndDragDropTarget();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetDragDropPayload")]
            internal static extern global::System.IntPtr GetDragDropPayload();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushClipRect")]
            internal static extern void PushClipRect(global::ImGui.ImVec2.__Internal clip_rect_min, global::ImGui.ImVec2.__Internal clip_rect_max, bool intersect_with_current_clip_rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopClipRect")]
            internal static extern void PopClipRect();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetItemDefaultFocus")]
            internal static extern void SetItemDefaultFocus();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetKeyboardFocusHere")]
            internal static extern void SetKeyboardFocusHere(int offset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsItemHovered")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsItemHovered(int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsItemActive")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsItemActive();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsItemFocused")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsItemFocused();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsItemClicked")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsItemClicked(int mouse_button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsItemVisible")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsItemVisible();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsItemEdited")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsItemEdited();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsItemActivated")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsItemActivated();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsItemDeactivated")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsItemDeactivated();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsItemDeactivatedAfterEdit")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsItemDeactivatedAfterEdit();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsItemToggledOpen")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsItemToggledOpen();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsAnyItemHovered")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAnyItemHovered();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsAnyItemActive")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAnyItemActive();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsAnyItemFocused")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAnyItemFocused();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetItemRectMin")]
            internal static extern void GetItemRectMin(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetItemRectMax")]
            internal static extern void GetItemRectMax(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetItemRectSize")]
            internal static extern void GetItemRectSize(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetItemAllowOverlap")]
            internal static extern void SetItemAllowOverlap();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsRectVisibleNil")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsRectVisibleNil(global::ImGui.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsRectVisibleVec2")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsRectVisibleVec2(global::ImGui.ImVec2.__Internal rect_min, global::ImGui.ImVec2.__Internal rect_max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetTime")]
            internal static extern double GetTime();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetFrameCount")]
            internal static extern int GetFrameCount();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetBackgroundDrawList")]
            internal static extern global::System.IntPtr GetBackgroundDrawList();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetForegroundDrawListNil")]
            internal static extern global::System.IntPtr GetForegroundDrawListNil();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetDrawListSharedData")]
            internal static extern global::System.IntPtr GetDrawListSharedData();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetStyleColorName")]
            internal static extern global::System.IntPtr GetStyleColorName(int idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetStateStorage")]
            internal static extern void SetStateStorage(global::System.IntPtr storage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetStateStorage")]
            internal static extern global::System.IntPtr GetStateStorage();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCalcTextSize")]
            internal static extern void CalcTextSize(global::System.IntPtr pOut, [MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end, bool hide_text_after_double_hash, float wrap_width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCalcListClipping")]
            internal static extern void CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginChildFrame")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginChildFrame(uint id, global::ImGui.ImVec2.__Internal size, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndChildFrame")]
            internal static extern void EndChildFrame();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorConvertU32ToFloat4")]
            internal static extern void ColorConvertU32ToFloat4(global::System.IntPtr pOut, uint @in);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorConvertFloat4ToU32")]
            internal static extern uint ColorConvertFloat4ToU32(global::System.IntPtr @in);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetKeyIndex")]
            internal static extern int GetKeyIndex(int imgui_key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsKeyDown")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsKeyDown(int user_key_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsKeyPressed")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsKeyPressed(int user_key_index, bool repeat);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsKeyReleased")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsKeyReleased(int user_key_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetKeyPressedAmount")]
            internal static extern int GetKeyPressedAmount(int key_index, float repeat_delay, float rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCaptureKeyboardFromApp")]
            internal static extern void CaptureKeyboardFromApp(bool want_capture_keyboard_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsMouseDown")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMouseDown(int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsMouseClicked")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMouseClicked(int button, bool repeat);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsMouseReleased")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMouseReleased(int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsMouseDoubleClicked")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMouseDoubleClicked(int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsMouseHoveringRect")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMouseHoveringRect(global::ImGui.ImVec2.__Internal r_min, global::ImGui.ImVec2.__Internal r_max, bool clip);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsMousePosValid")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMousePosValid(global::System.IntPtr mouse_pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsAnyMouseDown")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsAnyMouseDown();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetMousePos")]
            internal static extern void GetMousePos(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetMousePosOnOpeningCurrentPopup")]
            internal static extern void GetMousePosOnOpeningCurrentPopup(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsMouseDragging")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMouseDragging(int button, float lock_threshold);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetMouseDragDelta")]
            internal static extern void GetMouseDragDelta(global::System.IntPtr pOut, int button, float lock_threshold);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igResetMouseDragDelta")]
            internal static extern void ResetMouseDragDelta(int button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetMouseCursor")]
            internal static extern int GetMouseCursor();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetMouseCursor")]
            internal static extern void SetMouseCursor(int cursor_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCaptureMouseFromApp")]
            internal static extern void CaptureMouseFromApp(bool want_capture_mouse_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetClipboardText")]
            internal static extern global::System.IntPtr GetClipboardText();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetClipboardText")]
            internal static extern void SetClipboardText([MarshalAs(UnmanagedType.LPUTF8Str)] string text);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLoadIniSettingsFromDisk")]
            internal static extern void LoadIniSettingsFromDisk([MarshalAs(UnmanagedType.LPUTF8Str)] string ini_filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLoadIniSettingsFromMemory")]
            internal static extern void LoadIniSettingsFromMemory([MarshalAs(UnmanagedType.LPUTF8Str)] string ini_data, ulong ini_size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSaveIniSettingsToDisk")]
            internal static extern void SaveIniSettingsToDisk([MarshalAs(UnmanagedType.LPUTF8Str)] string ini_filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSaveIniSettingsToMemory")]
            internal static extern global::System.IntPtr SaveIniSettingsToMemory(ulong* out_ini_size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetAllocatorFunctions")]
            internal static extern void SetAllocatorFunctions(global::System.IntPtr alloc_func, global::System.IntPtr free_func, global::System.IntPtr user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igMemAlloc")]
            internal static extern global::System.IntPtr MemAlloc(ulong size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igMemFree")]
            internal static extern void MemFree(global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStyle_ImGuiStyle")]
            internal static extern global::System.IntPtr ImGuiStyleImGuiStyle();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStyle_destroy")]
            internal static extern void ImGuiStyle_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStyle_ScaleAllSizes")]
            internal static extern void ImGuiStyleScaleAllSizes(global::System.IntPtr self, float scale_factor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiIO_AddInputCharacter")]
            internal static extern void ImGuiIO_AddInputCharacter(global::System.IntPtr self, uint c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiIO_AddInputCharactersUTF8")]
            internal static extern void ImGuiIO_AddInputCharactersUTF8(global::System.IntPtr self, [MarshalAs(UnmanagedType.LPUTF8Str)] string str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiIO_ClearInputCharacters")]
            internal static extern void ImGuiIO_ClearInputCharacters(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiIO_ImGuiIO")]
            internal static extern global::System.IntPtr ImGuiIO_ImGuiIO();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiIO_destroy")]
            internal static extern void ImGuiIO_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextCallbackData_ImGuiInputTextCallbackData")]
            internal static extern global::System.IntPtr ImGuiInputTextCallbackDataImGuiInputTextCallbackData();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextCallbackData_destroy")]
            internal static extern void ImGuiInputTextCallbackData_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextCallbackData_DeleteChars")]
            internal static extern void ImGuiInputTextCallbackDataDeleteChars(global::System.IntPtr self, int pos, int bytes_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextCallbackData_InsertChars")]
            internal static extern void ImGuiInputTextCallbackDataInsertChars(global::System.IntPtr self, int pos, [MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextCallbackData_HasSelection")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiInputTextCallbackDataHasSelection(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiPayload_ImGuiPayload")]
            internal static extern global::System.IntPtr ImGuiPayloadImGuiPayload();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiPayload_destroy")]
            internal static extern void ImGuiPayload_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiPayload_Clear")]
            internal static extern void ImGuiPayloadClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiPayload_IsDataType")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiPayloadIsDataType(global::System.IntPtr self, [MarshalAs(UnmanagedType.LPUTF8Str)] string type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiPayload_IsPreview")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiPayloadIsPreview(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiPayload_IsDelivery")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiPayloadIsDelivery(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiOnceUponAFrame_ImGuiOnceUponAFrame")]
            internal static extern global::System.IntPtr ImGuiOnceUponAFrameImGuiOnceUponAFrame();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiOnceUponAFrame_destroy")]
            internal static extern void ImGuiOnceUponAFrame_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextFilter_ImGuiTextFilter")]
            internal static extern global::System.IntPtr ImGuiTextFilterImGuiTextFilter([MarshalAs(UnmanagedType.LPUTF8Str)] string default_filter);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextFilter_destroy")]
            internal static extern void ImGuiTextFilter_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextFilter_Draw")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiTextFilterDraw(global::System.IntPtr self, [MarshalAs(UnmanagedType.LPUTF8Str)] string label, float width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextFilter_PassFilter")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiTextFilterPassFilter(global::System.IntPtr self, [MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextFilter_Build")]
            internal static extern void ImGuiTextFilterBuild(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextFilter_Clear")]
            internal static extern void ImGuiTextFilterClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextFilter_IsActive")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiTextFilterIsActive(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextRange_ImGuiTextRangeNil")]
            internal static extern global::System.IntPtr ImGuiTextRangeImGuiTextRangeNil();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextRange_destroy")]
            internal static extern void ImGuiTextRange_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextRange_ImGuiTextRangeStr")]
            internal static extern global::System.IntPtr ImGuiTextRangeImGuiTextRangeStr([MarshalAs(UnmanagedType.LPUTF8Str)] string _b, [MarshalAs(UnmanagedType.LPUTF8Str)] string _e);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextRange_empty")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiTextRange_empty(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextRange_split")]
            internal static extern void ImGuiTextRange_split(global::System.IntPtr self, sbyte separator, global::System.IntPtr @out);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextBuffer_ImGuiTextBuffer")]
            internal static extern global::System.IntPtr ImGuiTextBufferImGuiTextBuffer();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextBuffer_destroy")]
            internal static extern void ImGuiTextBuffer_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextBuffer_begin")]
            internal static extern global::System.IntPtr ImGuiTextBuffer_begin(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextBuffer_end")]
            internal static extern global::System.IntPtr ImGuiTextBuffer_end(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextBuffer_size")]
            internal static extern int ImGuiTextBuffer_size(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextBuffer_empty")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiTextBuffer_empty(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextBuffer_clear")]
            internal static extern void ImGuiTextBuffer_clear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextBuffer_reserve")]
            internal static extern void ImGuiTextBuffer_reserve(global::System.IntPtr self, int capacity);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextBuffer_c_str")]
            internal static extern global::System.IntPtr ImGuiTextBuffer_c_str(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTextBuffer_append")]
            internal static extern void ImGuiTextBuffer_append(global::System.IntPtr self, [MarshalAs(UnmanagedType.LPUTF8Str)] string str, [MarshalAs(UnmanagedType.LPUTF8Str)] string str_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStoragePair_ImGuiStoragePairInt")]
            internal static extern global::System.IntPtr ImGuiStoragePairImGuiStoragePairInt(uint _key, int _val_i);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStoragePair_destroy")]
            internal static extern void ImGuiStoragePair_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStoragePair_ImGuiStoragePairFloat")]
            internal static extern global::System.IntPtr ImGuiStoragePairImGuiStoragePairFloat(uint _key, float _val_f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStoragePair_ImGuiStoragePairPtr")]
            internal static extern global::System.IntPtr ImGuiStoragePairImGuiStoragePairPtr(uint _key, global::System.IntPtr _val_p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_Clear")]
            internal static extern void ImGuiStorageClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_GetInt")]
            internal static extern int ImGuiStorageGetInt(global::System.IntPtr self, uint key, int default_val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_SetInt")]
            internal static extern void ImGuiStorageSetInt(global::System.IntPtr self, uint key, int val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_GetBool")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiStorageGetBool(global::System.IntPtr self, uint key, bool default_val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_SetBool")]
            internal static extern void ImGuiStorageSetBool(global::System.IntPtr self, uint key, bool val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_GetFloat")]
            internal static extern float ImGuiStorageGetFloat(global::System.IntPtr self, uint key, float default_val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_SetFloat")]
            internal static extern void ImGuiStorageSetFloat(global::System.IntPtr self, uint key, float val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_GetVoidPtr")]
            internal static extern global::System.IntPtr ImGuiStorageGetVoidPtr(global::System.IntPtr self, uint key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_SetVoidPtr")]
            internal static extern void ImGuiStorageSetVoidPtr(global::System.IntPtr self, uint key, global::System.IntPtr val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_GetIntRef")]
            internal static extern int* ImGuiStorageGetIntRef(global::System.IntPtr self, uint key, int default_val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_GetBoolRef")]
            internal static extern bool* ImGuiStorageGetBoolRef(global::System.IntPtr self, uint key, bool default_val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_GetFloatRef")]
            internal static extern float* ImGuiStorageGetFloatRef(global::System.IntPtr self, uint key, float default_val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_GetVoidPtrRef")]
            internal static extern void** ImGuiStorageGetVoidPtrRef(global::System.IntPtr self, uint key, global::System.IntPtr default_val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_SetAllInt")]
            internal static extern void ImGuiStorageSetAllInt(global::System.IntPtr self, int val);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStorage_BuildSortByKey")]
            internal static extern void ImGuiStorageBuildSortByKey(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiListClipper_ImGuiListClipper")]
            internal static extern global::System.IntPtr ImGuiListClipperImGuiListClipper(int items_count, float items_height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiListClipper_destroy")]
            internal static extern void ImGuiListClipper_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiListClipper_Step")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiListClipperStep(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiListClipper_Begin")]
            internal static extern void ImGuiListClipperBegin(global::System.IntPtr self, int items_count, float items_height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiListClipper_End")]
            internal static extern void ImGuiListClipperEnd(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImColor_ImColorNil")]
            internal static extern global::System.IntPtr ImColorImColorNil();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImColor_destroy")]
            internal static extern void ImColor_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImColor_ImColorInt")]
            internal static extern global::System.IntPtr ImColorImColorInt(int r, int g, int b, int a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImColor_ImColorU32")]
            internal static extern global::System.IntPtr ImColorImColorU32(uint rgba);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImColor_ImColorFloat")]
            internal static extern global::System.IntPtr ImColorImColorFloat(float r, float g, float b, float a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImColor_ImColorVec4")]
            internal static extern global::System.IntPtr ImColorImColorVec4(global::System.IntPtr col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImColor_SetHSV")]
            internal static extern void ImColorSetHSV(global::System.IntPtr self, float h, float s, float v, float a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImColor_HSV")]
            internal static extern void ImColorHSV(global::System.IntPtr pOut, global::System.IntPtr self, float h, float s, float v, float a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawCmd_ImDrawCmd")]
            internal static extern global::System.IntPtr ImDrawCmdImDrawCmd();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawCmd_destroy")]
            internal static extern void ImDrawCmd_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawListSplitter_ImDrawListSplitter")]
            internal static extern global::System.IntPtr ImDrawListSplitterImDrawListSplitter();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawListSplitter_destroy")]
            internal static extern void ImDrawListSplitter_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawListSplitter_Clear")]
            internal static extern void ImDrawListSplitterClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawListSplitter_ClearFreeMemory")]
            internal static extern void ImDrawListSplitterClearFreeMemory(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawListSplitter_Split")]
            internal static extern void ImDrawListSplitterSplit(global::System.IntPtr self, global::System.IntPtr draw_list, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawListSplitter_Merge")]
            internal static extern void ImDrawListSplitterMerge(global::System.IntPtr self, global::System.IntPtr draw_list);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawListSplitter_SetCurrentChannel")]
            internal static extern void ImDrawListSplitterSetCurrentChannel(global::System.IntPtr self, global::System.IntPtr draw_list, int channel_idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_ImDrawList")]
            internal static extern global::System.IntPtr ImDrawListImDrawList(global::System.IntPtr shared_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_destroy")]
            internal static extern void ImDrawList_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PushClipRect")]
            internal static extern void ImDrawListPushClipRect(global::System.IntPtr self, global::ImGui.ImVec2.__Internal clip_rect_min, global::ImGui.ImVec2.__Internal clip_rect_max, bool intersect_with_current_clip_rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PushClipRectFullScreen")]
            internal static extern void ImDrawListPushClipRectFullScreen(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PopClipRect")]
            internal static extern void ImDrawListPopClipRect(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PushTextureID")]
            internal static extern void ImDrawListPushTextureID(global::System.IntPtr self, global::System.IntPtr texture_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PopTextureID")]
            internal static extern void ImDrawListPopTextureID(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_GetClipRectMin")]
            internal static extern void ImDrawListGetClipRectMin(global::System.IntPtr pOut, global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_GetClipRectMax")]
            internal static extern void ImDrawListGetClipRectMax(global::System.IntPtr pOut, global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddLine")]
            internal static extern void ImDrawListAddLine(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p1, global::ImGui.ImVec2.__Internal p2, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddRect")]
            internal static extern void ImDrawListAddRect(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p_min, global::ImGui.ImVec2.__Internal p_max, uint col, float rounding, int rounding_corners, float thickness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddRectFilled")]
            internal static extern void ImDrawListAddRectFilled(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p_min, global::ImGui.ImVec2.__Internal p_max, uint col, float rounding, int rounding_corners);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddRectFilledMultiColor")]
            internal static extern void ImDrawListAddRectFilledMultiColor(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p_min, global::ImGui.ImVec2.__Internal p_max, uint col_upr_left, uint col_upr_right, uint col_bot_right, uint col_bot_left);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddQuad")]
            internal static extern void ImDrawListAddQuad(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p1, global::ImGui.ImVec2.__Internal p2, global::ImGui.ImVec2.__Internal p3, global::ImGui.ImVec2.__Internal p4, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddQuadFilled")]
            internal static extern void ImDrawListAddQuadFilled(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p1, global::ImGui.ImVec2.__Internal p2, global::ImGui.ImVec2.__Internal p3, global::ImGui.ImVec2.__Internal p4, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddTriangle")]
            internal static extern void ImDrawListAddTriangle(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p1, global::ImGui.ImVec2.__Internal p2, global::ImGui.ImVec2.__Internal p3, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddTriangleFilled")]
            internal static extern void ImDrawListAddTriangleFilled(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p1, global::ImGui.ImVec2.__Internal p2, global::ImGui.ImVec2.__Internal p3, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddCircle")]
            internal static extern void ImDrawListAddCircle(global::System.IntPtr self, global::ImGui.ImVec2.__Internal center, float radius, uint col, int num_segments, float thickness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddCircleFilled")]
            internal static extern void ImDrawListAddCircleFilled(global::System.IntPtr self, global::ImGui.ImVec2.__Internal center, float radius, uint col, int num_segments);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddNgon")]
            internal static extern void ImDrawListAddNgon(global::System.IntPtr self, global::ImGui.ImVec2.__Internal center, float radius, uint col, int num_segments, float thickness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddNgonFilled")]
            internal static extern void ImDrawListAddNgonFilled(global::System.IntPtr self, global::ImGui.ImVec2.__Internal center, float radius, uint col, int num_segments);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddTextVec2")]
            internal static extern void ImDrawListAddTextVec2(global::System.IntPtr self, global::ImGui.ImVec2.__Internal pos, uint col, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_begin, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddTextFontPtr")]
            internal static extern void ImDrawListAddTextFontPtr(global::System.IntPtr self, global::System.IntPtr font, float font_size, global::ImGui.ImVec2.__Internal pos, uint col, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_begin, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end, float wrap_width, global::System.IntPtr cpu_fine_clip_rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddPolyline")]
            internal static extern void ImDrawListAddPolyline(global::System.IntPtr self, global::System.IntPtr points, int num_points, uint col, bool closed, float thickness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddConvexPolyFilled")]
            internal static extern void ImDrawListAddConvexPolyFilled(global::System.IntPtr self, global::System.IntPtr points, int num_points, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddBezierCurve")]
            internal static extern void ImDrawListAddBezierCurve(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p1, global::ImGui.ImVec2.__Internal p2, global::ImGui.ImVec2.__Internal p3, global::ImGui.ImVec2.__Internal p4, uint col, float thickness, int num_segments);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddImage")]
            internal static extern void ImDrawListAddImage(global::System.IntPtr self, global::System.IntPtr user_texture_id, global::ImGui.ImVec2.__Internal p_min, global::ImGui.ImVec2.__Internal p_max, global::ImGui.ImVec2.__Internal uv_min, global::ImGui.ImVec2.__Internal uv_max, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddImageQuad")]
            internal static extern void ImDrawListAddImageQuad(global::System.IntPtr self, global::System.IntPtr user_texture_id, global::ImGui.ImVec2.__Internal p1, global::ImGui.ImVec2.__Internal p2, global::ImGui.ImVec2.__Internal p3, global::ImGui.ImVec2.__Internal p4, global::ImGui.ImVec2.__Internal uv1, global::ImGui.ImVec2.__Internal uv2, global::ImGui.ImVec2.__Internal uv3, global::ImGui.ImVec2.__Internal uv4, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddImageRounded")]
            internal static extern void ImDrawListAddImageRounded(global::System.IntPtr self, global::System.IntPtr user_texture_id, global::ImGui.ImVec2.__Internal p_min, global::ImGui.ImVec2.__Internal p_max, global::ImGui.ImVec2.__Internal uv_min, global::ImGui.ImVec2.__Internal uv_max, uint col, float rounding, int rounding_corners);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PathClear")]
            internal static extern void ImDrawListPathClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PathLineTo")]
            internal static extern void ImDrawListPathLineTo(global::System.IntPtr self, global::ImGui.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PathLineToMergeDuplicate")]
            internal static extern void ImDrawListPathLineToMergeDuplicate(global::System.IntPtr self, global::ImGui.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PathFillConvex")]
            internal static extern void ImDrawListPathFillConvex(global::System.IntPtr self, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PathStroke")]
            internal static extern void ImDrawListPathStroke(global::System.IntPtr self, uint col, bool closed, float thickness);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PathArcTo")]
            internal static extern void ImDrawListPathArcTo(global::System.IntPtr self, global::ImGui.ImVec2.__Internal center, float radius, float a_min, float a_max, int num_segments);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PathArcToFast")]
            internal static extern void ImDrawListPathArcToFast(global::System.IntPtr self, global::ImGui.ImVec2.__Internal center, float radius, int a_min_of_12, int a_max_of_12);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PathBezierCurveTo")]
            internal static extern void ImDrawListPathBezierCurveTo(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p2, global::ImGui.ImVec2.__Internal p3, global::ImGui.ImVec2.__Internal p4, int num_segments);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PathRect")]
            internal static extern void ImDrawListPathRect(global::System.IntPtr self, global::ImGui.ImVec2.__Internal rect_min, global::ImGui.ImVec2.__Internal rect_max, float rounding, int rounding_corners);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddCallback")]
            internal static extern void ImDrawListAddCallback(global::System.IntPtr self, global::System.IntPtr callback, global::System.IntPtr callback_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_AddDrawCmd")]
            internal static extern void ImDrawListAddDrawCmd(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_CloneOutput")]
            internal static extern global::System.IntPtr ImDrawListCloneOutput(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_ChannelsSplit")]
            internal static extern void ImDrawListChannelsSplit(global::System.IntPtr self, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_ChannelsMerge")]
            internal static extern void ImDrawListChannelsMerge(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_ChannelsSetCurrent")]
            internal static extern void ImDrawListChannelsSetCurrent(global::System.IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_Clear")]
            internal static extern void ImDrawListClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_ClearFreeMemory")]
            internal static extern void ImDrawListClearFreeMemory(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PrimReserve")]
            internal static extern void ImDrawListPrimReserve(global::System.IntPtr self, int idx_count, int vtx_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PrimUnreserve")]
            internal static extern void ImDrawListPrimUnreserve(global::System.IntPtr self, int idx_count, int vtx_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PrimRect")]
            internal static extern void ImDrawListPrimRect(global::System.IntPtr self, global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PrimRectUV")]
            internal static extern void ImDrawListPrimRectUV(global::System.IntPtr self, global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b, global::ImGui.ImVec2.__Internal uv_a, global::ImGui.ImVec2.__Internal uv_b, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PrimQuadUV")]
            internal static extern void ImDrawListPrimQuadUV(global::System.IntPtr self, global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b, global::ImGui.ImVec2.__Internal c, global::ImGui.ImVec2.__Internal d, global::ImGui.ImVec2.__Internal uv_a, global::ImGui.ImVec2.__Internal uv_b, global::ImGui.ImVec2.__Internal uv_c, global::ImGui.ImVec2.__Internal uv_d, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PrimWriteVtx")]
            internal static extern void ImDrawListPrimWriteVtx(global::System.IntPtr self, global::ImGui.ImVec2.__Internal pos, global::ImGui.ImVec2.__Internal uv, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PrimWriteIdx")]
            internal static extern void ImDrawListPrimWriteIdx(global::System.IntPtr self, ushort idx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_PrimVtx")]
            internal static extern void ImDrawListPrimVtx(global::System.IntPtr self, global::ImGui.ImVec2.__Internal pos, global::ImGui.ImVec2.__Internal uv, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_UpdateClipRect")]
            internal static extern void ImDrawListUpdateClipRect(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawList_UpdateTextureID")]
            internal static extern void ImDrawListUpdateTextureID(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawData_ImDrawData")]
            internal static extern global::System.IntPtr ImDrawDataImDrawData();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawData_destroy")]
            internal static extern void ImDrawData_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawData_Clear")]
            internal static extern void ImDrawDataClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawData_DeIndexAllBuffers")]
            internal static extern void ImDrawDataDeIndexAllBuffers(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawData_ScaleClipRects")]
            internal static extern void ImDrawDataScaleClipRects(global::System.IntPtr self, global::ImGui.ImVec2.__Internal fb_scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontConfig_ImFontConfig")]
            internal static extern global::System.IntPtr ImFontConfigImFontConfig();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontConfig_destroy")]
            internal static extern void ImFontConfig_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder")]
            internal static extern global::System.IntPtr ImFontGlyphRangesBuilderImFontGlyphRangesBuilder();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontGlyphRangesBuilder_destroy")]
            internal static extern void ImFontGlyphRangesBuilder_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontGlyphRangesBuilder_Clear")]
            internal static extern void ImFontGlyphRangesBuilderClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontGlyphRangesBuilder_GetBit")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImFontGlyphRangesBuilderGetBit(global::System.IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontGlyphRangesBuilder_SetBit")]
            internal static extern void ImFontGlyphRangesBuilderSetBit(global::System.IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontGlyphRangesBuilder_AddChar")]
            internal static extern void ImFontGlyphRangesBuilderAddChar(global::System.IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontGlyphRangesBuilder_AddText")]
            internal static extern void ImFontGlyphRangesBuilderAddText(global::System.IntPtr self, [MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontGlyphRangesBuilder_AddRanges")]
            internal static extern void ImFontGlyphRangesBuilderAddRanges(global::System.IntPtr self, ushort* ranges);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontGlyphRangesBuilder_BuildRanges")]
            internal static extern void ImFontGlyphRangesBuilderBuildRanges(global::System.IntPtr self, global::System.IntPtr out_ranges);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlasCustomRect_ImFontAtlasCustomRect")]
            internal static extern global::System.IntPtr ImFontAtlasCustomRectImFontAtlasCustomRect();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlasCustomRect_destroy")]
            internal static extern void ImFontAtlasCustomRect_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlasCustomRect_IsPacked")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImFontAtlasCustomRectIsPacked(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_ImFontAtlas")]
            internal static extern global::System.IntPtr ImFontAtlasImFontAtlas();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_destroy")]
            internal static extern void ImFontAtlas_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_AddFont")]
            internal static extern global::System.IntPtr ImFontAtlasAddFont(global::System.IntPtr self, global::System.IntPtr font_cfg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_AddFontDefault")]
            internal static extern global::System.IntPtr ImFontAtlasAddFontDefault(global::System.IntPtr self, global::System.IntPtr font_cfg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_AddFontFromFileTTF")]
            internal static extern global::System.IntPtr ImFontAtlasAddFontFromFileTTF(global::System.IntPtr self, [MarshalAs(UnmanagedType.LPUTF8Str)] string filename, float size_pixels, global::System.IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_AddFontFromMemoryTTF")]
            internal static extern global::System.IntPtr ImFontAtlasAddFontFromMemoryTTF(global::System.IntPtr self, global::System.IntPtr font_data, int font_size, float size_pixels, global::System.IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_AddFontFromMemoryCompressedTTF")]
            internal static extern global::System.IntPtr ImFontAtlasAddFontFromMemoryCompressedTTF(global::System.IntPtr self, global::System.IntPtr compressed_font_data, int compressed_font_size, float size_pixels, global::System.IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_AddFontFromMemoryCompressedBase85TTF")]
            internal static extern global::System.IntPtr ImFontAtlasAddFontFromMemoryCompressedBase85TTF(global::System.IntPtr self, [MarshalAs(UnmanagedType.LPUTF8Str)] string compressed_font_data_base85, float size_pixels, global::System.IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_ClearInputData")]
            internal static extern void ImFontAtlasClearInputData(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_ClearTexData")]
            internal static extern void ImFontAtlasClearTexData(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_ClearFonts")]
            internal static extern void ImFontAtlasClearFonts(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_Clear")]
            internal static extern void ImFontAtlasClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_Build")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImFontAtlasBuild(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetTexDataAsAlpha8")]
            internal static extern void ImFontAtlasGetTexDataAsAlpha8(global::System.IntPtr self, byte** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetTexDataAsRGBA32")]
            internal static extern void ImFontAtlasGetTexDataAsRGBA32(global::System.IntPtr self, byte** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_IsBuilt")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImFontAtlasIsBuilt(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_SetTexID")]
            internal static extern void ImFontAtlasSetTexID(global::System.IntPtr self, global::System.IntPtr id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetGlyphRangesDefault")]
            internal static extern ushort* ImFontAtlasGetGlyphRangesDefault(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetGlyphRangesKorean")]
            internal static extern ushort* ImFontAtlasGetGlyphRangesKorean(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetGlyphRangesJapanese")]
            internal static extern ushort* ImFontAtlasGetGlyphRangesJapanese(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetGlyphRangesChineseFull")]
            internal static extern ushort* ImFontAtlasGetGlyphRangesChineseFull(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon")]
            internal static extern ushort* ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetGlyphRangesCyrillic")]
            internal static extern ushort* ImFontAtlasGetGlyphRangesCyrillic(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetGlyphRangesThai")]
            internal static extern ushort* ImFontAtlasGetGlyphRangesThai(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetGlyphRangesVietnamese")]
            internal static extern ushort* ImFontAtlasGetGlyphRangesVietnamese(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_AddCustomRectRegular")]
            internal static extern int ImFontAtlasAddCustomRectRegular(global::System.IntPtr self, uint id, int width, int height);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_AddCustomRectFontGlyph")]
            internal static extern int ImFontAtlasAddCustomRectFontGlyph(global::System.IntPtr self, global::System.IntPtr font, ushort id, int width, int height, float advance_x, global::ImGui.ImVec2.__Internal offset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetCustomRectByIndex")]
            internal static extern global::System.IntPtr ImFontAtlasGetCustomRectByIndex(global::System.IntPtr self, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_CalcCustomRectUV")]
            internal static extern void ImFontAtlasCalcCustomRectUV(global::System.IntPtr self, global::System.IntPtr rect, global::System.IntPtr out_uv_min, global::System.IntPtr out_uv_max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFontAtlas_GetMouseCursorTexData")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImFontAtlasGetMouseCursorTexData(global::System.IntPtr self, int cursor, global::System.IntPtr out_offset, global::System.IntPtr out_size, global::ImGui.ImVec2.__Internal[] out_uv_border, global::ImGui.ImVec2.__Internal[] out_uv_fill);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_ImFont")]
            internal static extern global::System.IntPtr ImFontImFont();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_destroy")]
            internal static extern void ImFont_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_FindGlyph")]
            internal static extern global::System.IntPtr ImFontFindGlyph(global::System.IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_FindGlyphNoFallback")]
            internal static extern global::System.IntPtr ImFontFindGlyphNoFallback(global::System.IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_GetCharAdvance")]
            internal static extern float ImFontGetCharAdvance(global::System.IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_IsLoaded")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImFontIsLoaded(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_GetDebugName")]
            internal static extern global::System.IntPtr ImFontGetDebugName(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_CalcTextSizeA")]
            internal static extern void ImFontCalcTextSizeA(global::System.IntPtr pOut, global::System.IntPtr self, float size, float max_width, float wrap_width, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_begin, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end, sbyte** remaining);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_CalcWordWrapPositionA")]
            internal static extern global::System.IntPtr ImFontCalcWordWrapPositionA(global::System.IntPtr self, float scale, [MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end, float wrap_width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_RenderChar")]
            internal static extern void ImFontRenderChar(global::System.IntPtr self, global::System.IntPtr draw_list, float size, global::ImGui.ImVec2.__Internal pos, uint col, ushort c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_RenderText")]
            internal static extern void ImFontRenderText(global::System.IntPtr self, global::System.IntPtr draw_list, float size, global::ImGui.ImVec2.__Internal pos, uint col, global::System.IntPtr clip_rect, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_begin, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end, float wrap_width, bool cpu_fine_clip);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_BuildLookupTable")]
            internal static extern void ImFontBuildLookupTable(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_ClearOutputData")]
            internal static extern void ImFontClearOutputData(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_GrowIndex")]
            internal static extern void ImFontGrowIndex(global::System.IntPtr self, int new_size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_AddGlyph")]
            internal static extern void ImFontAddGlyph(global::System.IntPtr self, ushort c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_AddRemapChar")]
            internal static extern void ImFontAddRemapChar(global::System.IntPtr self, ushort dst, ushort src, bool overwrite_dst);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImFont_SetFallbackChar")]
            internal static extern void ImFontSetFallbackChar(global::System.IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImHashData")]
            internal static extern uint ImHashData(global::System.IntPtr data, ulong data_size, uint seed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImHashStr")]
            internal static extern uint ImHashStr([MarshalAs(UnmanagedType.LPUTF8Str)] string data, ulong data_size, uint seed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImIsPowerOfTwo")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImIsPowerOfTwo(int v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImUpperPowerOfTwo")]
            internal static extern int ImUpperPowerOfTwo(int v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStricmp")]
            internal static extern int ImStricmp([MarshalAs(UnmanagedType.LPUTF8Str)] string str1, [MarshalAs(UnmanagedType.LPUTF8Str)] string str2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStrnicmp")]
            internal static extern int ImStrnicmp([MarshalAs(UnmanagedType.LPUTF8Str)] string str1, [MarshalAs(UnmanagedType.LPUTF8Str)] string str2, ulong count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStrncpy")]
            internal static extern void ImStrncpy(sbyte* dst, [MarshalAs(UnmanagedType.LPUTF8Str)] string src, ulong count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStrdup")]
            internal static extern sbyte* ImStrdup([MarshalAs(UnmanagedType.LPUTF8Str)] string str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStrdupcpy")]
            internal static extern sbyte* ImStrdupcpy(sbyte* dst, ulong* p_dst_size, [MarshalAs(UnmanagedType.LPUTF8Str)] string str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStrchrRange")]
            internal static extern global::System.IntPtr ImStrchrRange([MarshalAs(UnmanagedType.LPUTF8Str)] string str_begin, [MarshalAs(UnmanagedType.LPUTF8Str)] string str_end, sbyte c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStrlenW")]
            internal static extern int ImStrlenW(ushort* str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStreolRange")]
            internal static extern global::System.IntPtr ImStreolRange([MarshalAs(UnmanagedType.LPUTF8Str)] string str, [MarshalAs(UnmanagedType.LPUTF8Str)] string str_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStrbolW")]
            internal static extern ushort* ImStrbolW(ushort* buf_mid_line, ushort* buf_begin);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStristr")]
            internal static extern global::System.IntPtr ImStristr([MarshalAs(UnmanagedType.LPUTF8Str)] string haystack, [MarshalAs(UnmanagedType.LPUTF8Str)] string haystack_end, [MarshalAs(UnmanagedType.LPUTF8Str)] string needle, [MarshalAs(UnmanagedType.LPUTF8Str)] string needle_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStrTrimBlanks")]
            internal static extern void ImStrTrimBlanks(sbyte* str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImStrSkipBlank")]
            internal static extern global::System.IntPtr ImStrSkipBlank([MarshalAs(UnmanagedType.LPUTF8Str)] string str);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFormatString")]
            internal static extern int ImFormatString(sbyte* buf, ulong buf_size, [MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImParseFormatFindStart")]
            internal static extern global::System.IntPtr ImParseFormatFindStart([MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImParseFormatFindEnd")]
            internal static extern global::System.IntPtr ImParseFormatFindEnd([MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImParseFormatTrimDecorations")]
            internal static extern global::System.IntPtr ImParseFormatTrimDecorations([MarshalAs(UnmanagedType.LPUTF8Str)] string format, sbyte* buf, ulong buf_size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImParseFormatPrecision")]
            internal static extern int ImParseFormatPrecision([MarshalAs(UnmanagedType.LPUTF8Str)] string format, int default_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImCharIsBlankA")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImCharIsBlankA(sbyte c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImCharIsBlankW")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImCharIsBlankW(uint c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImTextStrToUtf8")]
            internal static extern int ImTextStrToUtf8(sbyte* buf, int buf_size, ushort* in_text, ushort* in_text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImTextCharFromUtf8")]
            internal static extern int ImTextCharFromUtf8(uint* out_char, [MarshalAs(UnmanagedType.LPUTF8Str)] string in_text, [MarshalAs(UnmanagedType.LPUTF8Str)] string in_text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImTextStrFromUtf8")]
            internal static extern int ImTextStrFromUtf8(ushort* buf, int buf_size, [MarshalAs(UnmanagedType.LPUTF8Str)] string in_text, [MarshalAs(UnmanagedType.LPUTF8Str)] string in_text_end, sbyte** in_remaining);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImTextCountCharsFromUtf8")]
            internal static extern int ImTextCountCharsFromUtf8([MarshalAs(UnmanagedType.LPUTF8Str)] string in_text, [MarshalAs(UnmanagedType.LPUTF8Str)] string in_text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImTextCountUtf8BytesFromChar")]
            internal static extern int ImTextCountUtf8BytesFromChar([MarshalAs(UnmanagedType.LPUTF8Str)] string in_text, [MarshalAs(UnmanagedType.LPUTF8Str)] string in_text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImTextCountUtf8BytesFromStr")]
            internal static extern int ImTextCountUtf8BytesFromStr(ushort* in_text, ushort* in_text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFileOpen")]
            internal static extern global::System.IntPtr ImFileOpen([MarshalAs(UnmanagedType.LPUTF8Str)] string filename, [MarshalAs(UnmanagedType.LPUTF8Str)] string mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFileClose")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImFileClose(global::System.IntPtr file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFileGetSize")]
            internal static extern ulong ImFileGetSize(global::System.IntPtr file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFileRead")]
            internal static extern ulong ImFileRead(global::System.IntPtr data, ulong size, ulong count, global::System.IntPtr file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFileWrite")]
            internal static extern ulong ImFileWrite(global::System.IntPtr data, ulong size, ulong count, global::System.IntPtr file);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFileLoadToMemory")]
            internal static extern global::System.IntPtr ImFileLoadToMemory([MarshalAs(UnmanagedType.LPUTF8Str)] string filename, [MarshalAs(UnmanagedType.LPUTF8Str)] string mode, ulong* out_file_size, int padding_bytes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImPowFloat")]
            internal static extern float ImPowFloat(float x, float y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImPowdouble")]
            internal static extern double ImPowdouble(double x, double y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImMin")]
            internal static extern void ImMin(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal lhs, global::ImGui.ImVec2.__Internal rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImMax")]
            internal static extern void ImMax(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal lhs, global::ImGui.ImVec2.__Internal rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImClamp")]
            internal static extern void ImClamp(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal v, global::ImGui.ImVec2.__Internal mn, global::ImGui.ImVec2.__Internal mx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImLerpVec2Float")]
            internal static extern void ImLerpVec2Float(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b, float t);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImLerpVec2Vec2")]
            internal static extern void ImLerpVec2Vec2(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b, global::ImGui.ImVec2.__Internal t);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImLerpVec4")]
            internal static extern void ImLerpVec4(global::System.IntPtr pOut, global::System.IntPtr a, global::System.IntPtr b, float t);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImSaturate")]
            internal static extern float ImSaturate(float f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImLengthSqrVec2")]
            internal static extern float ImLengthSqrVec2(global::ImGui.ImVec2.__Internal lhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImLengthSqrVec4")]
            internal static extern float ImLengthSqrVec4(global::System.IntPtr lhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImInvLength")]
            internal static extern float ImInvLength(global::ImGui.ImVec2.__Internal lhs, float fail_value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFloorFloat")]
            internal static extern float ImFloorFloat(float f);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFloorVec2")]
            internal static extern void ImFloorVec2(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImModPositive")]
            internal static extern int ImModPositive(int a, int b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImDot")]
            internal static extern float ImDot(global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImRotate")]
            internal static extern void ImRotate(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal v, float cos_a, float sin_a);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImLinearSweep")]
            internal static extern float ImLinearSweep(float current, float target, float speed);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImMul")]
            internal static extern void ImMul(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal lhs, global::ImGui.ImVec2.__Internal rhs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImBezierCalc")]
            internal static extern void ImBezierCalc(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal p1, global::ImGui.ImVec2.__Internal p2, global::ImGui.ImVec2.__Internal p3, global::ImGui.ImVec2.__Internal p4, float t);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImBezierClosestPoint")]
            internal static extern void ImBezierClosestPoint(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal p1, global::ImGui.ImVec2.__Internal p2, global::ImGui.ImVec2.__Internal p3, global::ImGui.ImVec2.__Internal p4, global::ImGui.ImVec2.__Internal p, int num_segments);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImBezierClosestPointCasteljau")]
            internal static extern void ImBezierClosestPointCasteljau(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal p1, global::ImGui.ImVec2.__Internal p2, global::ImGui.ImVec2.__Internal p3, global::ImGui.ImVec2.__Internal p4, global::ImGui.ImVec2.__Internal p, float tess_tol);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImLineClosestPoint")]
            internal static extern void ImLineClosestPoint(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b, global::ImGui.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImTriangleContainsPoint")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImTriangleContainsPoint(global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b, global::ImGui.ImVec2.__Internal c, global::ImGui.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImTriangleClosestPoint")]
            internal static extern void ImTriangleClosestPoint(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b, global::ImGui.ImVec2.__Internal c, global::ImGui.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImTriangleBarycentricCoords")]
            internal static extern void ImTriangleBarycentricCoords(global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b, global::ImGui.ImVec2.__Internal c, global::ImGui.ImVec2.__Internal p, float out_u, float out_v, float out_w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImTriangleArea")]
            internal static extern float ImTriangleArea(global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b, global::ImGui.ImVec2.__Internal c);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImGetDirQuadrantFromDelta")]
            internal static extern int ImGetDirQuadrantFromDelta(float dx, float dy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImBoolVector_ImBoolVector")]
            internal static extern global::System.IntPtr ImBoolVectorImBoolVector();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImBoolVector_destroy")]
            internal static extern void ImBoolVector_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImBoolVector_Resize")]
            internal static extern void ImBoolVectorResize(global::System.IntPtr self, int sz);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImBoolVector_Clear")]
            internal static extern void ImBoolVectorClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImBoolVector_GetBit")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImBoolVectorGetBit(global::System.IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImBoolVector_SetBit")]
            internal static extern void ImBoolVectorSetBit(global::System.IntPtr self, int n, bool v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec1_ImVec1Nil")]
            internal static extern global::System.IntPtr ImVec1ImVec1Nil();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec1_destroy")]
            internal static extern void ImVec1_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec1_ImVec1Float")]
            internal static extern global::System.IntPtr ImVec1ImVec1Float(float _x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec2ih_ImVec2ihNil")]
            internal static extern global::System.IntPtr ImVec2ihImVec2ihNil();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec2ih_destroy")]
            internal static extern void ImVec2ih_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVec2ih_ImVec2ihshort")]
            internal static extern global::System.IntPtr ImVec2ihImVec2ihshort(short _x, short _y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_ImRectNil")]
            internal static extern global::System.IntPtr ImRectImRectNil();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_destroy")]
            internal static extern void ImRect_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_ImRectVec2")]
            internal static extern global::System.IntPtr ImRectImRectVec2(global::ImGui.ImVec2.__Internal min, global::ImGui.ImVec2.__Internal max);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_ImRectVec4")]
            internal static extern global::System.IntPtr ImRectImRectVec4(global::System.IntPtr v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_ImRectFloat")]
            internal static extern global::System.IntPtr ImRectImRectFloat(float x1, float y1, float x2, float y2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_GetCenter")]
            internal static extern void ImRectGetCenter(global::System.IntPtr pOut, global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_GetSize")]
            internal static extern void ImRectGetSize(global::System.IntPtr pOut, global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_GetWidth")]
            internal static extern float ImRectGetWidth(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_GetHeight")]
            internal static extern float ImRectGetHeight(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_GetTL")]
            internal static extern void ImRectGetTL(global::System.IntPtr pOut, global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_GetTR")]
            internal static extern void ImRectGetTR(global::System.IntPtr pOut, global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_GetBL")]
            internal static extern void ImRectGetBL(global::System.IntPtr pOut, global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_GetBR")]
            internal static extern void ImRectGetBR(global::System.IntPtr pOut, global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_ContainsVec2")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImRectContainsVec2(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_ContainsRect")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImRectContainsRect(global::System.IntPtr self, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_Overlaps")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImRectOverlaps(global::System.IntPtr self, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_AddVec2")]
            internal static extern void ImRectAddVec2(global::System.IntPtr self, global::ImGui.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_AddRect")]
            internal static extern void ImRectAddRect(global::System.IntPtr self, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_ExpandFloat")]
            internal static extern void ImRectExpandFloat(global::System.IntPtr self, float amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_ExpandVec2")]
            internal static extern void ImRectExpandVec2(global::System.IntPtr self, global::ImGui.ImVec2.__Internal amount);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_Translate")]
            internal static extern void ImRectTranslate(global::System.IntPtr self, global::ImGui.ImVec2.__Internal d);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_TranslateX")]
            internal static extern void ImRectTranslateX(global::System.IntPtr self, float dx);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_TranslateY")]
            internal static extern void ImRectTranslateY(global::System.IntPtr self, float dy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_ClipWith")]
            internal static extern void ImRectClipWith(global::System.IntPtr self, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_ClipWithFull")]
            internal static extern void ImRectClipWithFull(global::System.IntPtr self, global::System.IntPtr r);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_Floor")]
            internal static extern void ImRectFloor(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImRect_IsInverted")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImRectIsInverted(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStyleMod_ImGuiStyleModInt")]
            internal static extern global::System.IntPtr ImGuiStyleModImGuiStyleModInt(int idx, int v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStyleMod_destroy")]
            internal static extern void ImGuiStyleMod_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStyleMod_ImGuiStyleModFloat")]
            internal static extern global::System.IntPtr ImGuiStyleModImGuiStyleModFloat(int idx, float v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiStyleMod_ImGuiStyleModVec2")]
            internal static extern global::System.IntPtr ImGuiStyleModImGuiStyleModVec2(int idx, global::ImGui.ImVec2.__Internal v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiMenuColumns_ImGuiMenuColumns")]
            internal static extern global::System.IntPtr ImGuiMenuColumnsImGuiMenuColumns();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiMenuColumns_destroy")]
            internal static extern void ImGuiMenuColumns_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiMenuColumns_Update")]
            internal static extern void ImGuiMenuColumnsUpdate(global::System.IntPtr self, int count, float spacing, bool clear);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiMenuColumns_DeclColumns")]
            internal static extern float ImGuiMenuColumnsDeclColumns(global::System.IntPtr self, float w0, float w1, float w2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiMenuColumns_CalcExtraSpace")]
            internal static extern float ImGuiMenuColumnsCalcExtraSpace(global::System.IntPtr self, float avail_w);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_ImGuiInputTextState")]
            internal static extern global::System.IntPtr ImGuiInputTextStateImGuiInputTextState();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_destroy")]
            internal static extern void ImGuiInputTextState_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_ClearText")]
            internal static extern void ImGuiInputTextStateClearText(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_ClearFreeMemory")]
            internal static extern void ImGuiInputTextStateClearFreeMemory(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_GetUndoAvailCount")]
            internal static extern int ImGuiInputTextStateGetUndoAvailCount(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_GetRedoAvailCount")]
            internal static extern int ImGuiInputTextStateGetRedoAvailCount(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_OnKeyPressed")]
            internal static extern void ImGuiInputTextStateOnKeyPressed(global::System.IntPtr self, int key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_CursorAnimReset")]
            internal static extern void ImGuiInputTextStateCursorAnimReset(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_CursorClamp")]
            internal static extern void ImGuiInputTextStateCursorClamp(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_HasSelection")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiInputTextStateHasSelection(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_ClearSelection")]
            internal static extern void ImGuiInputTextStateClearSelection(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiInputTextState_SelectAll")]
            internal static extern void ImGuiInputTextStateSelectAll(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindowSettings_ImGuiWindowSettings")]
            internal static extern global::System.IntPtr ImGuiWindowSettingsImGuiWindowSettings();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindowSettings_destroy")]
            internal static extern void ImGuiWindowSettings_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindowSettings_GetName")]
            internal static extern sbyte* ImGuiWindowSettingsGetName(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiSettingsHandler_ImGuiSettingsHandler")]
            internal static extern global::System.IntPtr ImGuiSettingsHandlerImGuiSettingsHandler();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiSettingsHandler_destroy")]
            internal static extern void ImGuiSettingsHandler_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiPopupData_ImGuiPopupData")]
            internal static extern global::System.IntPtr ImGuiPopupDataImGuiPopupData();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiPopupData_destroy")]
            internal static extern void ImGuiPopupData_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiColumnData_ImGuiColumnData")]
            internal static extern global::System.IntPtr ImGuiColumnDataImGuiColumnData();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiColumnData_destroy")]
            internal static extern void ImGuiColumnData_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiColumns_ImGuiColumns")]
            internal static extern global::System.IntPtr ImGuiColumnsImGuiColumns();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiColumns_destroy")]
            internal static extern void ImGuiColumns_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiColumns_Clear")]
            internal static extern void ImGuiColumnsClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawListSharedData_ImDrawListSharedData")]
            internal static extern global::System.IntPtr ImDrawListSharedDataImDrawListSharedData();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawListSharedData_destroy")]
            internal static extern void ImDrawListSharedData_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawListSharedData_SetCircleSegmentMaxError")]
            internal static extern void ImDrawListSharedDataSetCircleSegmentMaxError(global::System.IntPtr self, float max_error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawDataBuilder_Clear")]
            internal static extern void ImDrawDataBuilderClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawDataBuilder_ClearFreeMemory")]
            internal static extern void ImDrawDataBuilderClearFreeMemory(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImDrawDataBuilder_FlattenIntoSingleLayer")]
            internal static extern void ImDrawDataBuilderFlattenIntoSingleLayer(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiNavMoveResult_ImGuiNavMoveResult")]
            internal static extern global::System.IntPtr ImGuiNavMoveResultImGuiNavMoveResult();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiNavMoveResult_destroy")]
            internal static extern void ImGuiNavMoveResult_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiNavMoveResult_Clear")]
            internal static extern void ImGuiNavMoveResultClear(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiNextWindowData_ImGuiNextWindowData")]
            internal static extern global::System.IntPtr ImGuiNextWindowDataImGuiNextWindowData();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiNextWindowData_destroy")]
            internal static extern void ImGuiNextWindowData_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiNextWindowData_ClearFlags")]
            internal static extern void ImGuiNextWindowDataClearFlags(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiNextItemData_ImGuiNextItemData")]
            internal static extern global::System.IntPtr ImGuiNextItemDataImGuiNextItemData();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiNextItemData_destroy")]
            internal static extern void ImGuiNextItemData_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiNextItemData_ClearFlags")]
            internal static extern void ImGuiNextItemDataClearFlags(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiPtrOrIndex_ImGuiPtrOrIndexPtr")]
            internal static extern global::System.IntPtr ImGuiPtrOrIndexImGuiPtrOrIndexPtr(global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiPtrOrIndex_destroy")]
            internal static extern void ImGuiPtrOrIndex_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiPtrOrIndex_ImGuiPtrOrIndexInt")]
            internal static extern global::System.IntPtr ImGuiPtrOrIndexImGuiPtrOrIndexInt(int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiContext_ImGuiContext")]
            internal static extern global::System.IntPtr ImGuiContextImGuiContext(global::System.IntPtr shared_font_atlas);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiContext_destroy")]
            internal static extern void ImGuiContext_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindowTempData_ImGuiWindowTempData")]
            internal static extern global::System.IntPtr ImGuiWindowTempDataImGuiWindowTempData();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindowTempData_destroy")]
            internal static extern void ImGuiWindowTempData_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_ImGuiWindow")]
            internal static extern global::System.IntPtr ImGuiWindowImGuiWindow(global::System.IntPtr context, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_destroy")]
            internal static extern void ImGuiWindow_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_GetIDStr")]
            internal static extern uint ImGuiWindowGetIDStr(global::System.IntPtr self, [MarshalAs(UnmanagedType.LPUTF8Str)] string str, [MarshalAs(UnmanagedType.LPUTF8Str)] string str_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_GetIDPtr")]
            internal static extern uint ImGuiWindowGetIDPtr(global::System.IntPtr self, global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_GetIDInt")]
            internal static extern uint ImGuiWindowGetIDInt(global::System.IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_GetIDNoKeepAliveStr")]
            internal static extern uint ImGuiWindowGetIDNoKeepAliveStr(global::System.IntPtr self, [MarshalAs(UnmanagedType.LPUTF8Str)] string str, [MarshalAs(UnmanagedType.LPUTF8Str)] string str_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_GetIDNoKeepAlivePtr")]
            internal static extern uint ImGuiWindowGetIDNoKeepAlivePtr(global::System.IntPtr self, global::System.IntPtr ptr);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_GetIDNoKeepAliveInt")]
            internal static extern uint ImGuiWindowGetIDNoKeepAliveInt(global::System.IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_GetIDFromRectangle")]
            internal static extern uint ImGuiWindowGetIDFromRectangle(global::System.IntPtr self, global::System.IntPtr r_abs);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_Rect")]
            internal static extern void ImGuiWindowRect(global::System.IntPtr pOut, global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_CalcFontSize")]
            internal static extern float ImGuiWindowCalcFontSize(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_TitleBarHeight")]
            internal static extern float ImGuiWindowTitleBarHeight(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_TitleBarRect")]
            internal static extern void ImGuiWindowTitleBarRect(global::System.IntPtr pOut, global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_MenuBarHeight")]
            internal static extern float ImGuiWindowMenuBarHeight(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiWindow_MenuBarRect")]
            internal static extern void ImGuiWindowMenuBarRect(global::System.IntPtr pOut, global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiItemHoveredDataBackup_ImGuiItemHoveredDataBackup")]
            internal static extern global::System.IntPtr ImGuiItemHoveredDataBackupImGuiItemHoveredDataBackup();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiItemHoveredDataBackup_destroy")]
            internal static extern void ImGuiItemHoveredDataBackup_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiItemHoveredDataBackup_Backup")]
            internal static extern void ImGuiItemHoveredDataBackupBackup(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiItemHoveredDataBackup_Restore")]
            internal static extern void ImGuiItemHoveredDataBackupRestore(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTabItem_ImGuiTabItem")]
            internal static extern global::System.IntPtr ImGuiTabItemImGuiTabItem();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTabItem_destroy")]
            internal static extern void ImGuiTabItem_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTabBar_ImGuiTabBar")]
            internal static extern global::System.IntPtr ImGuiTabBarImGuiTabBar();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTabBar_destroy")]
            internal static extern void ImGuiTabBar_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTabBar_GetTabOrder")]
            internal static extern int ImGuiTabBarGetTabOrder(global::System.IntPtr self, global::System.IntPtr tab);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGuiTabBar_GetTabName")]
            internal static extern global::System.IntPtr ImGuiTabBarGetTabName(global::System.IntPtr self, global::System.IntPtr tab);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetCurrentWindowRead")]
            internal static extern global::System.IntPtr GetCurrentWindowRead();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetCurrentWindow")]
            internal static extern global::System.IntPtr GetCurrentWindow();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFindWindowByID")]
            internal static extern global::System.IntPtr FindWindowByID(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFindWindowByName")]
            internal static extern global::System.IntPtr FindWindowByName([MarshalAs(UnmanagedType.LPUTF8Str)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igUpdateWindowParentAndRootLinks")]
            internal static extern void UpdateWindowParentAndRootLinks(global::System.IntPtr window, int flags, global::System.IntPtr parent_window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCalcWindowExpectedSize")]
            internal static extern void CalcWindowExpectedSize(global::System.IntPtr pOut, global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsWindowChildOf")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsWindowChildOf(global::System.IntPtr window, global::System.IntPtr potential_parent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsWindowNavFocusable")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsWindowNavFocusable(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetWindowAllowedExtentRect")]
            internal static extern void GetWindowAllowedExtentRect(global::System.IntPtr pOut, global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowPosWindowPtr")]
            internal static extern void SetWindowPosWindowPtr(global::System.IntPtr window, global::ImGui.ImVec2.__Internal pos, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowSizeWindowPtr")]
            internal static extern void SetWindowSizeWindowPtr(global::System.IntPtr window, global::ImGui.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetWindowCollapsedWindowPtr")]
            internal static extern void SetWindowCollapsedWindowPtr(global::System.IntPtr window, bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFocusWindow")]
            internal static extern void FocusWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFocusTopMostWindowUnderOne")]
            internal static extern void FocusTopMostWindowUnderOne(global::System.IntPtr under_this_window, global::System.IntPtr ignore_window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBringWindowToFocusFront")]
            internal static extern void BringWindowToFocusFront(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBringWindowToDisplayFront")]
            internal static extern void BringWindowToDisplayFront(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBringWindowToDisplayBack")]
            internal static extern void BringWindowToDisplayBack(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetCurrentFont")]
            internal static extern void SetCurrentFont(global::System.IntPtr font);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetDefaultFont")]
            internal static extern global::System.IntPtr GetDefaultFont();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetForegroundDrawListWindowPtr")]
            internal static extern global::System.IntPtr GetForegroundDrawListWindowPtr(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInitialize")]
            internal static extern void Initialize(global::System.IntPtr context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igShutdown")]
            internal static extern void Shutdown(global::System.IntPtr context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igUpdateHoveredWindowAndCaptureFlags")]
            internal static extern void UpdateHoveredWindowAndCaptureFlags();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igStartMouseMovingWindow")]
            internal static extern void StartMouseMovingWindow(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igUpdateMouseMovingWindowNewFrame")]
            internal static extern void UpdateMouseMovingWindowNewFrame();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igUpdateMouseMovingWindowEndFrame")]
            internal static extern void UpdateMouseMovingWindowEndFrame();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igMarkIniSettingsDirtyNil")]
            internal static extern void MarkIniSettingsDirtyNil();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igMarkIniSettingsDirtyWindowPtr")]
            internal static extern void MarkIniSettingsDirtyWindowPtr(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCreateNewWindowSettings")]
            internal static extern global::System.IntPtr CreateNewWindowSettings([MarshalAs(UnmanagedType.LPUTF8Str)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFindWindowSettings")]
            internal static extern global::System.IntPtr FindWindowSettings(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFindOrCreateWindowSettings")]
            internal static extern global::System.IntPtr FindOrCreateWindowSettings([MarshalAs(UnmanagedType.LPUTF8Str)] string name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFindSettingsHandler")]
            internal static extern global::System.IntPtr FindSettingsHandler([MarshalAs(UnmanagedType.LPUTF8Str)] string type_name);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetScrollXWindowPtr")]
            internal static extern void SetScrollXWindowPtr(global::System.IntPtr window, float new_scroll_x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetScrollYWindowPtr")]
            internal static extern void SetScrollYWindowPtr(global::System.IntPtr window, float new_scroll_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetScrollFromPosXWindowPtr")]
            internal static extern void SetScrollFromPosXWindowPtr(global::System.IntPtr window, float local_x, float center_x_ratio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetScrollFromPosYWindowPtr")]
            internal static extern void SetScrollFromPosYWindowPtr(global::System.IntPtr window, float local_y, float center_y_ratio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igScrollToBringRectIntoView")]
            internal static extern void ScrollToBringRectIntoView(global::System.IntPtr pOut, global::System.IntPtr window, global::System.IntPtr item_rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetItemID")]
            internal static extern uint GetItemID();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetItemStatusFlags")]
            internal static extern int GetItemStatusFlags();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetActiveID")]
            internal static extern uint GetActiveID();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetFocusID")]
            internal static extern uint GetFocusID();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetActiveID")]
            internal static extern void SetActiveID(uint id, global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetFocusID")]
            internal static extern void SetFocusID(uint id, global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igClearActiveID")]
            internal static extern void ClearActiveID();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetHoveredID")]
            internal static extern uint GetHoveredID();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetHoveredID")]
            internal static extern void SetHoveredID(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igKeepAliveID")]
            internal static extern void KeepAliveID(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igMarkItemEdited")]
            internal static extern void MarkItemEdited(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushOverrideID")]
            internal static extern void PushOverrideID(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igItemSizeVec2")]
            internal static extern void ItemSizeVec2(global::ImGui.ImVec2.__Internal size, float text_baseline_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igItemSizeRect")]
            internal static extern void ItemSizeRect(global::System.IntPtr bb, float text_baseline_y);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igItemAdd")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ItemAdd(global::System.IntPtr bb, uint id, global::System.IntPtr nav_bb);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igItemHoverable")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ItemHoverable(global::System.IntPtr bb, uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsClippedEx")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsClippedEx(global::System.IntPtr bb, uint id, bool clip_even_when_logged);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFocusableItemRegister")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool FocusableItemRegister(global::System.IntPtr window, uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFocusableItemUnregister")]
            internal static extern void FocusableItemUnregister(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCalcItemSize")]
            internal static extern void CalcItemSize(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal size, float default_w, float default_h);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCalcWrapWidthForPos")]
            internal static extern float CalcWrapWidthForPos(global::ImGui.ImVec2.__Internal pos, float wrap_pos_x);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushMultiItemsWidths")]
            internal static extern void PushMultiItemsWidths(int components, float width_full);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushItemFlag")]
            internal static extern void PushItemFlag(int option, bool enabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopItemFlag")]
            internal static extern void PopItemFlag();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsItemToggledSelection")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsItemToggledSelection();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetContentRegionMaxAbs")]
            internal static extern void GetContentRegionMaxAbs(global::System.IntPtr pOut);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igShrinkWidths")]
            internal static extern void ShrinkWidths(global::System.IntPtr items, int count, float width_excess);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLogBegin")]
            internal static extern void LogBegin(global::ImGui.ImGuiLogType type, int auto_open_depth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLogToBuffer")]
            internal static extern void LogToBuffer(int auto_open_depth);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginChildEx")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginChildEx([MarshalAs(UnmanagedType.LPUTF8Str)] string name, uint id, global::ImGui.ImVec2.__Internal size_arg, bool border, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igOpenPopupEx")]
            internal static extern void OpenPopupEx(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igClosePopupToLevel")]
            internal static extern void ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igClosePopupsOverWindow")]
            internal static extern void ClosePopupsOverWindow(global::System.IntPtr ref_window, bool restore_focus_to_window_under_popup);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsPopupOpenID")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPopupOpenID(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginPopupEx")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginPopupEx(uint id, int extra_flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginTooltipEx")]
            internal static extern void BeginTooltipEx(int extra_flags, int tooltip_flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetTopMostPopupModal")]
            internal static extern global::System.IntPtr GetTopMostPopupModal();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFindBestWindowPosForPopup")]
            internal static extern void FindBestWindowPosForPopup(global::System.IntPtr pOut, global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFindBestWindowPosForPopupEx")]
            internal static extern void FindBestWindowPosForPopupEx(global::System.IntPtr pOut, global::ImGui.ImVec2.__Internal ref_pos, global::ImGui.ImVec2.__Internal size, int* last_dir, global::System.IntPtr r_outer, global::System.IntPtr r_avoid, global::ImGui.ImGuiPopupPositionPolicy policy);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igNavInitWindow")]
            internal static extern void NavInitWindow(global::System.IntPtr window, bool force_reinit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igNavMoveRequestButNoResultYet")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool NavMoveRequestButNoResultYet();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igNavMoveRequestCancel")]
            internal static extern void NavMoveRequestCancel();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igNavMoveRequestForward")]
            internal static extern void NavMoveRequestForward(int move_dir, int clip_dir, global::System.IntPtr bb_rel, int move_flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igNavMoveRequestTryWrapping")]
            internal static extern void NavMoveRequestTryWrapping(global::System.IntPtr window, int move_flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetNavInputAmount")]
            internal static extern float GetNavInputAmount(int n, global::ImGui.ImGuiInputReadMode mode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetNavInputAmount2d")]
            internal static extern void GetNavInputAmount2d(global::System.IntPtr pOut, int dir_sources, global::ImGui.ImGuiInputReadMode mode, float slow_factor, float fast_factor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCalcTypematicRepeatAmount")]
            internal static extern int CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igActivateItem")]
            internal static extern void ActivateItem(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetNavID")]
            internal static extern void SetNavID(uint id, int nav_layer, uint focus_scope_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSetNavIDWithRectRel")]
            internal static extern void SetNavIDWithRectRel(uint id, int nav_layer, uint focus_scope_id, global::System.IntPtr rect_rel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushFocusScope")]
            internal static extern void PushFocusScope(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopFocusScope")]
            internal static extern void PopFocusScope();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetFocusScopeID")]
            internal static extern uint GetFocusScopeID();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsActiveIdUsingNavDir")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsActiveIdUsingNavDir(int dir);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsActiveIdUsingNavInput")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsActiveIdUsingNavInput(int input);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsActiveIdUsingKey")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsActiveIdUsingKey(int key);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsMouseDragPastThreshold")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsMouseDragPastThreshold(int button, float lock_threshold);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsKeyPressedMap")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsKeyPressedMap(int key, bool repeat);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsNavInputDown")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNavInputDown(int n);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsNavInputTest")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsNavInputTest(int n, global::ImGui.ImGuiInputReadMode rm);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginDragDropTargetCustom")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginDragDropTargetCustom(global::System.IntPtr bb, uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igClearDragDrop")]
            internal static extern void ClearDragDrop();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igIsDragDropPayloadBeingAccepted")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsDragDropPayloadBeingAccepted();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginColumns")]
            internal static extern void BeginColumns([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, int count, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igEndColumns")]
            internal static extern void EndColumns();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushColumnClipRect")]
            internal static extern void PushColumnClipRect(int column_index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPushColumnsBackground")]
            internal static extern void PushColumnsBackground();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPopColumnsBackground")]
            internal static extern void PopColumnsBackground();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetColumnsID")]
            internal static extern uint GetColumnsID([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, int count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFindOrCreateColumns")]
            internal static extern global::System.IntPtr FindOrCreateColumns(global::System.IntPtr window, uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetColumnOffsetFromNorm")]
            internal static extern float GetColumnOffsetFromNorm(global::System.IntPtr columns, float offset_norm);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetColumnNormFromOffset")]
            internal static extern float GetColumnNormFromOffset(global::System.IntPtr columns, float offset);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igBeginTabBarEx")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool BeginTabBarEx(global::System.IntPtr tab_bar, global::System.IntPtr bb, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTabBarFindTabByID")]
            internal static extern global::System.IntPtr TabBarFindTabByID(global::System.IntPtr tab_bar, uint tab_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTabBarRemoveTab")]
            internal static extern void TabBarRemoveTab(global::System.IntPtr tab_bar, uint tab_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTabBarCloseTab")]
            internal static extern void TabBarCloseTab(global::System.IntPtr tab_bar, global::System.IntPtr tab);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTabBarQueueChangeTabOrder")]
            internal static extern void TabBarQueueChangeTabOrder(global::System.IntPtr tab_bar, global::System.IntPtr tab, int dir);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTabItemEx")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TabItemEx(global::System.IntPtr tab_bar, [MarshalAs(UnmanagedType.LPUTF8Str)] string label, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTabItemCalcSize")]
            internal static extern void TabItemCalcSize(global::System.IntPtr pOut, [MarshalAs(UnmanagedType.LPUTF8Str)] string label, bool has_close_button);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTabItemBackground")]
            internal static extern void TabItemBackground(global::System.IntPtr draw_list, global::System.IntPtr bb, int flags, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTabItemLabelAndCloseButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TabItemLabelAndCloseButton(global::System.IntPtr draw_list, global::System.IntPtr bb, int flags, global::ImGui.ImVec2.__Internal frame_padding, [MarshalAs(UnmanagedType.LPUTF8Str)] string label, uint tab_id, uint close_button_id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderText")]
            internal static extern void RenderText(global::ImGui.ImVec2.__Internal pos, [MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end, bool hide_text_after_hash);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderTextWrapped")]
            internal static extern void RenderTextWrapped(global::ImGui.ImVec2.__Internal pos, [MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end, float wrap_width);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderTextClipped")]
            internal static extern void RenderTextClipped(global::ImGui.ImVec2.__Internal pos_min, global::ImGui.ImVec2.__Internal pos_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end, global::System.IntPtr text_size_if_known, global::ImGui.ImVec2.__Internal align, global::System.IntPtr clip_rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderTextClippedEx")]
            internal static extern void RenderTextClippedEx(global::System.IntPtr draw_list, global::ImGui.ImVec2.__Internal pos_min, global::ImGui.ImVec2.__Internal pos_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end, global::System.IntPtr text_size_if_known, global::ImGui.ImVec2.__Internal align, global::System.IntPtr clip_rect);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderTextEllipsis")]
            internal static extern void RenderTextEllipsis(global::System.IntPtr draw_list, global::ImGui.ImVec2.__Internal pos_min, global::ImGui.ImVec2.__Internal pos_max, float clip_max_x, float ellipsis_max_x, [MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end, global::System.IntPtr text_size_if_known);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderFrame")]
            internal static extern void RenderFrame(global::ImGui.ImVec2.__Internal p_min, global::ImGui.ImVec2.__Internal p_max, uint fill_col, bool border, float rounding);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderFrameBorder")]
            internal static extern void RenderFrameBorder(global::ImGui.ImVec2.__Internal p_min, global::ImGui.ImVec2.__Internal p_max, float rounding);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderColorRectWithAlphaCheckerboard")]
            internal static extern void RenderColorRectWithAlphaCheckerboard(global::ImGui.ImVec2.__Internal p_min, global::ImGui.ImVec2.__Internal p_max, uint fill_col, float grid_step, global::ImGui.ImVec2.__Internal grid_off, float rounding, int rounding_corners_flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderCheckMark")]
            internal static extern void RenderCheckMark(global::ImGui.ImVec2.__Internal pos, uint col, float sz);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderNavHighlight")]
            internal static extern void RenderNavHighlight(global::System.IntPtr bb, uint id, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igFindRenderedTextEnd")]
            internal static extern global::System.IntPtr FindRenderedTextEnd([MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLogRenderedText")]
            internal static extern void LogRenderedText(global::System.IntPtr ref_pos, [MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderArrow")]
            internal static extern void RenderArrow(global::System.IntPtr draw_list, global::ImGui.ImVec2.__Internal pos, uint col, int dir, float scale);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderBullet")]
            internal static extern void RenderBullet(global::System.IntPtr draw_list, global::ImGui.ImVec2.__Internal pos, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderMouseCursor")]
            internal static extern void RenderMouseCursor(global::System.IntPtr draw_list, global::ImGui.ImVec2.__Internal pos, float scale, int mouse_cursor, uint col_fill, uint col_border, uint col_shadow);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderArrowPointingAt")]
            internal static extern void RenderArrowPointingAt(global::System.IntPtr draw_list, global::ImGui.ImVec2.__Internal pos, global::ImGui.ImVec2.__Internal half_sz, int direction, uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igRenderRectFilledRangeH")]
            internal static extern void RenderRectFilledRangeH(global::System.IntPtr draw_list, global::System.IntPtr rect, uint col, float x_start_norm, float x_end_norm, float rounding);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTextEx")]
            internal static extern void TextEx([MarshalAs(UnmanagedType.LPUTF8Str)] string text, [MarshalAs(UnmanagedType.LPUTF8Str)] string text_end, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igButtonEx")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ButtonEx([MarshalAs(UnmanagedType.LPUTF8Str)] string label, global::ImGui.ImVec2.__Internal size_arg, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCloseButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CloseButton(uint id, global::ImGui.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igCollapseButton")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool CollapseButton(uint id, global::ImGui.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igArrowButtonEx")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ArrowButtonEx([MarshalAs(UnmanagedType.LPUTF8Str)] string str_id, int dir, global::ImGui.ImVec2.__Internal size_arg, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igScrollbar")]
            internal static extern void Scrollbar(global::ImGui.ImGuiAxis axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igScrollbarEx")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ScrollbarEx(global::System.IntPtr bb, uint id, global::ImGui.ImGuiAxis axis, float* p_scroll_v, float avail_v, float contents_v, int rounding_corners);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetWindowScrollbarID")]
            internal static extern uint GetWindowScrollbarID(global::System.IntPtr window, global::ImGui.ImGuiAxis axis);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGetWindowResizeID")]
            internal static extern uint GetWindowResizeID(global::System.IntPtr window, int n);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSeparatorEx")]
            internal static extern void SeparatorEx(int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igButtonBehavior")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ButtonBehavior(global::System.IntPtr bb, uint id, bool* out_hovered, bool* out_held, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDragBehavior")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DragBehavior(uint id, int data_type, global::System.IntPtr p_v, float v_speed, global::System.IntPtr p_min, global::System.IntPtr p_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSliderBehavior")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SliderBehavior(global::System.IntPtr bb, uint id, int data_type, global::System.IntPtr p_v, global::System.IntPtr p_min, global::System.IntPtr p_max, [MarshalAs(UnmanagedType.LPUTF8Str)] string format, float power, int flags, global::System.IntPtr out_grab_bb);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igSplitterBehavior")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool SplitterBehavior(global::System.IntPtr bb, uint id, global::ImGui.ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreeNodeBehavior")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TreeNodeBehavior(uint id, int flags, [MarshalAs(UnmanagedType.LPUTF8Str)] string label, [MarshalAs(UnmanagedType.LPUTF8Str)] string label_end);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreeNodeBehaviorIsOpen")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TreeNodeBehaviorIsOpen(uint id, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTreePushOverrideID")]
            internal static extern void TreePushOverrideID(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDataTypeGetInfo")]
            internal static extern global::System.IntPtr DataTypeGetInfo(int data_type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDataTypeFormatString")]
            internal static extern int DataTypeFormatString(sbyte* buf, int buf_size, int data_type, global::System.IntPtr p_data, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDataTypeApplyOp")]
            internal static extern void DataTypeApplyOp(int data_type, int op, global::System.IntPtr output, global::System.IntPtr arg_1, global::System.IntPtr arg_2);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDataTypeApplyOpFromText")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool DataTypeApplyOpFromText([MarshalAs(UnmanagedType.LPUTF8Str)] string buf, [MarshalAs(UnmanagedType.LPUTF8Str)] string initial_value_buf, int data_type, global::System.IntPtr p_data, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igInputTextEx")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool InputTextEx([MarshalAs(UnmanagedType.LPUTF8Str)] string label, [MarshalAs(UnmanagedType.LPUTF8Str)] string hint, sbyte* buf, int buf_size, global::ImGui.ImVec2.__Internal size_arg, int flags, global::System.IntPtr callback, global::System.IntPtr user_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTempInputTextScalar")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TempInputTextScalar(global::System.IntPtr bb, uint id, [MarshalAs(UnmanagedType.LPUTF8Str)] string label, int data_type, global::System.IntPtr p_data, [MarshalAs(UnmanagedType.LPUTF8Str)] string format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igTempInputTextIsActive")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool TempInputTextIsActive(uint id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorTooltip")]
            internal static extern void ColorTooltip([MarshalAs(UnmanagedType.LPUTF8Str)] string text, float* col, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorEditOptionsPopup")]
            internal static extern void ColorEditOptionsPopup(float* col, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorPickerOptionsPopup")]
            internal static extern void ColorPickerOptionsPopup(float* ref_col, int flags);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igPlotEx")]
            internal static extern void PlotEx(global::ImGui.ImGuiPlotType plot_type, [MarshalAs(UnmanagedType.LPUTF8Str)] string label, global::System.IntPtr values_getter, global::System.IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.LPUTF8Str)] string overlay_text, float scale_min, float scale_max, global::ImGui.ImVec2.__Internal frame_size);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igShadeVertsLinearColorGradientKeepAlpha")]
            internal static extern void ShadeVertsLinearColorGradientKeepAlpha(global::System.IntPtr draw_list, int vert_start_idx, int vert_end_idx, global::ImGui.ImVec2.__Internal gradient_p0, global::ImGui.ImVec2.__Internal gradient_p1, uint col0, uint col1);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igShadeVertsLinearUV")]
            internal static extern void ShadeVertsLinearUV(global::System.IntPtr draw_list, int vert_start_idx, int vert_end_idx, global::ImGui.ImVec2.__Internal a, global::ImGui.ImVec2.__Internal b, global::ImGui.ImVec2.__Internal uv_a, global::ImGui.ImVec2.__Internal uv_b, bool clamp);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGcCompactTransientWindowBuffers")]
            internal static extern void GcCompactTransientWindowBuffers(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGcAwakeTransientWindowBuffers")]
            internal static extern void GcAwakeTransientWindowBuffers(global::System.IntPtr window);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDebugDrawItemRect")]
            internal static extern void DebugDrawItemRect(uint col);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igDebugStartItemPicker")]
            internal static extern void DebugStartItemPicker();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFontAtlasBuildWithStbTruetype")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImFontAtlasBuildWithStbTruetype(global::System.IntPtr atlas);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFontAtlasBuildRegisterDefaultCustomRects")]
            internal static extern void ImFontAtlasBuildRegisterDefaultCustomRects(global::System.IntPtr atlas);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFontAtlasBuildSetupFont")]
            internal static extern void ImFontAtlasBuildSetupFont(global::System.IntPtr atlas, global::System.IntPtr font, global::System.IntPtr font_config, float ascent, float descent);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFontAtlasBuildPackCustomRects")]
            internal static extern void ImFontAtlasBuildPackCustomRects(global::System.IntPtr atlas, global::System.IntPtr stbrp_context_opaque);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFontAtlasBuildFinish")]
            internal static extern void ImFontAtlasBuildFinish(global::System.IntPtr atlas);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFontAtlasBuildMultiplyCalcLookupTable")]
            internal static extern void ImFontAtlasBuildMultiplyCalcLookupTable(byte[] out_table, float in_multiply_factor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igImFontAtlasBuildMultiplyRectAlpha8")]
            internal static extern void ImFontAtlasBuildMultiplyRectAlpha8(byte[] table, byte* pixels, int x, int y, int w, int h, int stride);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igLogText")]
            internal static extern void LogText([MarshalAs(UnmanagedType.LPUTF8Str)] string fmt);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igGET_FLT_MAX")]
            internal static extern float GET_FLT_MAX();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorConvertRGBtoHSV")]
            internal static extern void ColorConvertRGBtoHSV(float r, float g, float b, float* out_h, float* out_s, float* out_v);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="igColorConvertHSVtoRGB")]
            internal static extern void ColorConvertHSVtoRGB(float h, float s, float v, float* out_r, float* out_g, float* out_b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVector_ImWchar_create")]
            internal static extern global::System.IntPtr ImVectorImWchar_create();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVector_ImWchar_destroy")]
            internal static extern void ImVectorImWchar_destroy(global::System.IntPtr self);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVector_ImWchar_Init")]
            internal static extern void ImVectorImWcharInit(global::System.IntPtr p);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImVector_ImWchar_UnInit")]
            internal static extern void ImVectorImWcharUnInit(global::System.IntPtr p);
        }

        public static global::ImGui.ImVec2 ImVec2ImVec2Nil()
        {
            var __ret = __Internal.ImVec2ImVec2Nil();
            global::ImGui.ImVec2 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImVec2.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImVec2) global::ImGui.ImVec2.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImVec2.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImVec2_destroy(global::ImGui.ImVec2 self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImVec2_destroy(__arg0);
        }

        public static global::ImGui.ImVec2 ImVec2ImVec2Float(float _x, float _y)
        {
            var __ret = __Internal.ImVec2ImVec2Float(_x, _y);
            global::ImGui.ImVec2 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImVec2.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImVec2) global::ImGui.ImVec2.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImVec2.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImVec4 ImVec4ImVec4Nil()
        {
            var __ret = __Internal.ImVec4ImVec4Nil();
            global::ImGui.ImVec4 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImVec4.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImVec4) global::ImGui.ImVec4.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImVec4.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImVec4_destroy(global::ImGui.ImVec4 self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImVec4_destroy(__arg0);
        }

        public static global::ImGui.ImVec4 ImVec4ImVec4Float(float _x, float _y, float _z, float _w)
        {
            var __ret = __Internal.ImVec4ImVec4Float(_x, _y, _z, _w);
            global::ImGui.ImVec4 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImVec4.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImVec4) global::ImGui.ImVec4.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImVec4.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiContext CreateContext(global::ImGui.ImFontAtlas shared_font_atlas)
        {
            var __arg0 = ReferenceEquals(shared_font_atlas, null) ? global::System.IntPtr.Zero : shared_font_atlas.__Instance;
            var __ret = __Internal.CreateContext(__arg0);
            global::ImGui.ImGuiContext __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiContext.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiContext) global::ImGui.ImGuiContext.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiContext.__CreateInstance(__ret);
            return __result0;
        }

        public static void DestroyContext(global::ImGui.ImGuiContext ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            __Internal.DestroyContext(__arg0);
        }

        public static global::ImGui.ImGuiContext GetCurrentContext()
        {
            var __ret = __Internal.GetCurrentContext();
            global::ImGui.ImGuiContext __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiContext.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiContext) global::ImGui.ImGuiContext.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiContext.__CreateInstance(__ret);
            return __result0;
        }

        public static void SetCurrentContext(global::ImGui.ImGuiContext ctx)
        {
            var __arg0 = ReferenceEquals(ctx, null) ? global::System.IntPtr.Zero : ctx.__Instance;
            __Internal.SetCurrentContext(__arg0);
        }

        public static bool DebugCheckVersionAndDataLayout(string version_str, ulong sz_io, ulong sz_style, ulong sz_vec2, ulong sz_vec4, ulong sz_drawvert, ulong sz_drawidx)
        {
            var __ret = __Internal.DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert, sz_drawidx);
            return __ret;
        }

        public static global::ImGui.ImGuiIO GetIO()
        {
            var __ret = __Internal.GetIO();
            global::ImGui.ImGuiIO __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiIO.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiIO) global::ImGui.ImGuiIO.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiIO.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiStyle GetStyle()
        {
            var __ret = __Internal.GetStyle();
            global::ImGui.ImGuiStyle __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiStyle.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiStyle) global::ImGui.ImGuiStyle.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiStyle.__CreateInstance(__ret);
            return __result0;
        }

        public static void NewFrame()
        {
            __Internal.NewFrame();
        }

        public static void EndFrame()
        {
            __Internal.EndFrame();
        }

        public static void Render()
        {
            __Internal.Render();
        }

        public static global::ImGui.ImDrawData GetDrawData()
        {
            var __ret = __Internal.GetDrawData();
            global::ImGui.ImDrawData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawData) global::ImGui.ImDrawData.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawData.__CreateInstance(__ret);
            return __result0;
        }

        public static void ShowDemoWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowDemoWindow(__arg0);
            }
        }

        public static void ShowAboutWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowAboutWindow(__arg0);
            }
        }

        public static void ShowMetricsWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowMetricsWindow(__arg0);
            }
        }

        public static void ShowStyleEditor(global::ImGui.ImGuiStyle @ref)
        {
            var __arg0 = ReferenceEquals(@ref, null) ? global::System.IntPtr.Zero : @ref.__Instance;
            __Internal.ShowStyleEditor(__arg0);
        }

        public static bool ShowStyleSelector(string label)
        {
            var __ret = __Internal.ShowStyleSelector(label);
            return __ret;
        }

        public static void ShowFontSelector(string label)
        {
            __Internal.ShowFontSelector(label);
        }

        public static void ShowUserGuide()
        {
            __Internal.ShowUserGuide();
        }

        public static string GetVersion()
        {
            var __ret = __Internal.GetVersion();
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static void StyleColorsDark(global::ImGui.ImGuiStyle dst)
        {
            var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsDark(__arg0);
        }

        public static void StyleColorsClassic(global::ImGui.ImGuiStyle dst)
        {
            var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsClassic(__arg0);
        }

        public static void StyleColorsLight(global::ImGui.ImGuiStyle dst)
        {
            var __arg0 = ReferenceEquals(dst, null) ? global::System.IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsLight(__arg0);
        }

        public static bool Begin(string name, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.Begin(name, __arg1, flags);
                return __ret;
            }
        }

        public static void End()
        {
            __Internal.End();
        }

        public static bool BeginChildStr(string str_id, global::ImGui.ImVec2 size, bool border, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildStr(str_id, *(global::ImGui.ImVec2.__Internal*) __arg1, border, flags);
            return __ret;
        }

        public static bool BeginChildID(uint id, global::ImGui.ImVec2 size, bool border, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildID(id, *(global::ImGui.ImVec2.__Internal*) __arg1, border, flags);
            return __ret;
        }

        public static void EndChild()
        {
            __Internal.EndChild();
        }

        public static bool IsWindowAppearing()
        {
            var __ret = __Internal.IsWindowAppearing();
            return __ret;
        }

        public static bool IsWindowCollapsed()
        {
            var __ret = __Internal.IsWindowCollapsed();
            return __ret;
        }

        public static bool IsWindowFocused(int flags)
        {
            var __ret = __Internal.IsWindowFocused(flags);
            return __ret;
        }

        public static bool IsWindowHovered(int flags)
        {
            var __ret = __Internal.IsWindowHovered(flags);
            return __ret;
        }

        public static global::ImGui.ImDrawList GetWindowDrawList()
        {
            var __ret = __Internal.GetWindowDrawList();
            global::ImGui.ImDrawList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawList) global::ImGui.ImDrawList.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawList.__CreateInstance(__ret);
            return __result0;
        }

        public static void GetWindowPos(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowPos(__arg0);
        }

        public static void GetWindowSize(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowSize(__arg0);
        }

        public static float GetWindowWidth()
        {
            var __ret = __Internal.GetWindowWidth();
            return __ret;
        }

        public static float GetWindowHeight()
        {
            var __ret = __Internal.GetWindowHeight();
            return __ret;
        }

        public static void SetNextWindowPos(global::ImGui.ImVec2 pos, int cond, global::ImGui.ImVec2 pivot)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            if (ReferenceEquals(pivot, null))
                throw new global::System.ArgumentNullException("pivot", "Cannot be null because it is passed by value.");
            var __arg2 = pivot.__Instance;
            __Internal.SetNextWindowPos(*(global::ImGui.ImVec2.__Internal*) __arg0, cond, *(global::ImGui.ImVec2.__Internal*) __arg2);
        }

        public static void SetNextWindowSize(global::ImGui.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetNextWindowSize(*(global::ImGui.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetNextWindowSizeConstraints(global::ImGui.ImVec2 size_min, global::ImGui.ImVec2 size_max, global::ImGui.ImGuiSizeCallback custom_callback, global::System.IntPtr custom_callback_data)
        {
            if (ReferenceEquals(size_min, null))
                throw new global::System.ArgumentNullException("size_min", "Cannot be null because it is passed by value.");
            var __arg0 = size_min.__Instance;
            if (ReferenceEquals(size_max, null))
                throw new global::System.ArgumentNullException("size_max", "Cannot be null because it is passed by value.");
            var __arg1 = size_max.__Instance;
            var __arg2 = custom_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(custom_callback);
            __Internal.SetNextWindowSizeConstraints(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, __arg2, custom_callback_data);
        }

        public static void SetNextWindowContentSize(global::ImGui.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetNextWindowContentSize(*(global::ImGui.ImVec2.__Internal*) __arg0);
        }

        public static void SetNextWindowCollapsed(bool collapsed, int cond)
        {
            __Internal.SetNextWindowCollapsed(collapsed, cond);
        }

        public static void SetNextWindowFocus()
        {
            __Internal.SetNextWindowFocus();
        }

        public static void SetNextWindowBgAlpha(float alpha)
        {
            __Internal.SetNextWindowBgAlpha(alpha);
        }

        public static void SetWindowPosVec2(global::ImGui.ImVec2 pos, int cond)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.SetWindowPosVec2(*(global::ImGui.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetWindowSizeVec2(global::ImGui.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetWindowSizeVec2(*(global::ImGui.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetWindowCollapsedBool(bool collapsed, int cond)
        {
            __Internal.SetWindowCollapsedBool(collapsed, cond);
        }

        public static void SetWindowFocusNil()
        {
            __Internal.SetWindowFocusNil();
        }

        public static void SetWindowFontScale(float scale)
        {
            __Internal.SetWindowFontScale(scale);
        }

        public static void SetWindowPosStr(string name, global::ImGui.ImVec2 pos, int cond)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.SetWindowPosStr(name, *(global::ImGui.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowSizeStr(string name, global::ImGui.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            __Internal.SetWindowSizeStr(name, *(global::ImGui.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowCollapsedStr(string name, bool collapsed, int cond)
        {
            __Internal.SetWindowCollapsedStr(name, collapsed, cond);
        }

        public static void SetWindowFocusStr(string name)
        {
            __Internal.SetWindowFocusStr(name);
        }

        public static void GetContentRegionMax(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetContentRegionMax(__arg0);
        }

        public static void GetContentRegionAvail(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetContentRegionAvail(__arg0);
        }

        public static void GetWindowContentRegionMin(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowContentRegionMin(__arg0);
        }

        public static void GetWindowContentRegionMax(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowContentRegionMax(__arg0);
        }

        public static float GetWindowContentRegionWidth()
        {
            var __ret = __Internal.GetWindowContentRegionWidth();
            return __ret;
        }

        public static float GetScrollX()
        {
            var __ret = __Internal.GetScrollX();
            return __ret;
        }

        public static float GetScrollY()
        {
            var __ret = __Internal.GetScrollY();
            return __ret;
        }

        public static float GetScrollMaxX()
        {
            var __ret = __Internal.GetScrollMaxX();
            return __ret;
        }

        public static float GetScrollMaxY()
        {
            var __ret = __Internal.GetScrollMaxY();
            return __ret;
        }

        public static void SetScrollXFloat(float scroll_x)
        {
            __Internal.SetScrollXFloat(scroll_x);
        }

        public static void SetScrollYFloat(float scroll_y)
        {
            __Internal.SetScrollYFloat(scroll_y);
        }

        public static void SetScrollHereX(float center_x_ratio)
        {
            __Internal.SetScrollHereX(center_x_ratio);
        }

        public static void SetScrollHereY(float center_y_ratio)
        {
            __Internal.SetScrollHereY(center_y_ratio);
        }

        public static void SetScrollFromPosXFloat(float local_x, float center_x_ratio)
        {
            __Internal.SetScrollFromPosXFloat(local_x, center_x_ratio);
        }

        public static void SetScrollFromPosYFloat(float local_y, float center_y_ratio)
        {
            __Internal.SetScrollFromPosYFloat(local_y, center_y_ratio);
        }

        public static void PushFont(global::ImGui.ImFont font)
        {
            var __arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            __Internal.PushFont(__arg0);
        }

        public static void PopFont()
        {
            __Internal.PopFont();
        }

        public static void PushStyleColorU32(int idx, uint col)
        {
            __Internal.PushStyleColorU32(idx, col);
        }

        public static void PushStyleColorVec4(int idx, global::ImGui.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg1 = col.__Instance;
            __Internal.PushStyleColorVec4(idx, __arg1);
        }

        public static void PopStyleColor(int count)
        {
            __Internal.PopStyleColor(count);
        }

        public static void PushStyleVarFloat(int idx, float val)
        {
            __Internal.PushStyleVarFloat(idx, val);
        }

        public static void PushStyleVarVec2(int idx, global::ImGui.ImVec2 val)
        {
            if (ReferenceEquals(val, null))
                throw new global::System.ArgumentNullException("val", "Cannot be null because it is passed by value.");
            var __arg1 = val.__Instance;
            __Internal.PushStyleVarVec2(idx, *(global::ImGui.ImVec2.__Internal*) __arg1);
        }

        public static void PopStyleVar(int count)
        {
            __Internal.PopStyleVar(count);
        }

        public static global::ImGui.ImVec4 GetStyleColorVec4(int idx)
        {
            var __ret = __Internal.GetStyleColorVec4(idx);
            global::ImGui.ImVec4 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImVec4.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImVec4) global::ImGui.ImVec4.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImVec4.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImFont GetFont()
        {
            var __ret = __Internal.GetFont();
            global::ImGui.ImFont __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFont.__CreateInstance(__ret);
            return __result0;
        }

        public static float GetFontSize()
        {
            var __ret = __Internal.GetFontSize();
            return __ret;
        }

        public static void GetFontTexUvWhitePixel(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetFontTexUvWhitePixel(__arg0);
        }

        public static uint GetColorU32Col(int idx, float alpha_mul)
        {
            var __ret = __Internal.GetColorU32Col(idx, alpha_mul);
            return __ret;
        }

        public static uint GetColorU32Vec4(global::ImGui.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            var __ret = __Internal.GetColorU32Vec4(__arg0);
            return __ret;
        }

        public static uint GetColorU32U32(uint col)
        {
            var __ret = __Internal.GetColorU32U32(col);
            return __ret;
        }

        public static void PushItemWidth(float item_width)
        {
            __Internal.PushItemWidth(item_width);
        }

        public static void PopItemWidth()
        {
            __Internal.PopItemWidth();
        }

        public static void SetNextItemWidth(float item_width)
        {
            __Internal.SetNextItemWidth(item_width);
        }

        public static float CalcItemWidth()
        {
            var __ret = __Internal.CalcItemWidth();
            return __ret;
        }

        public static void PushTextWrapPos(float wrap_local_pos_x)
        {
            __Internal.PushTextWrapPos(wrap_local_pos_x);
        }

        public static void PopTextWrapPos()
        {
            __Internal.PopTextWrapPos();
        }

        public static void PushAllowKeyboardFocus(bool allow_keyboard_focus)
        {
            __Internal.PushAllowKeyboardFocus(allow_keyboard_focus);
        }

        public static void PopAllowKeyboardFocus()
        {
            __Internal.PopAllowKeyboardFocus();
        }

        public static void PushButtonRepeat(bool repeat)
        {
            __Internal.PushButtonRepeat(repeat);
        }

        public static void PopButtonRepeat()
        {
            __Internal.PopButtonRepeat();
        }

        public static void Separator()
        {
            __Internal.Separator();
        }

        public static void SameLine(float offset_from_start_x, float spacing)
        {
            __Internal.SameLine(offset_from_start_x, spacing);
        }

        public static void NewLine()
        {
            __Internal.NewLine();
        }

        public static void Spacing()
        {
            __Internal.Spacing();
        }

        public static void Dummy(global::ImGui.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.Dummy(*(global::ImGui.ImVec2.__Internal*) __arg0);
        }

        public static void Indent(float indent_w)
        {
            __Internal.Indent(indent_w);
        }

        public static void Unindent(float indent_w)
        {
            __Internal.Unindent(indent_w);
        }

        public static void BeginGroup()
        {
            __Internal.BeginGroup();
        }

        public static void EndGroup()
        {
            __Internal.EndGroup();
        }

        public static void GetCursorPos(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorPos(__arg0);
        }

        public static float GetCursorPosX()
        {
            var __ret = __Internal.GetCursorPosX();
            return __ret;
        }

        public static float GetCursorPosY()
        {
            var __ret = __Internal.GetCursorPosY();
            return __ret;
        }

        public static void SetCursorPos(global::ImGui.ImVec2 local_pos)
        {
            if (ReferenceEquals(local_pos, null))
                throw new global::System.ArgumentNullException("local_pos", "Cannot be null because it is passed by value.");
            var __arg0 = local_pos.__Instance;
            __Internal.SetCursorPos(*(global::ImGui.ImVec2.__Internal*) __arg0);
        }

        public static void SetCursorPosX(float local_x)
        {
            __Internal.SetCursorPosX(local_x);
        }

        public static void SetCursorPosY(float local_y)
        {
            __Internal.SetCursorPosY(local_y);
        }

        public static void GetCursorStartPos(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorStartPos(__arg0);
        }

        public static void GetCursorScreenPos(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorScreenPos(__arg0);
        }

        public static void SetCursorScreenPos(global::ImGui.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.SetCursorScreenPos(*(global::ImGui.ImVec2.__Internal*) __arg0);
        }

        public static void AlignTextToFramePadding()
        {
            __Internal.AlignTextToFramePadding();
        }

        public static float GetTextLineHeight()
        {
            var __ret = __Internal.GetTextLineHeight();
            return __ret;
        }

        public static float GetTextLineHeightWithSpacing()
        {
            var __ret = __Internal.GetTextLineHeightWithSpacing();
            return __ret;
        }

        public static float GetFrameHeight()
        {
            var __ret = __Internal.GetFrameHeight();
            return __ret;
        }

        public static float GetFrameHeightWithSpacing()
        {
            var __ret = __Internal.GetFrameHeightWithSpacing();
            return __ret;
        }

        public static void PushIDStr(string str_id)
        {
            __Internal.PushIDStr(str_id);
        }

        public static void PushIDStrStr(string str_id_begin, string str_id_end)
        {
            __Internal.PushIDStrStr(str_id_begin, str_id_end);
        }

        public static void PushIDPtr(global::System.IntPtr ptr_id)
        {
            __Internal.PushIDPtr(ptr_id);
        }

        public static void PushIDInt(int int_id)
        {
            __Internal.PushIDInt(int_id);
        }

        public static void PopID()
        {
            __Internal.PopID();
        }

        public static uint GetIDStr(string str_id)
        {
            var __ret = __Internal.GetIDStr(str_id);
            return __ret;
        }

        public static uint GetIDStrStr(string str_id_begin, string str_id_end)
        {
            var __ret = __Internal.GetIDStrStr(str_id_begin, str_id_end);
            return __ret;
        }

        public static uint GetIDPtr(global::System.IntPtr ptr_id)
        {
            var __ret = __Internal.GetIDPtr(ptr_id);
            return __ret;
        }

        public static void TextUnformatted(string text, string text_end)
        {
            __Internal.TextUnformatted(text, text_end);
        }

        public static void Text(string fmt)
        {
            __Internal.Text(fmt);
        }

        public static void TextColored(global::ImGui.ImVec4 col, string fmt)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            __Internal.TextColored(__arg0, fmt);
        }

        public static void TextDisabled(string fmt)
        {
            __Internal.TextDisabled(fmt);
        }

        public static void TextWrapped(string fmt)
        {
            __Internal.TextWrapped(fmt);
        }

        public static void LabelText(string label, string fmt)
        {
            __Internal.LabelText(label, fmt);
        }

        public static void BulletText(string fmt)
        {
            __Internal.BulletText(fmt);
        }

        public static bool Button(string label, global::ImGui.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.Button(label, *(global::ImGui.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool SmallButton(string label)
        {
            var __ret = __Internal.SmallButton(label);
            return __ret;
        }

        public static bool InvisibleButton(string str_id, global::ImGui.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.InvisibleButton(str_id, *(global::ImGui.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool ArrowButton(string str_id, int dir)
        {
            var __ret = __Internal.ArrowButton(str_id, dir);
            return __ret;
        }

        public static void Image(global::System.IntPtr user_texture_id, global::ImGui.ImVec2 size, global::ImGui.ImVec2 uv0, global::ImGui.ImVec2 uv1, global::ImGui.ImVec4 tint_col, global::ImGui.ImVec4 border_col)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(uv0, null))
                throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is passed by value.");
            var __arg2 = uv0.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg3 = uv1.__Instance;
            if (ReferenceEquals(tint_col, null))
                throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is passed by value.");
            var __arg4 = tint_col.__Instance;
            if (ReferenceEquals(border_col, null))
                throw new global::System.ArgumentNullException("border_col", "Cannot be null because it is passed by value.");
            var __arg5 = border_col.__Instance;
            __Internal.Image(user_texture_id, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, __arg4, __arg5);
        }

        public static bool ImageButton(global::System.IntPtr user_texture_id, global::ImGui.ImVec2 size, global::ImGui.ImVec2 uv0, global::ImGui.ImVec2 uv1, int frame_padding, global::ImGui.ImVec4 bg_col, global::ImGui.ImVec4 tint_col)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(uv0, null))
                throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is passed by value.");
            var __arg2 = uv0.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg3 = uv1.__Instance;
            if (ReferenceEquals(bg_col, null))
                throw new global::System.ArgumentNullException("bg_col", "Cannot be null because it is passed by value.");
            var __arg5 = bg_col.__Instance;
            if (ReferenceEquals(tint_col, null))
                throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is passed by value.");
            var __arg6 = tint_col.__Instance;
            var __ret = __Internal.ImageButton(user_texture_id, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, frame_padding, __arg5, __arg6);
            return __ret;
        }

        public static bool Checkbox(string label, ref bool v)
        {
            fixed (bool* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.Checkbox(label, __arg1);
                return __ret;
            }
        }

        public static bool CheckboxFlags(string label, ref uint flags, uint flags_value)
        {
            fixed (uint* __flags1 = &flags)
            {
                var __arg1 = __flags1;
                var __ret = __Internal.CheckboxFlags(label, __arg1, flags_value);
                return __ret;
            }
        }

        public static bool RadioButtonBool(string label, bool active)
        {
            var __ret = __Internal.RadioButtonBool(label, active);
            return __ret;
        }

        public static bool RadioButtonIntPtr(string label, ref int v, int v_button)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.RadioButtonIntPtr(label, __arg1, v_button);
                return __ret;
            }
        }

        public static void ProgressBar(float fraction, global::ImGui.ImVec2 size_arg, string overlay)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg1 = size_arg.__Instance;
            __Internal.ProgressBar(fraction, *(global::ImGui.ImVec2.__Internal*) __arg1, overlay);
        }

        public static void Bullet()
        {
            __Internal.Bullet();
        }

        public static bool BeginCombo(string label, string preview_value, int flags)
        {
            var __ret = __Internal.BeginCombo(label, preview_value, flags);
            return __ret;
        }

        public static void EndCombo()
        {
            __Internal.EndCombo();
        }

        public static bool ComboStr_arr(string label, ref int current_item, string[] items, int items_count, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ComboStr_arr(label, __arg1, items, items_count, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool ComboStr(string label, ref int current_item, string items_separated_by_zeros, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ComboStr(label, __arg1, items_separated_by_zeros, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool ComboFnPtr(string label, ref int current_item, global::ImGui.Delegates.Func_bool_IntPtr_int_sbytePtrPtr items_getter, global::System.IntPtr data, int items_count, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __arg2 = items_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(items_getter);
                var __ret = __Internal.ComboFnPtr(label, __arg1, __arg2, data, items_count, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool DragFloat(string label, ref float v, float v_speed, float v_min, float v_max, string format, float power)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.DragFloat(label, __arg1, v_speed, v_min, v_max, format, power);
                return __ret;
            }
        }

        public static bool DragFloat2(string label, float[] v, float v_speed, float v_min, float v_max, string format, float power)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat2(label, v, v_speed, v_min, v_max, format, power);
            return __ret;
        }

        public static bool DragFloat3(string label, float[] v, float v_speed, float v_min, float v_max, string format, float power)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat3(label, v, v_speed, v_min, v_max, format, power);
            return __ret;
        }

        public static bool DragFloat4(string label, float[] v, float v_speed, float v_min, float v_max, string format, float power)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat4(label, v, v_speed, v_min, v_max, format, power);
            return __ret;
        }

        public static bool DragFloatRange2(string label, ref float v_current_min, ref float v_current_max, float v_speed, float v_min, float v_max, string format, string format_max, float power)
        {
            fixed (float* __v_current_min1 = &v_current_min)
            {
                var __arg1 = __v_current_min1;
                fixed (float* __v_current_max2 = &v_current_max)
                {
                    var __arg2 = __v_current_max2;
                    var __ret = __Internal.DragFloatRange2(label, __arg1, __arg2, v_speed, v_min, v_max, format, format_max, power);
                    return __ret;
                }
            }
        }

        public static bool DragInt(string label, ref int v, float v_speed, int v_min, int v_max, string format)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.DragInt(label, __arg1, v_speed, v_min, v_max, format);
                return __ret;
            }
        }

        public static bool DragInt2(string label, int[] v, float v_speed, int v_min, int v_max, string format)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt2(label, v, v_speed, v_min, v_max, format);
            return __ret;
        }

        public static bool DragInt3(string label, int[] v, float v_speed, int v_min, int v_max, string format)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt3(label, v, v_speed, v_min, v_max, format);
            return __ret;
        }

        public static bool DragInt4(string label, int[] v, float v_speed, int v_min, int v_max, string format)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt4(label, v, v_speed, v_min, v_max, format);
            return __ret;
        }

        public static bool DragIntRange2(string label, ref int v_current_min, ref int v_current_max, float v_speed, int v_min, int v_max, string format, string format_max)
        {
            fixed (int* __v_current_min1 = &v_current_min)
            {
                var __arg1 = __v_current_min1;
                fixed (int* __v_current_max2 = &v_current_max)
                {
                    var __arg2 = __v_current_max2;
                    var __ret = __Internal.DragIntRange2(label, __arg1, __arg2, v_speed, v_min, v_max, format, format_max);
                    return __ret;
                }
            }
        }

        public static bool DragScalar(string label, int data_type, global::System.IntPtr p_data, float v_speed, global::System.IntPtr p_min, global::System.IntPtr p_max, string format, float power)
        {
            var __ret = __Internal.DragScalar(label, data_type, p_data, v_speed, p_min, p_max, format, power);
            return __ret;
        }

        public static bool DragScalarN(string label, int data_type, global::System.IntPtr p_data, int components, float v_speed, global::System.IntPtr p_min, global::System.IntPtr p_max, string format, float power)
        {
            var __ret = __Internal.DragScalarN(label, data_type, p_data, components, v_speed, p_min, p_max, format, power);
            return __ret;
        }

        public static bool SliderFloat(string label, ref float v, float v_min, float v_max, string format, float power)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.SliderFloat(label, __arg1, v_min, v_max, format, power);
                return __ret;
            }
        }

        public static bool SliderFloat2(string label, float[] v, float v_min, float v_max, string format, float power)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat2(label, v, v_min, v_max, format, power);
            return __ret;
        }

        public static bool SliderFloat3(string label, float[] v, float v_min, float v_max, string format, float power)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat3(label, v, v_min, v_max, format, power);
            return __ret;
        }

        public static bool SliderFloat4(string label, float[] v, float v_min, float v_max, string format, float power)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat4(label, v, v_min, v_max, format, power);
            return __ret;
        }

        public static bool SliderAngle(string label, ref float v_rad, float v_degrees_min, float v_degrees_max, string format)
        {
            fixed (float* __v_rad1 = &v_rad)
            {
                var __arg1 = __v_rad1;
                var __ret = __Internal.SliderAngle(label, __arg1, v_degrees_min, v_degrees_max, format);
                return __ret;
            }
        }

        public static bool SliderInt(string label, ref int v, int v_min, int v_max, string format)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.SliderInt(label, __arg1, v_min, v_max, format);
                return __ret;
            }
        }

        public static bool SliderInt2(string label, int[] v, int v_min, int v_max, string format)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt2(label, v, v_min, v_max, format);
            return __ret;
        }

        public static bool SliderInt3(string label, int[] v, int v_min, int v_max, string format)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt3(label, v, v_min, v_max, format);
            return __ret;
        }

        public static bool SliderInt4(string label, int[] v, int v_min, int v_max, string format)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt4(label, v, v_min, v_max, format);
            return __ret;
        }

        public static bool SliderScalar(string label, int data_type, global::System.IntPtr p_data, global::System.IntPtr p_min, global::System.IntPtr p_max, string format, float power)
        {
            var __ret = __Internal.SliderScalar(label, data_type, p_data, p_min, p_max, format, power);
            return __ret;
        }

        public static bool SliderScalarN(string label, int data_type, global::System.IntPtr p_data, int components, global::System.IntPtr p_min, global::System.IntPtr p_max, string format, float power)
        {
            var __ret = __Internal.SliderScalarN(label, data_type, p_data, components, p_min, p_max, format, power);
            return __ret;
        }

        public static bool VSliderFloat(string label, global::ImGui.ImVec2 size, ref float v, float v_min, float v_max, string format, float power)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            fixed (float* __v2 = &v)
            {
                var __arg2 = __v2;
                var __ret = __Internal.VSliderFloat(label, *(global::ImGui.ImVec2.__Internal*) __arg1, __arg2, v_min, v_max, format, power);
                return __ret;
            }
        }

        public static bool VSliderInt(string label, global::ImGui.ImVec2 size, ref int v, int v_min, int v_max, string format)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            fixed (int* __v2 = &v)
            {
                var __arg2 = __v2;
                var __ret = __Internal.VSliderInt(label, *(global::ImGui.ImVec2.__Internal*) __arg1, __arg2, v_min, v_max, format);
                return __ret;
            }
        }

        public static bool VSliderScalar(string label, global::ImGui.ImVec2 size, int data_type, global::System.IntPtr p_data, global::System.IntPtr p_min, global::System.IntPtr p_max, string format, float power)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.VSliderScalar(label, *(global::ImGui.ImVec2.__Internal*) __arg1, data_type, p_data, p_min, p_max, format, power);
            return __ret;
        }

        public static bool InputText(string label, sbyte* buf, ulong buf_size, int flags, global::ImGui.ImGuiInputTextCallback callback, global::System.IntPtr user_data)
        {
            var __arg4 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputText(label, buf, buf_size, flags, __arg4, user_data);
            return __ret;
        }

        public static bool InputTextMultiline(string label, sbyte* buf, ulong buf_size, global::ImGui.ImVec2 size, int flags, global::ImGui.ImGuiInputTextCallback callback, global::System.IntPtr user_data)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __arg5 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputTextMultiline(label, buf, buf_size, *(global::ImGui.ImVec2.__Internal*) __arg3, flags, __arg5, user_data);
            return __ret;
        }

        public static bool InputTextWithHint(string label, string hint, sbyte* buf, ulong buf_size, int flags, global::ImGui.ImGuiInputTextCallback callback, global::System.IntPtr user_data)
        {
            var __arg5 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputTextWithHint(label, hint, buf, buf_size, flags, __arg5, user_data);
            return __ret;
        }

        public static bool InputFloat(string label, ref float v, float step, float step_fast, string format, int flags)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputFloat(label, __arg1, step, step_fast, format, flags);
                return __ret;
            }
        }

        public static bool InputFloat2(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat2(label, v, format, flags);
            return __ret;
        }

        public static bool InputFloat3(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat3(label, v, format, flags);
            return __ret;
        }

        public static bool InputFloat4(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat4(label, v, format, flags);
            return __ret;
        }

        public static bool InputInt(string label, ref int v, int step, int step_fast, int flags)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputInt(label, __arg1, step, step_fast, flags);
                return __ret;
            }
        }

        public static bool InputInt2(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt2(label, v, flags);
            return __ret;
        }

        public static bool InputInt3(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt3(label, v, flags);
            return __ret;
        }

        public static bool InputInt4(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt4(label, v, flags);
            return __ret;
        }

        public static bool InputDouble(string label, ref double v, double step, double step_fast, string format, int flags)
        {
            fixed (double* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputDouble(label, __arg1, step, step_fast, format, flags);
                return __ret;
            }
        }

        public static bool InputScalar(string label, int data_type, global::System.IntPtr p_data, global::System.IntPtr p_step, global::System.IntPtr p_step_fast, string format, int flags)
        {
            var __ret = __Internal.InputScalar(label, data_type, p_data, p_step, p_step_fast, format, flags);
            return __ret;
        }

        public static bool InputScalarN(string label, int data_type, global::System.IntPtr p_data, int components, global::System.IntPtr p_step, global::System.IntPtr p_step_fast, string format, int flags)
        {
            var __ret = __Internal.InputScalarN(label, data_type, p_data, components, p_step, p_step_fast, format, flags);
            return __ret;
        }

        public static bool ColorEdit3(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 3)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorEdit3(label, col, flags);
            return __ret;
        }

        public static bool ColorEdit4(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 4)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorEdit4(label, col, flags);
            return __ret;
        }

        public static bool ColorPicker3(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 3)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorPicker3(label, col, flags);
            return __ret;
        }

        public static bool ColorPicker4(string label, float[] col, int flags, ref float ref_col)
        {
            if (col == null || col.Length != 4)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            fixed (float* __ref_col3 = &ref_col)
            {
                var __arg3 = __ref_col3;
                var __ret = __Internal.ColorPicker4(label, col, flags, __arg3);
                return __ret;
            }
        }

        public static bool ColorButton(string desc_id, global::ImGui.ImVec4 col, int flags, global::ImGui.ImVec2 size)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg1 = col.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __ret = __Internal.ColorButton(desc_id, __arg1, flags, *(global::ImGui.ImVec2.__Internal*) __arg3);
            return __ret;
        }

        public static void SetColorEditOptions(int flags)
        {
            __Internal.SetColorEditOptions(flags);
        }

        public static bool TreeNodeStr(string label)
        {
            var __ret = __Internal.TreeNodeStr(label);
            return __ret;
        }

        public static bool TreeNodeStrStr(string str_id, string fmt)
        {
            var __ret = __Internal.TreeNodeStrStr(str_id, fmt);
            return __ret;
        }

        public static bool TreeNodePtr(global::System.IntPtr ptr_id, string fmt)
        {
            var __ret = __Internal.TreeNodePtr(ptr_id, fmt);
            return __ret;
        }

        public static bool TreeNodeExStr(string label, int flags)
        {
            var __ret = __Internal.TreeNodeExStr(label, flags);
            return __ret;
        }

        public static bool TreeNodeExStrStr(string str_id, int flags, string fmt)
        {
            var __ret = __Internal.TreeNodeExStrStr(str_id, flags, fmt);
            return __ret;
        }

        public static bool TreeNodeExPtr(global::System.IntPtr ptr_id, int flags, string fmt)
        {
            var __ret = __Internal.TreeNodeExPtr(ptr_id, flags, fmt);
            return __ret;
        }

        public static void TreePushStr(string str_id)
        {
            __Internal.TreePushStr(str_id);
        }

        public static void TreePushPtr(global::System.IntPtr ptr_id)
        {
            __Internal.TreePushPtr(ptr_id);
        }

        public static void TreePop()
        {
            __Internal.TreePop();
        }

        public static float GetTreeNodeToLabelSpacing()
        {
            var __ret = __Internal.GetTreeNodeToLabelSpacing();
            return __ret;
        }

        public static bool CollapsingHeaderTreeNodeFlags(string label, int flags)
        {
            var __ret = __Internal.CollapsingHeaderTreeNodeFlags(label, flags);
            return __ret;
        }

        public static bool CollapsingHeaderBoolPtr(string label, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.CollapsingHeaderBoolPtr(label, __arg1, flags);
                return __ret;
            }
        }

        public static void SetNextItemOpen(bool is_open, int cond)
        {
            __Internal.SetNextItemOpen(is_open, cond);
        }

        public static bool SelectableBool(string label, bool selected, int flags, global::ImGui.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __ret = __Internal.SelectableBool(label, selected, flags, *(global::ImGui.ImVec2.__Internal*) __arg3);
            return __ret;
        }

        public static bool SelectableBoolPtr(string label, ref bool p_selected, int flags, global::ImGui.ImVec2 size)
        {
            fixed (bool* __p_selected1 = &p_selected)
            {
                var __arg1 = __p_selected1;
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
                var __arg3 = size.__Instance;
                var __ret = __Internal.SelectableBoolPtr(label, __arg1, flags, *(global::ImGui.ImVec2.__Internal*) __arg3);
                return __ret;
            }
        }

        public static bool ListBoxStr_arr(string label, ref int current_item, string[] items, int items_count, int height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ListBoxStr_arr(label, __arg1, items, items_count, height_in_items);
                return __ret;
            }
        }

        public static bool ListBoxFnPtr(string label, ref int current_item, global::ImGui.Delegates.Func_bool_IntPtr_int_sbytePtrPtr items_getter, global::System.IntPtr data, int items_count, int height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __arg2 = items_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(items_getter);
                var __ret = __Internal.ListBoxFnPtr(label, __arg1, __arg2, data, items_count, height_in_items);
                return __ret;
            }
        }

        public static bool ListBoxHeaderVec2(string label, global::ImGui.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.ListBoxHeaderVec2(label, *(global::ImGui.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool ListBoxHeaderInt(string label, int items_count, int height_in_items)
        {
            var __ret = __Internal.ListBoxHeaderInt(label, items_count, height_in_items);
            return __ret;
        }

        public static void ListBoxFooter()
        {
            __Internal.ListBoxFooter();
        }

        public static void PlotLinesFloatPtr(string label, ref float values, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::ImGui.ImVec2 graph_size, int stride)
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (ReferenceEquals(graph_size, null))
                    throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                var __arg7 = graph_size.__Instance;
                __Internal.PlotLinesFloatPtr(label, __arg1, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::ImGui.ImVec2.__Internal*) __arg7, stride);
            }
        }

        public static void PlotLinesFnPtr(string label, global::ImGui.Delegates.Func_float_IntPtr_int values_getter, global::System.IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::ImGui.ImVec2 graph_size)
        {
            var __arg1 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
            if (ReferenceEquals(graph_size, null))
                throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
            var __arg8 = graph_size.__Instance;
            __Internal.PlotLinesFnPtr(label, __arg1, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::ImGui.ImVec2.__Internal*) __arg8);
        }

        public static void PlotHistogramFloatPtr(string label, ref float values, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::ImGui.ImVec2 graph_size, int stride)
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (ReferenceEquals(graph_size, null))
                    throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                var __arg7 = graph_size.__Instance;
                __Internal.PlotHistogramFloatPtr(label, __arg1, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::ImGui.ImVec2.__Internal*) __arg7, stride);
            }
        }

        public static void PlotHistogramFnPtr(string label, global::ImGui.Delegates.Func_float_IntPtr_int values_getter, global::System.IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::ImGui.ImVec2 graph_size)
        {
            var __arg1 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
            if (ReferenceEquals(graph_size, null))
                throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
            var __arg8 = graph_size.__Instance;
            __Internal.PlotHistogramFnPtr(label, __arg1, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::ImGui.ImVec2.__Internal*) __arg8);
        }

        public static void ValueBool(string prefix, bool b)
        {
            __Internal.ValueBool(prefix, b);
        }

        public static void ValueInt(string prefix, int v)
        {
            __Internal.ValueInt(prefix, v);
        }

        public static void ValueUint(string prefix, uint v)
        {
            __Internal.ValueUint(prefix, v);
        }

        public static void ValueFloat(string prefix, float v, string float_format)
        {
            __Internal.ValueFloat(prefix, v, float_format);
        }

        public static bool BeginMenuBar()
        {
            var __ret = __Internal.BeginMenuBar();
            return __ret;
        }

        public static void EndMenuBar()
        {
            __Internal.EndMenuBar();
        }

        public static bool BeginMainMenuBar()
        {
            var __ret = __Internal.BeginMainMenuBar();
            return __ret;
        }

        public static void EndMainMenuBar()
        {
            __Internal.EndMainMenuBar();
        }

        public static bool BeginMenu(string label, bool enabled)
        {
            var __ret = __Internal.BeginMenu(label, enabled);
            return __ret;
        }

        public static void EndMenu()
        {
            __Internal.EndMenu();
        }

        public static bool MenuItemBool(string label, string shortcut, bool selected, bool enabled)
        {
            var __ret = __Internal.MenuItemBool(label, shortcut, selected, enabled);
            return __ret;
        }

        public static bool MenuItemBoolPtr(string label, string shortcut, ref bool p_selected, bool enabled)
        {
            fixed (bool* __p_selected2 = &p_selected)
            {
                var __arg2 = __p_selected2;
                var __ret = __Internal.MenuItemBoolPtr(label, shortcut, __arg2, enabled);
                return __ret;
            }
        }

        public static void BeginTooltip()
        {
            __Internal.BeginTooltip();
        }

        public static void EndTooltip()
        {
            __Internal.EndTooltip();
        }

        public static void SetTooltip(string fmt)
        {
            __Internal.SetTooltip(fmt);
        }

        public static void OpenPopup(string str_id)
        {
            __Internal.OpenPopup(str_id);
        }

        public static bool BeginPopup(string str_id, int flags)
        {
            var __ret = __Internal.BeginPopup(str_id, flags);
            return __ret;
        }

        public static bool BeginPopupContextItem(string str_id, int mouse_button)
        {
            var __ret = __Internal.BeginPopupContextItem(str_id, mouse_button);
            return __ret;
        }

        public static bool BeginPopupContextWindow(string str_id, int mouse_button, bool also_over_items)
        {
            var __ret = __Internal.BeginPopupContextWindow(str_id, mouse_button, also_over_items);
            return __ret;
        }

        public static bool BeginPopupContextVoid(string str_id, int mouse_button)
        {
            var __ret = __Internal.BeginPopupContextVoid(str_id, mouse_button);
            return __ret;
        }

        public static bool BeginPopupModal(string name, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.BeginPopupModal(name, __arg1, flags);
                return __ret;
            }
        }

        public static void EndPopup()
        {
            __Internal.EndPopup();
        }

        public static bool OpenPopupOnItemClick(string str_id, int mouse_button)
        {
            var __ret = __Internal.OpenPopupOnItemClick(str_id, mouse_button);
            return __ret;
        }

        public static bool IsPopupOpenStr(string str_id)
        {
            var __ret = __Internal.IsPopupOpenStr(str_id);
            return __ret;
        }

        public static void CloseCurrentPopup()
        {
            __Internal.CloseCurrentPopup();
        }

        public static void Columns(int count, string id, bool border)
        {
            __Internal.Columns(count, id, border);
        }

        public static void NextColumn()
        {
            __Internal.NextColumn();
        }

        public static int GetColumnIndex()
        {
            var __ret = __Internal.GetColumnIndex();
            return __ret;
        }

        public static float GetColumnWidth(int column_index)
        {
            var __ret = __Internal.GetColumnWidth(column_index);
            return __ret;
        }

        public static void SetColumnWidth(int column_index, float width)
        {
            __Internal.SetColumnWidth(column_index, width);
        }

        public static float GetColumnOffset(int column_index)
        {
            var __ret = __Internal.GetColumnOffset(column_index);
            return __ret;
        }

        public static void SetColumnOffset(int column_index, float offset_x)
        {
            __Internal.SetColumnOffset(column_index, offset_x);
        }

        public static int GetColumnsCount()
        {
            var __ret = __Internal.GetColumnsCount();
            return __ret;
        }

        public static bool BeginTabBar(string str_id, int flags)
        {
            var __ret = __Internal.BeginTabBar(str_id, flags);
            return __ret;
        }

        public static void EndTabBar()
        {
            __Internal.EndTabBar();
        }

        public static bool BeginTabItem(string label, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.BeginTabItem(label, __arg1, flags);
                return __ret;
            }
        }

        public static void EndTabItem()
        {
            __Internal.EndTabItem();
        }

        public static void SetTabItemClosed(string tab_or_docked_window_label)
        {
            __Internal.SetTabItemClosed(tab_or_docked_window_label);
        }

        public static void LogToTTY(int auto_open_depth)
        {
            __Internal.LogToTTY(auto_open_depth);
        }

        public static void LogToFile(int auto_open_depth, string filename)
        {
            __Internal.LogToFile(auto_open_depth, filename);
        }

        public static void LogToClipboard(int auto_open_depth)
        {
            __Internal.LogToClipboard(auto_open_depth);
        }

        public static void LogFinish()
        {
            __Internal.LogFinish();
        }

        public static void LogButtons()
        {
            __Internal.LogButtons();
        }

        public static bool BeginDragDropSource(int flags)
        {
            var __ret = __Internal.BeginDragDropSource(flags);
            return __ret;
        }

        public static bool SetDragDropPayload(string type, global::System.IntPtr data, ulong sz, int cond)
        {
            var __ret = __Internal.SetDragDropPayload(type, data, sz, cond);
            return __ret;
        }

        public static void EndDragDropSource()
        {
            __Internal.EndDragDropSource();
        }

        public static bool BeginDragDropTarget()
        {
            var __ret = __Internal.BeginDragDropTarget();
            return __ret;
        }

        public static global::ImGui.ImGuiPayload AcceptDragDropPayload(string type, int flags)
        {
            var __ret = __Internal.AcceptDragDropPayload(type, flags);
            global::ImGui.ImGuiPayload __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiPayload.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiPayload) global::ImGui.ImGuiPayload.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiPayload.__CreateInstance(__ret);
            return __result0;
        }

        public static void EndDragDropTarget()
        {
            __Internal.EndDragDropTarget();
        }

        public static global::ImGui.ImGuiPayload GetDragDropPayload()
        {
            var __ret = __Internal.GetDragDropPayload();
            global::ImGui.ImGuiPayload __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiPayload.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiPayload) global::ImGui.ImGuiPayload.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiPayload.__CreateInstance(__ret);
            return __result0;
        }

        public static void PushClipRect(global::ImGui.ImVec2 clip_rect_min, global::ImGui.ImVec2 clip_rect_max, bool intersect_with_current_clip_rect)
        {
            if (ReferenceEquals(clip_rect_min, null))
                throw new global::System.ArgumentNullException("clip_rect_min", "Cannot be null because it is passed by value.");
            var __arg0 = clip_rect_min.__Instance;
            if (ReferenceEquals(clip_rect_max, null))
                throw new global::System.ArgumentNullException("clip_rect_max", "Cannot be null because it is passed by value.");
            var __arg1 = clip_rect_max.__Instance;
            __Internal.PushClipRect(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, intersect_with_current_clip_rect);
        }

        public static void PopClipRect()
        {
            __Internal.PopClipRect();
        }

        public static void SetItemDefaultFocus()
        {
            __Internal.SetItemDefaultFocus();
        }

        public static void SetKeyboardFocusHere(int offset)
        {
            __Internal.SetKeyboardFocusHere(offset);
        }

        public static bool IsItemHovered(int flags)
        {
            var __ret = __Internal.IsItemHovered(flags);
            return __ret;
        }

        public static bool IsItemActive()
        {
            var __ret = __Internal.IsItemActive();
            return __ret;
        }

        public static bool IsItemFocused()
        {
            var __ret = __Internal.IsItemFocused();
            return __ret;
        }

        public static bool IsItemClicked(int mouse_button)
        {
            var __ret = __Internal.IsItemClicked(mouse_button);
            return __ret;
        }

        public static bool IsItemVisible()
        {
            var __ret = __Internal.IsItemVisible();
            return __ret;
        }

        public static bool IsItemEdited()
        {
            var __ret = __Internal.IsItemEdited();
            return __ret;
        }

        public static bool IsItemActivated()
        {
            var __ret = __Internal.IsItemActivated();
            return __ret;
        }

        public static bool IsItemDeactivated()
        {
            var __ret = __Internal.IsItemDeactivated();
            return __ret;
        }

        public static bool IsItemDeactivatedAfterEdit()
        {
            var __ret = __Internal.IsItemDeactivatedAfterEdit();
            return __ret;
        }

        public static bool IsItemToggledOpen()
        {
            var __ret = __Internal.IsItemToggledOpen();
            return __ret;
        }

        public static bool IsAnyItemHovered()
        {
            var __ret = __Internal.IsAnyItemHovered();
            return __ret;
        }

        public static bool IsAnyItemActive()
        {
            var __ret = __Internal.IsAnyItemActive();
            return __ret;
        }

        public static bool IsAnyItemFocused()
        {
            var __ret = __Internal.IsAnyItemFocused();
            return __ret;
        }

        public static void GetItemRectMin(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectMin(__arg0);
        }

        public static void GetItemRectMax(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectMax(__arg0);
        }

        public static void GetItemRectSize(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectSize(__arg0);
        }

        public static void SetItemAllowOverlap()
        {
            __Internal.SetItemAllowOverlap();
        }

        public static bool IsRectVisibleNil(global::ImGui.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            var __ret = __Internal.IsRectVisibleNil(*(global::ImGui.ImVec2.__Internal*) __arg0);
            return __ret;
        }

        public static bool IsRectVisibleVec2(global::ImGui.ImVec2 rect_min, global::ImGui.ImVec2 rect_max)
        {
            if (ReferenceEquals(rect_min, null))
                throw new global::System.ArgumentNullException("rect_min", "Cannot be null because it is passed by value.");
            var __arg0 = rect_min.__Instance;
            if (ReferenceEquals(rect_max, null))
                throw new global::System.ArgumentNullException("rect_max", "Cannot be null because it is passed by value.");
            var __arg1 = rect_max.__Instance;
            var __ret = __Internal.IsRectVisibleVec2(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static double GetTime()
        {
            var __ret = __Internal.GetTime();
            return __ret;
        }

        public static int GetFrameCount()
        {
            var __ret = __Internal.GetFrameCount();
            return __ret;
        }

        public static global::ImGui.ImDrawList GetBackgroundDrawList()
        {
            var __ret = __Internal.GetBackgroundDrawList();
            global::ImGui.ImDrawList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawList) global::ImGui.ImDrawList.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawList.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImDrawList GetForegroundDrawListNil()
        {
            var __ret = __Internal.GetForegroundDrawListNil();
            global::ImGui.ImDrawList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawList) global::ImGui.ImDrawList.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawList.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImDrawListSharedData GetDrawListSharedData()
        {
            var __ret = __Internal.GetDrawListSharedData();
            global::ImGui.ImDrawListSharedData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawListSharedData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawListSharedData) global::ImGui.ImDrawListSharedData.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawListSharedData.__CreateInstance(__ret);
            return __result0;
        }

        public static string GetStyleColorName(int idx)
        {
            var __ret = __Internal.GetStyleColorName(idx);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static void SetStateStorage(global::ImGui.ImGuiStorage storage)
        {
            var __arg0 = ReferenceEquals(storage, null) ? global::System.IntPtr.Zero : storage.__Instance;
            __Internal.SetStateStorage(__arg0);
        }

        public static global::ImGui.ImGuiStorage GetStateStorage()
        {
            var __ret = __Internal.GetStateStorage();
            global::ImGui.ImGuiStorage __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiStorage.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiStorage) global::ImGui.ImGuiStorage.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiStorage.__CreateInstance(__ret);
            return __result0;
        }

        public static void CalcTextSize(global::ImGui.ImVec2 pOut, string text, string text_end, bool hide_text_after_double_hash, float wrap_width)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.CalcTextSize(__arg0, text, text_end, hide_text_after_double_hash, wrap_width);
        }

        public static void CalcListClipping(int items_count, float items_height, ref int out_items_display_start, ref int out_items_display_end)
        {
            fixed (int* __out_items_display_start2 = &out_items_display_start)
            {
                var __arg2 = __out_items_display_start2;
                fixed (int* __out_items_display_end3 = &out_items_display_end)
                {
                    var __arg3 = __out_items_display_end3;
                    __Internal.CalcListClipping(items_count, items_height, __arg2, __arg3);
                }
            }
        }

        public static bool BeginChildFrame(uint id, global::ImGui.ImVec2 size, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildFrame(id, *(global::ImGui.ImVec2.__Internal*) __arg1, flags);
            return __ret;
        }

        public static void EndChildFrame()
        {
            __Internal.EndChildFrame();
        }

        public static void ColorConvertU32ToFloat4(global::ImGui.ImVec4 pOut, uint @in)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.ColorConvertU32ToFloat4(__arg0, @in);
        }

        public static uint ColorConvertFloat4ToU32(global::ImGui.ImVec4 @in)
        {
            if (ReferenceEquals(@in, null))
                throw new global::System.ArgumentNullException("@in", "Cannot be null because it is passed by value.");
            var __arg0 = @in.__Instance;
            var __ret = __Internal.ColorConvertFloat4ToU32(__arg0);
            return __ret;
        }

        public static int GetKeyIndex(int imgui_key)
        {
            var __ret = __Internal.GetKeyIndex(imgui_key);
            return __ret;
        }

        public static bool IsKeyDown(int user_key_index)
        {
            var __ret = __Internal.IsKeyDown(user_key_index);
            return __ret;
        }

        public static bool IsKeyPressed(int user_key_index, bool repeat)
        {
            var __ret = __Internal.IsKeyPressed(user_key_index, repeat);
            return __ret;
        }

        public static bool IsKeyReleased(int user_key_index)
        {
            var __ret = __Internal.IsKeyReleased(user_key_index);
            return __ret;
        }

        public static int GetKeyPressedAmount(int key_index, float repeat_delay, float rate)
        {
            var __ret = __Internal.GetKeyPressedAmount(key_index, repeat_delay, rate);
            return __ret;
        }

        public static void CaptureKeyboardFromApp(bool want_capture_keyboard_value)
        {
            __Internal.CaptureKeyboardFromApp(want_capture_keyboard_value);
        }

        public static bool IsMouseDown(int button)
        {
            var __ret = __Internal.IsMouseDown(button);
            return __ret;
        }

        public static bool IsMouseClicked(int button, bool repeat)
        {
            var __ret = __Internal.IsMouseClicked(button, repeat);
            return __ret;
        }

        public static bool IsMouseReleased(int button)
        {
            var __ret = __Internal.IsMouseReleased(button);
            return __ret;
        }

        public static bool IsMouseDoubleClicked(int button)
        {
            var __ret = __Internal.IsMouseDoubleClicked(button);
            return __ret;
        }

        public static bool IsMouseHoveringRect(global::ImGui.ImVec2 r_min, global::ImGui.ImVec2 r_max, bool clip)
        {
            if (ReferenceEquals(r_min, null))
                throw new global::System.ArgumentNullException("r_min", "Cannot be null because it is passed by value.");
            var __arg0 = r_min.__Instance;
            if (ReferenceEquals(r_max, null))
                throw new global::System.ArgumentNullException("r_max", "Cannot be null because it is passed by value.");
            var __arg1 = r_max.__Instance;
            var __ret = __Internal.IsMouseHoveringRect(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, clip);
            return __ret;
        }

        public static bool IsMousePosValid(global::ImGui.ImVec2 mouse_pos)
        {
            var __arg0 = ReferenceEquals(mouse_pos, null) ? global::System.IntPtr.Zero : mouse_pos.__Instance;
            var __ret = __Internal.IsMousePosValid(__arg0);
            return __ret;
        }

        public static bool IsAnyMouseDown()
        {
            var __ret = __Internal.IsAnyMouseDown();
            return __ret;
        }

        public static void GetMousePos(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetMousePos(__arg0);
        }

        public static void GetMousePosOnOpeningCurrentPopup(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetMousePosOnOpeningCurrentPopup(__arg0);
        }

        public static bool IsMouseDragging(int button, float lock_threshold)
        {
            var __ret = __Internal.IsMouseDragging(button, lock_threshold);
            return __ret;
        }

        public static void GetMouseDragDelta(global::ImGui.ImVec2 pOut, int button, float lock_threshold)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetMouseDragDelta(__arg0, button, lock_threshold);
        }

        public static void ResetMouseDragDelta(int button)
        {
            __Internal.ResetMouseDragDelta(button);
        }

        public static int GetMouseCursor()
        {
            var __ret = __Internal.GetMouseCursor();
            return __ret;
        }

        public static void SetMouseCursor(int cursor_type)
        {
            __Internal.SetMouseCursor(cursor_type);
        }

        public static void CaptureMouseFromApp(bool want_capture_mouse_value)
        {
            __Internal.CaptureMouseFromApp(want_capture_mouse_value);
        }

        public static string GetClipboardText()
        {
            var __ret = __Internal.GetClipboardText();
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static void SetClipboardText(string text)
        {
            __Internal.SetClipboardText(text);
        }

        public static void LoadIniSettingsFromDisk(string ini_filename)
        {
            __Internal.LoadIniSettingsFromDisk(ini_filename);
        }

        public static void LoadIniSettingsFromMemory(string ini_data, ulong ini_size)
        {
            __Internal.LoadIniSettingsFromMemory(ini_data, ini_size);
        }

        public static void SaveIniSettingsToDisk(string ini_filename)
        {
            __Internal.SaveIniSettingsToDisk(ini_filename);
        }

        public static string SaveIniSettingsToMemory(ref ulong out_ini_size)
        {
            fixed (ulong* __out_ini_size0 = &out_ini_size)
            {
                var __arg0 = __out_ini_size0;
                var __ret = __Internal.SaveIniSettingsToMemory(__arg0);
                if (__ret == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) __ret;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
            }
        }

        public static void SetAllocatorFunctions(global::ImGui.Delegates.Func_IntPtr_ulong_IntPtr alloc_func, global::ImGui.Delegates.Action_IntPtr_IntPtr free_func, global::System.IntPtr user_data)
        {
            var __arg0 = alloc_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(alloc_func);
            var __arg1 = free_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(free_func);
            __Internal.SetAllocatorFunctions(__arg0, __arg1, user_data);
        }

        public static global::System.IntPtr MemAlloc(ulong size)
        {
            var __ret = __Internal.MemAlloc(size);
            return __ret;
        }

        public static void MemFree(global::System.IntPtr ptr)
        {
            __Internal.MemFree(ptr);
        }

        public static global::ImGui.ImGuiStyle ImGuiStyleImGuiStyle()
        {
            var __ret = __Internal.ImGuiStyleImGuiStyle();
            global::ImGui.ImGuiStyle __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiStyle.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiStyle) global::ImGui.ImGuiStyle.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiStyle.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiStyle_destroy(global::ImGui.ImGuiStyle self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStyle_destroy(__arg0);
        }

        public static void ImGuiStyleScaleAllSizes(global::ImGui.ImGuiStyle self, float scale_factor)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStyleScaleAllSizes(__arg0, scale_factor);
        }

        public static void ImGuiIO_AddInputCharacter(global::ImGui.ImGuiIO self, uint c)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddInputCharacter(__arg0, c);
        }

        public static void ImGuiIO_AddInputCharactersUTF8(global::ImGui.ImGuiIO self, string str)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddInputCharactersUTF8(__arg0, str);
        }

        public static void ImGuiIO_ClearInputCharacters(global::ImGui.ImGuiIO self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_ClearInputCharacters(__arg0);
        }

        public static global::ImGui.ImGuiIO ImGuiIO_ImGuiIO()
        {
            var __ret = __Internal.ImGuiIO_ImGuiIO();
            global::ImGui.ImGuiIO __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiIO.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiIO) global::ImGui.ImGuiIO.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiIO.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiIO_destroy(global::ImGui.ImGuiIO self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_destroy(__arg0);
        }

        public static global::ImGui.ImGuiInputTextCallbackData ImGuiInputTextCallbackDataImGuiInputTextCallbackData()
        {
            var __ret = __Internal.ImGuiInputTextCallbackDataImGuiInputTextCallbackData();
            global::ImGui.ImGuiInputTextCallbackData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiInputTextCallbackData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiInputTextCallbackData) global::ImGui.ImGuiInputTextCallbackData.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiInputTextCallbackData.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiInputTextCallbackData_destroy(global::ImGui.ImGuiInputTextCallbackData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackData_destroy(__arg0);
        }

        public static void ImGuiInputTextCallbackDataDeleteChars(global::ImGui.ImGuiInputTextCallbackData self, int pos, int bytes_count)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataDeleteChars(__arg0, pos, bytes_count);
        }

        public static void ImGuiInputTextCallbackDataInsertChars(global::ImGui.ImGuiInputTextCallbackData self, int pos, string text, string text_end)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataInsertChars(__arg0, pos, text, text_end);
        }

        public static bool ImGuiInputTextCallbackDataHasSelection(global::ImGui.ImGuiInputTextCallbackData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextCallbackDataHasSelection(__arg0);
            return __ret;
        }

        public static global::ImGui.ImGuiPayload ImGuiPayloadImGuiPayload()
        {
            var __ret = __Internal.ImGuiPayloadImGuiPayload();
            global::ImGui.ImGuiPayload __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiPayload.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiPayload) global::ImGui.ImGuiPayload.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiPayload.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiPayload_destroy(global::ImGui.ImGuiPayload self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPayload_destroy(__arg0);
        }

        public static void ImGuiPayloadClear(global::ImGui.ImGuiPayload self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPayloadClear(__arg0);
        }

        public static bool ImGuiPayloadIsDataType(global::ImGui.ImGuiPayload self, string type)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsDataType(__arg0, type);
            return __ret;
        }

        public static bool ImGuiPayloadIsPreview(global::ImGui.ImGuiPayload self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsPreview(__arg0);
            return __ret;
        }

        public static bool ImGuiPayloadIsDelivery(global::ImGui.ImGuiPayload self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsDelivery(__arg0);
            return __ret;
        }

        public static global::ImGui.ImGuiOnceUponAFrame ImGuiOnceUponAFrameImGuiOnceUponAFrame()
        {
            var __ret = __Internal.ImGuiOnceUponAFrameImGuiOnceUponAFrame();
            global::ImGui.ImGuiOnceUponAFrame __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiOnceUponAFrame.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiOnceUponAFrame) global::ImGui.ImGuiOnceUponAFrame.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiOnceUponAFrame.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiOnceUponAFrame_destroy(global::ImGui.ImGuiOnceUponAFrame self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiOnceUponAFrame_destroy(__arg0);
        }

        public static global::ImGui.ImGuiTextFilter ImGuiTextFilterImGuiTextFilter(string default_filter)
        {
            var __ret = __Internal.ImGuiTextFilterImGuiTextFilter(default_filter);
            global::ImGui.ImGuiTextFilter __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiTextFilter.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiTextFilter) global::ImGui.ImGuiTextFilter.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiTextFilter.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiTextFilter_destroy(global::ImGui.ImGuiTextFilter self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilter_destroy(__arg0);
        }

        public static bool ImGuiTextFilterDraw(global::ImGui.ImGuiTextFilter self, string label, float width)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterDraw(__arg0, label, width);
            return __ret;
        }

        public static bool ImGuiTextFilterPassFilter(global::ImGui.ImGuiTextFilter self, string text, string text_end)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterPassFilter(__arg0, text, text_end);
            return __ret;
        }

        public static void ImGuiTextFilterBuild(global::ImGui.ImGuiTextFilter self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilterBuild(__arg0);
        }

        public static void ImGuiTextFilterClear(global::ImGui.ImGuiTextFilter self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilterClear(__arg0);
        }

        public static bool ImGuiTextFilterIsActive(global::ImGui.ImGuiTextFilter self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterIsActive(__arg0);
            return __ret;
        }

        public static global::ImGui.ImGuiTextRange ImGuiTextRangeImGuiTextRangeNil()
        {
            var __ret = __Internal.ImGuiTextRangeImGuiTextRangeNil();
            global::ImGui.ImGuiTextRange __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiTextRange.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiTextRange) global::ImGui.ImGuiTextRange.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiTextRange.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiTextRange_destroy(global::ImGui.ImGuiTextRange self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextRange_destroy(__arg0);
        }

        public static global::ImGui.ImGuiTextRange ImGuiTextRangeImGuiTextRangeStr(string _b, string _e)
        {
            var __ret = __Internal.ImGuiTextRangeImGuiTextRangeStr(_b, _e);
            global::ImGui.ImGuiTextRange __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiTextRange.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiTextRange) global::ImGui.ImGuiTextRange.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiTextRange.__CreateInstance(__ret);
            return __result0;
        }

        public static bool ImGuiTextRange_empty(global::ImGui.ImGuiTextRange self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextRange_empty(__arg0);
            return __ret;
        }

        public static void ImGuiTextRange_split(global::ImGui.ImGuiTextRange self, sbyte separator, global::ImGui.ImVectorImGuiTextRange @out)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg2 = ReferenceEquals(@out, null) ? global::System.IntPtr.Zero : @out.__Instance;
            __Internal.ImGuiTextRange_split(__arg0, separator, __arg2);
        }

        public static global::ImGui.ImGuiTextBuffer ImGuiTextBufferImGuiTextBuffer()
        {
            var __ret = __Internal.ImGuiTextBufferImGuiTextBuffer();
            global::ImGui.ImGuiTextBuffer __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiTextBuffer.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiTextBuffer) global::ImGui.ImGuiTextBuffer.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiTextBuffer.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiTextBuffer_destroy(global::ImGui.ImGuiTextBuffer self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_destroy(__arg0);
        }

        public static string ImGuiTextBuffer_begin(global::ImGui.ImGuiTextBuffer self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_begin(__arg0);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static string ImGuiTextBuffer_end(global::ImGui.ImGuiTextBuffer self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_end(__arg0);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static int ImGuiTextBuffer_size(global::ImGui.ImGuiTextBuffer self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_size(__arg0);
            return __ret;
        }

        public static bool ImGuiTextBuffer_empty(global::ImGui.ImGuiTextBuffer self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_empty(__arg0);
            return __ret;
        }

        public static void ImGuiTextBuffer_clear(global::ImGui.ImGuiTextBuffer self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_clear(__arg0);
        }

        public static void ImGuiTextBuffer_reserve(global::ImGui.ImGuiTextBuffer self, int capacity)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_reserve(__arg0, capacity);
        }

        public static string ImGuiTextBuffer_c_str(global::ImGui.ImGuiTextBuffer self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_c_str(__arg0);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static void ImGuiTextBuffer_append(global::ImGui.ImGuiTextBuffer self, string str, string str_end)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_append(__arg0, str, str_end);
        }

        public static global::ImGui.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairInt(uint _key, int _val_i)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairInt(_key, _val_i);
            global::ImGui.ImGuiStoragePair __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiStoragePair.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiStoragePair) global::ImGui.ImGuiStoragePair.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiStoragePair.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiStoragePair_destroy(global::ImGui.ImGuiStoragePair self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStoragePair_destroy(__arg0);
        }

        public static global::ImGui.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairFloat(uint _key, float _val_f)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairFloat(_key, _val_f);
            global::ImGui.ImGuiStoragePair __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiStoragePair.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiStoragePair) global::ImGui.ImGuiStoragePair.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiStoragePair.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairPtr(uint _key, global::System.IntPtr _val_p)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairPtr(_key, _val_p);
            global::ImGui.ImGuiStoragePair __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiStoragePair.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiStoragePair) global::ImGui.ImGuiStoragePair.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiStoragePair.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiStorageClear(global::ImGui.ImGuiStorage self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageClear(__arg0);
        }

        public static int ImGuiStorageGetInt(global::ImGui.ImGuiStorage self, uint key, int default_val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetInt(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetInt(global::ImGui.ImGuiStorage self, uint key, int val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetInt(__arg0, key, val);
        }

        public static bool ImGuiStorageGetBool(global::ImGui.ImGuiStorage self, uint key, bool default_val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetBool(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetBool(global::ImGui.ImGuiStorage self, uint key, bool val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetBool(__arg0, key, val);
        }

        public static float ImGuiStorageGetFloat(global::ImGui.ImGuiStorage self, uint key, float default_val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetFloat(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetFloat(global::ImGui.ImGuiStorage self, uint key, float val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetFloat(__arg0, key, val);
        }

        public static global::System.IntPtr ImGuiStorageGetVoidPtr(global::ImGui.ImGuiStorage self, uint key)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetVoidPtr(__arg0, key);
            return __ret;
        }

        public static void ImGuiStorageSetVoidPtr(global::ImGui.ImGuiStorage self, uint key, global::System.IntPtr val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetVoidPtr(__arg0, key, val);
        }

        public static int* ImGuiStorageGetIntRef(global::ImGui.ImGuiStorage self, uint key, int default_val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetIntRef(__arg0, key, default_val);
            return __ret;
        }

        public static bool* ImGuiStorageGetBoolRef(global::ImGui.ImGuiStorage self, uint key, bool default_val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetBoolRef(__arg0, key, default_val);
            return __ret;
        }

        public static float* ImGuiStorageGetFloatRef(global::ImGui.ImGuiStorage self, uint key, float default_val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetFloatRef(__arg0, key, default_val);
            return __ret;
        }

        public static void** ImGuiStorageGetVoidPtrRef(global::ImGui.ImGuiStorage self, uint key, global::System.IntPtr default_val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetVoidPtrRef(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetAllInt(global::ImGui.ImGuiStorage self, int val)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetAllInt(__arg0, val);
        }

        public static void ImGuiStorageBuildSortByKey(global::ImGui.ImGuiStorage self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageBuildSortByKey(__arg0);
        }

        public static global::ImGui.ImGuiListClipper ImGuiListClipperImGuiListClipper(int items_count, float items_height)
        {
            var __ret = __Internal.ImGuiListClipperImGuiListClipper(items_count, items_height);
            global::ImGui.ImGuiListClipper __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiListClipper.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiListClipper) global::ImGui.ImGuiListClipper.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiListClipper.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiListClipper_destroy(global::ImGui.ImGuiListClipper self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipper_destroy(__arg0);
        }

        public static bool ImGuiListClipperStep(global::ImGui.ImGuiListClipper self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiListClipperStep(__arg0);
            return __ret;
        }

        public static void ImGuiListClipperBegin(global::ImGui.ImGuiListClipper self, int items_count, float items_height)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperBegin(__arg0, items_count, items_height);
        }

        public static void ImGuiListClipperEnd(global::ImGui.ImGuiListClipper self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperEnd(__arg0);
        }

        public static global::ImGui.ImColor ImColorImColorNil()
        {
            var __ret = __Internal.ImColorImColorNil();
            global::ImGui.ImColor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImColor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImColor) global::ImGui.ImColor.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImColor.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImColor_destroy(global::ImGui.ImColor self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImColor_destroy(__arg0);
        }

        public static global::ImGui.ImColor ImColorImColorInt(int r, int g, int b, int a)
        {
            var __ret = __Internal.ImColorImColorInt(r, g, b, a);
            global::ImGui.ImColor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImColor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImColor) global::ImGui.ImColor.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImColor.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImColor ImColorImColorU32(uint rgba)
        {
            var __ret = __Internal.ImColorImColorU32(rgba);
            global::ImGui.ImColor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImColor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImColor) global::ImGui.ImColor.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImColor.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImColor ImColorImColorFloat(float r, float g, float b, float a)
        {
            var __ret = __Internal.ImColorImColorFloat(r, g, b, a);
            global::ImGui.ImColor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImColor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImColor) global::ImGui.ImColor.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImColor.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImColor ImColorImColorVec4(global::ImGui.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            var __ret = __Internal.ImColorImColorVec4(__arg0);
            global::ImGui.ImColor __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImColor.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImColor) global::ImGui.ImColor.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImColor.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImColorSetHSV(global::ImGui.ImColor self, float h, float s, float v, float a)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImColorSetHSV(__arg0, h, s, v, a);
        }

        public static void ImColorHSV(global::ImGui.ImColor pOut, global::ImGui.ImColor self, float h, float s, float v, float a)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImColorHSV(__arg0, __arg1, h, s, v, a);
        }

        public static global::ImGui.ImDrawCmd ImDrawCmdImDrawCmd()
        {
            var __ret = __Internal.ImDrawCmdImDrawCmd();
            global::ImGui.ImDrawCmd __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawCmd.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawCmd) global::ImGui.ImDrawCmd.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawCmd.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImDrawCmd_destroy(global::ImGui.ImDrawCmd self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawCmd_destroy(__arg0);
        }

        public static global::ImGui.ImDrawListSplitter ImDrawListSplitterImDrawListSplitter()
        {
            var __ret = __Internal.ImDrawListSplitterImDrawListSplitter();
            global::ImGui.ImDrawListSplitter __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawListSplitter.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawListSplitter) global::ImGui.ImDrawListSplitter.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawListSplitter.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImDrawListSplitter_destroy(global::ImGui.ImDrawListSplitter self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitter_destroy(__arg0);
        }

        public static void ImDrawListSplitterClear(global::ImGui.ImDrawListSplitter self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitterClear(__arg0);
        }

        public static void ImDrawListSplitterClearFreeMemory(global::ImGui.ImDrawListSplitter self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitterClearFreeMemory(__arg0);
        }

        public static void ImDrawListSplitterSplit(global::ImGui.ImDrawListSplitter self, global::ImGui.ImDrawList draw_list, int count)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterSplit(__arg0, __arg1, count);
        }

        public static void ImDrawListSplitterMerge(global::ImGui.ImDrawListSplitter self, global::ImGui.ImDrawList draw_list)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterMerge(__arg0, __arg1);
        }

        public static void ImDrawListSplitterSetCurrentChannel(global::ImGui.ImDrawListSplitter self, global::ImGui.ImDrawList draw_list, int channel_idx)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterSetCurrentChannel(__arg0, __arg1, channel_idx);
        }

        public static global::ImGui.ImDrawList ImDrawListImDrawList(global::ImGui.ImDrawListSharedData shared_data)
        {
            var __arg0 = ReferenceEquals(shared_data, null) ? global::System.IntPtr.Zero : shared_data.__Instance;
            var __ret = __Internal.ImDrawListImDrawList(__arg0);
            global::ImGui.ImDrawList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawList) global::ImGui.ImDrawList.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawList.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImDrawList_destroy(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawList_destroy(__arg0);
        }

        public static void ImDrawListPushClipRect(global::ImGui.ImDrawList self, global::ImGui.ImVec2 clip_rect_min, global::ImGui.ImVec2 clip_rect_max, bool intersect_with_current_clip_rect)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(clip_rect_min, null))
                throw new global::System.ArgumentNullException("clip_rect_min", "Cannot be null because it is passed by value.");
            var __arg1 = clip_rect_min.__Instance;
            if (ReferenceEquals(clip_rect_max, null))
                throw new global::System.ArgumentNullException("clip_rect_max", "Cannot be null because it is passed by value.");
            var __arg2 = clip_rect_max.__Instance;
            __Internal.ImDrawListPushClipRect(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, intersect_with_current_clip_rect);
        }

        public static void ImDrawListPushClipRectFullScreen(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPushClipRectFullScreen(__arg0);
        }

        public static void ImDrawListPopClipRect(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPopClipRect(__arg0);
        }

        public static void ImDrawListPushTextureID(global::ImGui.ImDrawList self, global::System.IntPtr texture_id)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPushTextureID(__arg0, texture_id);
        }

        public static void ImDrawListPopTextureID(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPopTextureID(__arg0);
        }

        public static void ImDrawListGetClipRectMin(global::ImGui.ImVec2 pOut, global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListGetClipRectMin(__arg0, __arg1);
        }

        public static void ImDrawListGetClipRectMax(global::ImGui.ImVec2 pOut, global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListGetClipRectMax(__arg0, __arg1);
        }

        public static void ImDrawListAddLine(global::ImGui.ImDrawList self, global::ImGui.ImVec2 p1, global::ImGui.ImVec2 p2, uint col, float thickness)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            __Internal.ImDrawListAddLine(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, col, thickness);
        }

        public static void ImDrawListAddRect(global::ImGui.ImDrawList self, global::ImGui.ImVec2 p_min, global::ImGui.ImVec2 p_max, uint col, float rounding, int rounding_corners, float thickness)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRect(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, col, rounding, rounding_corners, thickness);
        }

        public static void ImDrawListAddRectFilled(global::ImGui.ImDrawList self, global::ImGui.ImVec2 p_min, global::ImGui.ImVec2 p_max, uint col, float rounding, int rounding_corners)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRectFilled(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, col, rounding, rounding_corners);
        }

        public static void ImDrawListAddRectFilledMultiColor(global::ImGui.ImDrawList self, global::ImGui.ImVec2 p_min, global::ImGui.ImVec2 p_max, uint col_upr_left, uint col_upr_right, uint col_bot_right, uint col_bot_left)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRectFilledMultiColor(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
        }

        public static void ImDrawListAddQuad(global::ImGui.ImDrawList self, global::ImGui.ImVec2 p1, global::ImGui.ImVec2 p2, global::ImGui.ImVec2 p3, global::ImGui.ImVec2 p4, uint col, float thickness)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddQuad(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, col, thickness);
        }

        public static void ImDrawListAddQuadFilled(global::ImGui.ImDrawList self, global::ImGui.ImVec2 p1, global::ImGui.ImVec2 p2, global::ImGui.ImVec2 p3, global::ImGui.ImVec2 p4, uint col)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddQuadFilled(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, col);
        }

        public static void ImDrawListAddTriangle(global::ImGui.ImDrawList self, global::ImGui.ImVec2 p1, global::ImGui.ImVec2 p2, global::ImGui.ImVec2 p3, uint col, float thickness)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImDrawListAddTriangle(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, col, thickness);
        }

        public static void ImDrawListAddTriangleFilled(global::ImGui.ImDrawList self, global::ImGui.ImVec2 p1, global::ImGui.ImVec2 p2, global::ImGui.ImVec2 p3, uint col)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImDrawListAddTriangleFilled(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, col);
        }

        public static void ImDrawListAddCircle(global::ImGui.ImDrawList self, global::ImGui.ImVec2 center, float radius, uint col, int num_segments, float thickness)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddCircle(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, radius, col, num_segments, thickness);
        }

        public static void ImDrawListAddCircleFilled(global::ImGui.ImDrawList self, global::ImGui.ImVec2 center, float radius, uint col, int num_segments)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddCircleFilled(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, radius, col, num_segments);
        }

        public static void ImDrawListAddNgon(global::ImGui.ImDrawList self, global::ImGui.ImVec2 center, float radius, uint col, int num_segments, float thickness)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddNgon(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, radius, col, num_segments, thickness);
        }

        public static void ImDrawListAddNgonFilled(global::ImGui.ImDrawList self, global::ImGui.ImVec2 center, float radius, uint col, int num_segments)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddNgonFilled(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, radius, col, num_segments);
        }

        public static void ImDrawListAddTextVec2(global::ImGui.ImDrawList self, global::ImGui.ImVec2 pos, uint col, string text_begin, string text_end)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListAddTextVec2(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, col, text_begin, text_end);
        }

        public static void ImDrawListAddTextFontPtr(global::ImGui.ImDrawList self, global::ImGui.ImFont font, float font_size, global::ImGui.ImVec2 pos, uint col, string text_begin, string text_end, float wrap_width, global::ImGui.ImVec4 cpu_fine_clip_rect)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            var __arg8 = ReferenceEquals(cpu_fine_clip_rect, null) ? global::System.IntPtr.Zero : cpu_fine_clip_rect.__Instance;
            __Internal.ImDrawListAddTextFontPtr(__arg0, __arg1, font_size, *(global::ImGui.ImVec2.__Internal*) __arg3, col, text_begin, text_end, wrap_width, __arg8);
        }

        public static void ImDrawListAddPolyline(global::ImGui.ImDrawList self, global::ImGui.ImVec2 points, int num_points, uint col, bool closed, float thickness)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(points, null) ? global::System.IntPtr.Zero : points.__Instance;
            __Internal.ImDrawListAddPolyline(__arg0, __arg1, num_points, col, closed, thickness);
        }

        public static void ImDrawListAddConvexPolyFilled(global::ImGui.ImDrawList self, global::ImGui.ImVec2 points, int num_points, uint col)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(points, null) ? global::System.IntPtr.Zero : points.__Instance;
            __Internal.ImDrawListAddConvexPolyFilled(__arg0, __arg1, num_points, col);
        }

        public static void ImDrawListAddBezierCurve(global::ImGui.ImDrawList self, global::ImGui.ImVec2 p1, global::ImGui.ImVec2 p2, global::ImGui.ImVec2 p3, global::ImGui.ImVec2 p4, uint col, float thickness, int num_segments)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddBezierCurve(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, col, thickness, num_segments);
        }

        public static void ImDrawListAddImage(global::ImGui.ImDrawList self, global::System.IntPtr user_texture_id, global::ImGui.ImVec2 p_min, global::ImGui.ImVec2 p_max, global::ImGui.ImVec2 uv_min, global::ImGui.ImVec2 uv_max, uint col)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg2 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg3 = p_max.__Instance;
            if (ReferenceEquals(uv_min, null))
                throw new global::System.ArgumentNullException("uv_min", "Cannot be null because it is passed by value.");
            var __arg4 = uv_min.__Instance;
            if (ReferenceEquals(uv_max, null))
                throw new global::System.ArgumentNullException("uv_max", "Cannot be null because it is passed by value.");
            var __arg5 = uv_max.__Instance;
            __Internal.ImDrawListAddImage(__arg0, user_texture_id, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, *(global::ImGui.ImVec2.__Internal*) __arg5, col);
        }

        public static void ImDrawListAddImageQuad(global::ImGui.ImDrawList self, global::System.IntPtr user_texture_id, global::ImGui.ImVec2 p1, global::ImGui.ImVec2 p2, global::ImGui.ImVec2 p3, global::ImGui.ImVec2 p4, global::ImGui.ImVec2 uv1, global::ImGui.ImVec2 uv2, global::ImGui.ImVec2 uv3, global::ImGui.ImVec2 uv4, uint col)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg2 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg3 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg4 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg5 = p4.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg6 = uv1.__Instance;
            if (ReferenceEquals(uv2, null))
                throw new global::System.ArgumentNullException("uv2", "Cannot be null because it is passed by value.");
            var __arg7 = uv2.__Instance;
            if (ReferenceEquals(uv3, null))
                throw new global::System.ArgumentNullException("uv3", "Cannot be null because it is passed by value.");
            var __arg8 = uv3.__Instance;
            if (ReferenceEquals(uv4, null))
                throw new global::System.ArgumentNullException("uv4", "Cannot be null because it is passed by value.");
            var __arg9 = uv4.__Instance;
            __Internal.ImDrawListAddImageQuad(__arg0, user_texture_id, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, *(global::ImGui.ImVec2.__Internal*) __arg5, *(global::ImGui.ImVec2.__Internal*) __arg6, *(global::ImGui.ImVec2.__Internal*) __arg7, *(global::ImGui.ImVec2.__Internal*) __arg8, *(global::ImGui.ImVec2.__Internal*) __arg9, col);
        }

        public static void ImDrawListAddImageRounded(global::ImGui.ImDrawList self, global::System.IntPtr user_texture_id, global::ImGui.ImVec2 p_min, global::ImGui.ImVec2 p_max, global::ImGui.ImVec2 uv_min, global::ImGui.ImVec2 uv_max, uint col, float rounding, int rounding_corners)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg2 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg3 = p_max.__Instance;
            if (ReferenceEquals(uv_min, null))
                throw new global::System.ArgumentNullException("uv_min", "Cannot be null because it is passed by value.");
            var __arg4 = uv_min.__Instance;
            if (ReferenceEquals(uv_max, null))
                throw new global::System.ArgumentNullException("uv_max", "Cannot be null because it is passed by value.");
            var __arg5 = uv_max.__Instance;
            __Internal.ImDrawListAddImageRounded(__arg0, user_texture_id, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, *(global::ImGui.ImVec2.__Internal*) __arg5, col, rounding, rounding_corners);
        }

        public static void ImDrawListPathClear(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathClear(__arg0);
        }

        public static void ImDrawListPathLineTo(global::ImGui.ImDrawList self, global::ImGui.ImVec2 pos)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListPathLineTo(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1);
        }

        public static void ImDrawListPathLineToMergeDuplicate(global::ImGui.ImDrawList self, global::ImGui.ImVec2 pos)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListPathLineToMergeDuplicate(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1);
        }

        public static void ImDrawListPathFillConvex(global::ImGui.ImDrawList self, uint col)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathFillConvex(__arg0, col);
        }

        public static void ImDrawListPathStroke(global::ImGui.ImDrawList self, uint col, bool closed, float thickness)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathStroke(__arg0, col, closed, thickness);
        }

        public static void ImDrawListPathArcTo(global::ImGui.ImDrawList self, global::ImGui.ImVec2 center, float radius, float a_min, float a_max, int num_segments)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcTo(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, radius, a_min, a_max, num_segments);
        }

        public static void ImDrawListPathArcToFast(global::ImGui.ImDrawList self, global::ImGui.ImVec2 center, float radius, int a_min_of_12, int a_max_of_12)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcToFast(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, radius, a_min_of_12, a_max_of_12);
        }

        public static void ImDrawListPathBezierCurveTo(global::ImGui.ImDrawList self, global::ImGui.ImVec2 p2, global::ImGui.ImVec2 p3, global::ImGui.ImVec2 p4, int num_segments)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg2 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg3 = p4.__Instance;
            __Internal.ImDrawListPathBezierCurveTo(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, num_segments);
        }

        public static void ImDrawListPathRect(global::ImGui.ImDrawList self, global::ImGui.ImVec2 rect_min, global::ImGui.ImVec2 rect_max, float rounding, int rounding_corners)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(rect_min, null))
                throw new global::System.ArgumentNullException("rect_min", "Cannot be null because it is passed by value.");
            var __arg1 = rect_min.__Instance;
            if (ReferenceEquals(rect_max, null))
                throw new global::System.ArgumentNullException("rect_max", "Cannot be null because it is passed by value.");
            var __arg2 = rect_max.__Instance;
            __Internal.ImDrawListPathRect(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, rounding, rounding_corners);
        }

        public static void ImDrawListAddCallback(global::ImGui.ImDrawList self, global::ImGui.ImDrawCallback callback, global::System.IntPtr callback_data)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.ImDrawListAddCallback(__arg0, __arg1, callback_data);
        }

        public static void ImDrawListAddDrawCmd(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListAddDrawCmd(__arg0);
        }

        public static global::ImGui.ImDrawList ImDrawListCloneOutput(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImDrawListCloneOutput(__arg0);
            global::ImGui.ImDrawList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawList) global::ImGui.ImDrawList.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawList.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImDrawListChannelsSplit(global::ImGui.ImDrawList self, int count)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsSplit(__arg0, count);
        }

        public static void ImDrawListChannelsMerge(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsMerge(__arg0);
        }

        public static void ImDrawListChannelsSetCurrent(global::ImGui.ImDrawList self, int n)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsSetCurrent(__arg0, n);
        }

        public static void ImDrawListClear(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListClear(__arg0);
        }

        public static void ImDrawListClearFreeMemory(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListClearFreeMemory(__arg0);
        }

        public static void ImDrawListPrimReserve(global::ImGui.ImDrawList self, int idx_count, int vtx_count)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimReserve(__arg0, idx_count, vtx_count);
        }

        public static void ImDrawListPrimUnreserve(global::ImGui.ImDrawList self, int idx_count, int vtx_count)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimUnreserve(__arg0, idx_count, vtx_count);
        }

        public static void ImDrawListPrimRect(global::ImGui.ImDrawList self, global::ImGui.ImVec2 a, global::ImGui.ImVec2 b, uint col)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            __Internal.ImDrawListPrimRect(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListPrimRectUV(global::ImGui.ImDrawList self, global::ImGui.ImVec2 a, global::ImGui.ImVec2 b, global::ImGui.ImVec2 uv_a, global::ImGui.ImVec2 uv_b, uint col)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is passed by value.");
            var __arg3 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is passed by value.");
            var __arg4 = uv_b.__Instance;
            __Internal.ImDrawListPrimRectUV(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, col);
        }

        public static void ImDrawListPrimQuadUV(global::ImGui.ImDrawList self, global::ImGui.ImVec2 a, global::ImGui.ImVec2 b, global::ImGui.ImVec2 c, global::ImGui.ImVec2 d, global::ImGui.ImVec2 uv_a, global::ImGui.ImVec2 uv_b, global::ImGui.ImVec2 uv_c, global::ImGui.ImVec2 uv_d, uint col)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg3 = c.__Instance;
            if (ReferenceEquals(d, null))
                throw new global::System.ArgumentNullException("d", "Cannot be null because it is passed by value.");
            var __arg4 = d.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is passed by value.");
            var __arg5 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is passed by value.");
            var __arg6 = uv_b.__Instance;
            if (ReferenceEquals(uv_c, null))
                throw new global::System.ArgumentNullException("uv_c", "Cannot be null because it is passed by value.");
            var __arg7 = uv_c.__Instance;
            if (ReferenceEquals(uv_d, null))
                throw new global::System.ArgumentNullException("uv_d", "Cannot be null because it is passed by value.");
            var __arg8 = uv_d.__Instance;
            __Internal.ImDrawListPrimQuadUV(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, *(global::ImGui.ImVec2.__Internal*) __arg5, *(global::ImGui.ImVec2.__Internal*) __arg6, *(global::ImGui.ImVec2.__Internal*) __arg7, *(global::ImGui.ImVec2.__Internal*) __arg8, col);
        }

        public static void ImDrawListPrimWriteVtx(global::ImGui.ImDrawList self, global::ImGui.ImVec2 pos, global::ImGui.ImVec2 uv, uint col)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is passed by value.");
            var __arg2 = uv.__Instance;
            __Internal.ImDrawListPrimWriteVtx(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListPrimWriteIdx(global::ImGui.ImDrawList self, ushort idx)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimWriteIdx(__arg0, idx);
        }

        public static void ImDrawListPrimVtx(global::ImGui.ImDrawList self, global::ImGui.ImVec2 pos, global::ImGui.ImVec2 uv, uint col)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is passed by value.");
            var __arg2 = uv.__Instance;
            __Internal.ImDrawListPrimVtx(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListUpdateClipRect(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListUpdateClipRect(__arg0);
        }

        public static void ImDrawListUpdateTextureID(global::ImGui.ImDrawList self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListUpdateTextureID(__arg0);
        }

        public static global::ImGui.ImDrawData ImDrawDataImDrawData()
        {
            var __ret = __Internal.ImDrawDataImDrawData();
            global::ImGui.ImDrawData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawData) global::ImGui.ImDrawData.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawData.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImDrawData_destroy(global::ImGui.ImDrawData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawData_destroy(__arg0);
        }

        public static void ImDrawDataClear(global::ImGui.ImDrawData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataClear(__arg0);
        }

        public static void ImDrawDataDeIndexAllBuffers(global::ImGui.ImDrawData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataDeIndexAllBuffers(__arg0);
        }

        public static void ImDrawDataScaleClipRects(global::ImGui.ImDrawData self, global::ImGui.ImVec2 fb_scale)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(fb_scale, null))
                throw new global::System.ArgumentNullException("fb_scale", "Cannot be null because it is passed by value.");
            var __arg1 = fb_scale.__Instance;
            __Internal.ImDrawDataScaleClipRects(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1);
        }

        public static global::ImGui.ImFontConfig ImFontConfigImFontConfig()
        {
            var __ret = __Internal.ImFontConfigImFontConfig();
            global::ImGui.ImFontConfig __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFontConfig.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFontConfig) global::ImGui.ImFontConfig.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFontConfig.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImFontConfig_destroy(global::ImGui.ImFontConfig self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontConfig_destroy(__arg0);
        }

        public static global::ImGui.ImFontGlyphRangesBuilder ImFontGlyphRangesBuilderImFontGlyphRangesBuilder()
        {
            var __ret = __Internal.ImFontGlyphRangesBuilderImFontGlyphRangesBuilder();
            global::ImGui.ImFontGlyphRangesBuilder __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFontGlyphRangesBuilder.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFontGlyphRangesBuilder) global::ImGui.ImFontGlyphRangesBuilder.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFontGlyphRangesBuilder.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImFontGlyphRangesBuilder_destroy(global::ImGui.ImFontGlyphRangesBuilder self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilder_destroy(__arg0);
        }

        public static void ImFontGlyphRangesBuilderClear(global::ImGui.ImFontGlyphRangesBuilder self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderClear(__arg0);
        }

        public static bool ImFontGlyphRangesBuilderGetBit(global::ImGui.ImFontGlyphRangesBuilder self, int n)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGlyphRangesBuilderGetBit(__arg0, n);
            return __ret;
        }

        public static void ImFontGlyphRangesBuilderSetBit(global::ImGui.ImFontGlyphRangesBuilder self, int n)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderSetBit(__arg0, n);
        }

        public static void ImFontGlyphRangesBuilderAddChar(global::ImGui.ImFontGlyphRangesBuilder self, ushort c)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderAddChar(__arg0, c);
        }

        public static void ImFontGlyphRangesBuilderAddText(global::ImGui.ImFontGlyphRangesBuilder self, string text, string text_end)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderAddText(__arg0, text, text_end);
        }

        public static void ImFontGlyphRangesBuilderAddRanges(global::ImGui.ImFontGlyphRangesBuilder self, ref ushort ranges)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            fixed (ushort* __ranges1 = &ranges)
            {
                var __arg1 = __ranges1;
                __Internal.ImFontGlyphRangesBuilderAddRanges(__arg0, __arg1);
            }
        }

        public static void ImFontGlyphRangesBuilderBuildRanges(global::ImGui.ImFontGlyphRangesBuilder self, global::ImGui.ImVectorImWchar out_ranges)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(out_ranges, null) ? global::System.IntPtr.Zero : out_ranges.__Instance;
            __Internal.ImFontGlyphRangesBuilderBuildRanges(__arg0, __arg1);
        }

        public static global::ImGui.ImFontAtlasCustomRect ImFontAtlasCustomRectImFontAtlasCustomRect()
        {
            var __ret = __Internal.ImFontAtlasCustomRectImFontAtlasCustomRect();
            global::ImGui.ImFontAtlasCustomRect __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFontAtlasCustomRect.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFontAtlasCustomRect) global::ImGui.ImFontAtlasCustomRect.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFontAtlasCustomRect.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImFontAtlasCustomRect_destroy(global::ImGui.ImFontAtlasCustomRect self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasCustomRect_destroy(__arg0);
        }

        public static bool ImFontAtlasCustomRectIsPacked(global::ImGui.ImFontAtlasCustomRect self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasCustomRectIsPacked(__arg0);
            return __ret;
        }

        public static global::ImGui.ImFontAtlas ImFontAtlasImFontAtlas()
        {
            var __ret = __Internal.ImFontAtlasImFontAtlas();
            global::ImGui.ImFontAtlas __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFontAtlas.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFontAtlas) global::ImGui.ImFontAtlas.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFontAtlas.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImFontAtlas_destroy(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlas_destroy(__arg0);
        }

        public static global::ImGui.ImFont ImFontAtlasAddFont(global::ImGui.ImFontAtlas self, global::ImGui.ImFontConfig font_cfg)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(font_cfg, null) ? global::System.IntPtr.Zero : font_cfg.__Instance;
            var __ret = __Internal.ImFontAtlasAddFont(__arg0, __arg1);
            global::ImGui.ImFont __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFont.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImFont ImFontAtlasAddFontDefault(global::ImGui.ImFontAtlas self, global::ImGui.ImFontConfig font_cfg)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(font_cfg, null) ? global::System.IntPtr.Zero : font_cfg.__Instance;
            var __ret = __Internal.ImFontAtlasAddFontDefault(__arg0, __arg1);
            global::ImGui.ImFont __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFont.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImFont ImFontAtlasAddFontFromFileTTF(global::ImGui.ImFontAtlas self, string filename, float size_pixels, global::ImGui.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg3 = ReferenceEquals(font_cfg, null) ? global::System.IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges4 = &glyph_ranges)
            {
                var __arg4 = __glyph_ranges4;
                var __ret = __Internal.ImFontAtlasAddFontFromFileTTF(__arg0, filename, size_pixels, __arg3, __arg4);
                global::ImGui.ImFont __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[__ret];
                else __result0 = global::ImGui.ImFont.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static global::ImGui.ImFont ImFontAtlasAddFontFromMemoryTTF(global::ImGui.ImFontAtlas self, global::System.IntPtr font_data, int font_size, float size_pixels, global::ImGui.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg4 = ReferenceEquals(font_cfg, null) ? global::System.IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges5 = &glyph_ranges)
            {
                var __arg5 = __glyph_ranges5;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryTTF(__arg0, font_data, font_size, size_pixels, __arg4, __arg5);
                global::ImGui.ImFont __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[__ret];
                else __result0 = global::ImGui.ImFont.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static global::ImGui.ImFont ImFontAtlasAddFontFromMemoryCompressedTTF(global::ImGui.ImFontAtlas self, global::System.IntPtr compressed_font_data, int compressed_font_size, float size_pixels, global::ImGui.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg4 = ReferenceEquals(font_cfg, null) ? global::System.IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges5 = &glyph_ranges)
            {
                var __arg5 = __glyph_ranges5;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryCompressedTTF(__arg0, compressed_font_data, compressed_font_size, size_pixels, __arg4, __arg5);
                global::ImGui.ImFont __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[__ret];
                else __result0 = global::ImGui.ImFont.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static global::ImGui.ImFont ImFontAtlasAddFontFromMemoryCompressedBase85TTF(global::ImGui.ImFontAtlas self, string compressed_font_data_base85, float size_pixels, global::ImGui.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg3 = ReferenceEquals(font_cfg, null) ? global::System.IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges4 = &glyph_ranges)
            {
                var __arg4 = __glyph_ranges4;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryCompressedBase85TTF(__arg0, compressed_font_data_base85, size_pixels, __arg3, __arg4);
                global::ImGui.ImFont __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[__ret];
                else __result0 = global::ImGui.ImFont.__CreateInstance(__ret);
                return __result0;
            }
        }

        public static void ImFontAtlasClearInputData(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearInputData(__arg0);
        }

        public static void ImFontAtlasClearTexData(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearTexData(__arg0);
        }

        public static void ImFontAtlasClearFonts(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearFonts(__arg0);
        }

        public static void ImFontAtlasClear(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClear(__arg0);
        }

        public static bool ImFontAtlasBuild(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasBuild(__arg0);
            return __ret;
        }

        public static void ImFontAtlasGetTexDataAsAlpha8(global::ImGui.ImFontAtlas self, byte** out_pixels, ref int out_width, ref int out_height, ref int out_bytes_per_pixel)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            fixed (int* __out_width2 = &out_width)
            {
                var __arg2 = __out_width2;
                fixed (int* __out_height3 = &out_height)
                {
                    var __arg3 = __out_height3;
                    fixed (int* __out_bytes_per_pixel4 = &out_bytes_per_pixel)
                    {
                        var __arg4 = __out_bytes_per_pixel4;
                        __Internal.ImFontAtlasGetTexDataAsAlpha8(__arg0, out_pixels, __arg2, __arg3, __arg4);
                    }
                }
            }
        }

        public static void ImFontAtlasGetTexDataAsRGBA32(global::ImGui.ImFontAtlas self, byte** out_pixels, ref int out_width, ref int out_height, ref int out_bytes_per_pixel)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            fixed (int* __out_width2 = &out_width)
            {
                var __arg2 = __out_width2;
                fixed (int* __out_height3 = &out_height)
                {
                    var __arg3 = __out_height3;
                    fixed (int* __out_bytes_per_pixel4 = &out_bytes_per_pixel)
                    {
                        var __arg4 = __out_bytes_per_pixel4;
                        __Internal.ImFontAtlasGetTexDataAsRGBA32(__arg0, out_pixels, __arg2, __arg3, __arg4);
                    }
                }
            }
        }

        public static bool ImFontAtlasIsBuilt(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasIsBuilt(__arg0);
            return __ret;
        }

        public static void ImFontAtlasSetTexID(global::ImGui.ImFontAtlas self, global::System.IntPtr id)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasSetTexID(__arg0, id);
        }

        public static ushort* ImFontAtlasGetGlyphRangesDefault(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesDefault(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesKorean(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesKorean(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesJapanese(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesJapanese(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesChineseFull(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesChineseFull(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesCyrillic(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesCyrillic(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesThai(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesThai(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesVietnamese(global::ImGui.ImFontAtlas self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesVietnamese(__arg0);
            return __ret;
        }

        public static int ImFontAtlasAddCustomRectRegular(global::ImGui.ImFontAtlas self, uint id, int width, int height)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasAddCustomRectRegular(__arg0, id, width, height);
            return __ret;
        }

        public static int ImFontAtlasAddCustomRectFontGlyph(global::ImGui.ImFontAtlas self, global::ImGui.ImFont font, ushort id, int width, int height, float advance_x, global::ImGui.ImVec2 offset)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            if (ReferenceEquals(offset, null))
                throw new global::System.ArgumentNullException("offset", "Cannot be null because it is passed by value.");
            var __arg6 = offset.__Instance;
            var __ret = __Internal.ImFontAtlasAddCustomRectFontGlyph(__arg0, __arg1, id, width, height, advance_x, *(global::ImGui.ImVec2.__Internal*) __arg6);
            return __ret;
        }

        public static global::ImGui.ImFontAtlasCustomRect ImFontAtlasGetCustomRectByIndex(global::ImGui.ImFontAtlas self, int index)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetCustomRectByIndex(__arg0, index);
            global::ImGui.ImFontAtlasCustomRect __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFontAtlasCustomRect.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFontAtlasCustomRect) global::ImGui.ImFontAtlasCustomRect.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFontAtlasCustomRect.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImFontAtlasCalcCustomRectUV(global::ImGui.ImFontAtlas self, global::ImGui.ImFontAtlasCustomRect rect, global::ImGui.ImVec2 out_uv_min, global::ImGui.ImVec2 out_uv_max)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(rect, null) ? global::System.IntPtr.Zero : rect.__Instance;
            var __arg2 = ReferenceEquals(out_uv_min, null) ? global::System.IntPtr.Zero : out_uv_min.__Instance;
            var __arg3 = ReferenceEquals(out_uv_max, null) ? global::System.IntPtr.Zero : out_uv_max.__Instance;
            __Internal.ImFontAtlasCalcCustomRectUV(__arg0, __arg1, __arg2, __arg3);
        }

        public static bool ImFontAtlasGetMouseCursorTexData(global::ImGui.ImFontAtlas self, int cursor, global::ImGui.ImVec2 out_offset, global::ImGui.ImVec2 out_size, global::ImGui.ImVec2[] out_uv_border, global::ImGui.ImVec2[] out_uv_fill)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg2 = ReferenceEquals(out_offset, null) ? global::System.IntPtr.Zero : out_offset.__Instance;
            var __arg3 = ReferenceEquals(out_size, null) ? global::System.IntPtr.Zero : out_size.__Instance;
            if (out_uv_border == null || out_uv_border.Length != 2)
                throw new ArgumentOutOfRangeException("out_uv_border", "The dimensions of the provided array don't match the required size.");
            global::ImGui.ImVec2.__Internal[] __out_uv_border;
            if (ReferenceEquals(out_uv_border, null))
                __out_uv_border = null;
            else
            {
                __out_uv_border = new global::ImGui.ImVec2.__Internal[out_uv_border.Length];
                for (int i = 0; i < __out_uv_border.Length; i++)
                {
                    var __element = out_uv_border[i];
                    __out_uv_border[i] = ReferenceEquals(__element, null) ? new global::ImGui.ImVec2.__Internal() : *(global::ImGui.ImVec2.__Internal*) __element.__Instance;
                }
            }
            var __arg4 = __out_uv_border;
            if (out_uv_fill == null || out_uv_fill.Length != 2)
                throw new ArgumentOutOfRangeException("out_uv_fill", "The dimensions of the provided array don't match the required size.");
            global::ImGui.ImVec2.__Internal[] __out_uv_fill;
            if (ReferenceEquals(out_uv_fill, null))
                __out_uv_fill = null;
            else
            {
                __out_uv_fill = new global::ImGui.ImVec2.__Internal[out_uv_fill.Length];
                for (int i = 0; i < __out_uv_fill.Length; i++)
                {
                    var __element = out_uv_fill[i];
                    __out_uv_fill[i] = ReferenceEquals(__element, null) ? new global::ImGui.ImVec2.__Internal() : *(global::ImGui.ImVec2.__Internal*) __element.__Instance;
                }
            }
            var __arg5 = __out_uv_fill;
            var __ret = __Internal.ImFontAtlasGetMouseCursorTexData(__arg0, cursor, __arg2, __arg3, __arg4, __arg5);
            return __ret;
        }

        public static global::ImGui.ImFont ImFontImFont()
        {
            var __ret = __Internal.ImFontImFont();
            global::ImGui.ImFont __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFont.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImFont_destroy(global::ImGui.ImFont self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFont_destroy(__arg0);
        }

        public static global::ImGui.ImFontGlyph ImFontFindGlyph(global::ImGui.ImFont self, ushort c)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontFindGlyph(__arg0, c);
            global::ImGui.ImFontGlyph __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFontGlyph.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFontGlyph) global::ImGui.ImFontGlyph.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFontGlyph.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImFontGlyph ImFontFindGlyphNoFallback(global::ImGui.ImFont self, ushort c)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontFindGlyphNoFallback(__arg0, c);
            global::ImGui.ImFontGlyph __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFontGlyph.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFontGlyph) global::ImGui.ImFontGlyph.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFontGlyph.__CreateInstance(__ret);
            return __result0;
        }

        public static float ImFontGetCharAdvance(global::ImGui.ImFont self, ushort c)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGetCharAdvance(__arg0, c);
            return __ret;
        }

        public static bool ImFontIsLoaded(global::ImGui.ImFont self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontIsLoaded(__arg0);
            return __ret;
        }

        public static string ImFontGetDebugName(global::ImGui.ImFont self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGetDebugName(__arg0);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static void ImFontCalcTextSizeA(global::ImGui.ImVec2 pOut, global::ImGui.ImFont self, float size, float max_width, float wrap_width, string text_begin, string text_end, sbyte** remaining)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontCalcTextSizeA(__arg0, __arg1, size, max_width, wrap_width, text_begin, text_end, remaining);
        }

        public static string ImFontCalcWordWrapPositionA(global::ImGui.ImFont self, float scale, string text, string text_end, float wrap_width)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontCalcWordWrapPositionA(__arg0, scale, text, text_end, wrap_width);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static void ImFontRenderChar(global::ImGui.ImFont self, global::ImGui.ImDrawList draw_list, float size, global::ImGui.ImVec2 pos, uint col, ushort c)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            __Internal.ImFontRenderChar(__arg0, __arg1, size, *(global::ImGui.ImVec2.__Internal*) __arg3, col, c);
        }

        public static void ImFontRenderText(global::ImGui.ImFont self, global::ImGui.ImDrawList draw_list, float size, global::ImGui.ImVec2 pos, uint col, global::ImGui.ImVec4 clip_rect, string text_begin, string text_end, float wrap_width, bool cpu_fine_clip)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            if (ReferenceEquals(clip_rect, null))
                throw new global::System.ArgumentNullException("clip_rect", "Cannot be null because it is passed by value.");
            var __arg5 = clip_rect.__Instance;
            __Internal.ImFontRenderText(__arg0, __arg1, size, *(global::ImGui.ImVec2.__Internal*) __arg3, col, __arg5, text_begin, text_end, wrap_width, cpu_fine_clip);
        }

        public static void ImFontBuildLookupTable(global::ImGui.ImFont self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontBuildLookupTable(__arg0);
        }

        public static void ImFontClearOutputData(global::ImGui.ImFont self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontClearOutputData(__arg0);
        }

        public static void ImFontGrowIndex(global::ImGui.ImFont self, int new_size)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontGrowIndex(__arg0, new_size);
        }

        public static void ImFontAddGlyph(global::ImGui.ImFont self, ushort c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontAddGlyph(__arg0, c, x0, y0, x1, y1, u0, v0, u1, v1, advance_x);
        }

        public static void ImFontAddRemapChar(global::ImGui.ImFont self, ushort dst, ushort src, bool overwrite_dst)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontAddRemapChar(__arg0, dst, src, overwrite_dst);
        }

        public static void ImFontSetFallbackChar(global::ImGui.ImFont self, ushort c)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImFontSetFallbackChar(__arg0, c);
        }

        public static uint ImHashData(global::System.IntPtr data, ulong data_size, uint seed)
        {
            var __ret = __Internal.ImHashData(data, data_size, seed);
            return __ret;
        }

        public static uint ImHashStr(string data, ulong data_size, uint seed)
        {
            var __ret = __Internal.ImHashStr(data, data_size, seed);
            return __ret;
        }

        public static bool ImIsPowerOfTwo(int v)
        {
            var __ret = __Internal.ImIsPowerOfTwo(v);
            return __ret;
        }

        public static int ImUpperPowerOfTwo(int v)
        {
            var __ret = __Internal.ImUpperPowerOfTwo(v);
            return __ret;
        }

        public static int ImStricmp(string str1, string str2)
        {
            var __ret = __Internal.ImStricmp(str1, str2);
            return __ret;
        }

        public static int ImStrnicmp(string str1, string str2, ulong count)
        {
            var __ret = __Internal.ImStrnicmp(str1, str2, count);
            return __ret;
        }

        public static void ImStrncpy(sbyte* dst, string src, ulong count)
        {
            __Internal.ImStrncpy(dst, src, count);
        }

        public static sbyte* ImStrdup(string str)
        {
            var __ret = __Internal.ImStrdup(str);
            return __ret;
        }

        public static sbyte* ImStrdupcpy(sbyte* dst, ref ulong p_dst_size, string str)
        {
            fixed (ulong* __p_dst_size1 = &p_dst_size)
            {
                var __arg1 = __p_dst_size1;
                var __ret = __Internal.ImStrdupcpy(dst, __arg1, str);
                return __ret;
            }
        }

        public static string ImStrchrRange(string str_begin, string str_end, sbyte c)
        {
            var __ret = __Internal.ImStrchrRange(str_begin, str_end, c);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static int ImStrlenW(ref ushort str)
        {
            fixed (ushort* __str0 = &str)
            {
                var __arg0 = __str0;
                var __ret = __Internal.ImStrlenW(__arg0);
                return __ret;
            }
        }

        public static string ImStreolRange(string str, string str_end)
        {
            var __ret = __Internal.ImStreolRange(str, str_end);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static ushort* ImStrbolW(ref ushort buf_mid_line, ref ushort buf_begin)
        {
            fixed (ushort* __buf_mid_line0 = &buf_mid_line)
            {
                var __arg0 = __buf_mid_line0;
                fixed (ushort* __buf_begin1 = &buf_begin)
                {
                    var __arg1 = __buf_begin1;
                    var __ret = __Internal.ImStrbolW(__arg0, __arg1);
                    return __ret;
                }
            }
        }

        public static string ImStristr(string haystack, string haystack_end, string needle, string needle_end)
        {
            var __ret = __Internal.ImStristr(haystack, haystack_end, needle, needle_end);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static void ImStrTrimBlanks(sbyte* str)
        {
            __Internal.ImStrTrimBlanks(str);
        }

        public static string ImStrSkipBlank(string str)
        {
            var __ret = __Internal.ImStrSkipBlank(str);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static int ImFormatString(sbyte* buf, ulong buf_size, string fmt)
        {
            var __ret = __Internal.ImFormatString(buf, buf_size, fmt);
            return __ret;
        }

        public static string ImParseFormatFindStart(string format)
        {
            var __ret = __Internal.ImParseFormatFindStart(format);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static string ImParseFormatFindEnd(string format)
        {
            var __ret = __Internal.ImParseFormatFindEnd(format);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static string ImParseFormatTrimDecorations(string format, sbyte* buf, ulong buf_size)
        {
            var __ret = __Internal.ImParseFormatTrimDecorations(format, buf, buf_size);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static int ImParseFormatPrecision(string format, int default_value)
        {
            var __ret = __Internal.ImParseFormatPrecision(format, default_value);
            return __ret;
        }

        public static bool ImCharIsBlankA(sbyte c)
        {
            var __ret = __Internal.ImCharIsBlankA(c);
            return __ret;
        }

        public static bool ImCharIsBlankW(uint c)
        {
            var __ret = __Internal.ImCharIsBlankW(c);
            return __ret;
        }

        public static int ImTextStrToUtf8(sbyte* buf, int buf_size, ref ushort in_text, ref ushort in_text_end)
        {
            fixed (ushort* __in_text2 = &in_text)
            {
                var __arg2 = __in_text2;
                fixed (ushort* __in_text_end3 = &in_text_end)
                {
                    var __arg3 = __in_text_end3;
                    var __ret = __Internal.ImTextStrToUtf8(buf, buf_size, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        public static int ImTextCharFromUtf8(ref uint out_char, string in_text, string in_text_end)
        {
            fixed (uint* __out_char0 = &out_char)
            {
                var __arg0 = __out_char0;
                var __ret = __Internal.ImTextCharFromUtf8(__arg0, in_text, in_text_end);
                return __ret;
            }
        }

        public static int ImTextStrFromUtf8(ref ushort buf, int buf_size, string in_text, string in_text_end, sbyte** in_remaining)
        {
            fixed (ushort* __buf0 = &buf)
            {
                var __arg0 = __buf0;
                var __ret = __Internal.ImTextStrFromUtf8(__arg0, buf_size, in_text, in_text_end, in_remaining);
                return __ret;
            }
        }

        public static int ImTextCountCharsFromUtf8(string in_text, string in_text_end)
        {
            var __ret = __Internal.ImTextCountCharsFromUtf8(in_text, in_text_end);
            return __ret;
        }

        public static int ImTextCountUtf8BytesFromChar(string in_text, string in_text_end)
        {
            var __ret = __Internal.ImTextCountUtf8BytesFromChar(in_text, in_text_end);
            return __ret;
        }

        public static int ImTextCountUtf8BytesFromStr(ref ushort in_text, ref ushort in_text_end)
        {
            fixed (ushort* __in_text0 = &in_text)
            {
                var __arg0 = __in_text0;
                fixed (ushort* __in_text_end1 = &in_text_end)
                {
                    var __arg1 = __in_text_end1;
                    var __ret = __Internal.ImTextCountUtf8BytesFromStr(__arg0, __arg1);
                    return __ret;
                }
            }
        }

        public static global::System.IntPtr ImFileOpen(string filename, string mode)
        {
            var __ret = __Internal.ImFileOpen(filename, mode);
            return __ret;
        }

        public static bool ImFileClose(global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileClose(file);
            return __ret;
        }

        public static ulong ImFileGetSize(global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileGetSize(file);
            return __ret;
        }

        public static ulong ImFileRead(global::System.IntPtr data, ulong size, ulong count, global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileRead(data, size, count, file);
            return __ret;
        }

        public static ulong ImFileWrite(global::System.IntPtr data, ulong size, ulong count, global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileWrite(data, size, count, file);
            return __ret;
        }

        public static global::System.IntPtr ImFileLoadToMemory(string filename, string mode, ref ulong out_file_size, int padding_bytes)
        {
            fixed (ulong* __out_file_size2 = &out_file_size)
            {
                var __arg2 = __out_file_size2;
                var __ret = __Internal.ImFileLoadToMemory(filename, mode, __arg2, padding_bytes);
                return __ret;
            }
        }

        public static float ImPowFloat(float x, float y)
        {
            var __ret = __Internal.ImPowFloat(x, y);
            return __ret;
        }

        public static double ImPowdouble(double x, double y)
        {
            var __ret = __Internal.ImPowdouble(x, y);
            return __ret;
        }

        public static void ImMin(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 lhs, global::ImGui.ImVec2 rhs)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg1 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg2 = rhs.__Instance;
            __Internal.ImMin(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2);
        }

        public static void ImMax(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 lhs, global::ImGui.ImVec2 rhs)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg1 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg2 = rhs.__Instance;
            __Internal.ImMax(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2);
        }

        public static void ImClamp(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 v, global::ImGui.ImVec2 mn, global::ImGui.ImVec2 mx)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            if (ReferenceEquals(mn, null))
                throw new global::System.ArgumentNullException("mn", "Cannot be null because it is passed by value.");
            var __arg2 = mn.__Instance;
            if (ReferenceEquals(mx, null))
                throw new global::System.ArgumentNullException("mx", "Cannot be null because it is passed by value.");
            var __arg3 = mx.__Instance;
            __Internal.ImClamp(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3);
        }

        public static void ImLerpVec2Float(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 a, global::ImGui.ImVec2 b, float t)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            __Internal.ImLerpVec2Float(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, t);
        }

        public static void ImLerpVec2Vec2(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 a, global::ImGui.ImVec2 b, global::ImGui.ImVec2 t)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(t, null))
                throw new global::System.ArgumentNullException("t", "Cannot be null because it is passed by value.");
            var __arg3 = t.__Instance;
            __Internal.ImLerpVec2Vec2(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3);
        }

        public static void ImLerpVec4(global::ImGui.ImVec4 pOut, global::ImGui.ImVec4 a, global::ImGui.ImVec4 b, float t)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            __Internal.ImLerpVec4(__arg0, __arg1, __arg2, t);
        }

        public static float ImSaturate(float f)
        {
            var __ret = __Internal.ImSaturate(f);
            return __ret;
        }

        public static float ImLengthSqrVec2(global::ImGui.ImVec2 lhs)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            var __ret = __Internal.ImLengthSqrVec2(*(global::ImGui.ImVec2.__Internal*) __arg0);
            return __ret;
        }

        public static float ImLengthSqrVec4(global::ImGui.ImVec4 lhs)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            var __ret = __Internal.ImLengthSqrVec4(__arg0);
            return __ret;
        }

        public static float ImInvLength(global::ImGui.ImVec2 lhs, float fail_value)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            var __ret = __Internal.ImInvLength(*(global::ImGui.ImVec2.__Internal*) __arg0, fail_value);
            return __ret;
        }

        public static float ImFloorFloat(float f)
        {
            var __ret = __Internal.ImFloorFloat(f);
            return __ret;
        }

        public static void ImFloorVec2(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 v)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            __Internal.ImFloorVec2(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1);
        }

        public static int ImModPositive(int a, int b)
        {
            var __ret = __Internal.ImModPositive(a, b);
            return __ret;
        }

        public static float ImDot(global::ImGui.ImVec2 a, global::ImGui.ImVec2 b)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            var __ret = __Internal.ImDot(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static void ImRotate(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 v, float cos_a, float sin_a)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            __Internal.ImRotate(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, cos_a, sin_a);
        }

        public static float ImLinearSweep(float current, float target, float speed)
        {
            var __ret = __Internal.ImLinearSweep(current, target, speed);
            return __ret;
        }

        public static void ImMul(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 lhs, global::ImGui.ImVec2 rhs)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg1 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg2 = rhs.__Instance;
            __Internal.ImMul(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2);
        }

        public static void ImBezierCalc(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 p1, global::ImGui.ImVec2 p2, global::ImGui.ImVec2 p3, global::ImGui.ImVec2 p4, float t)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImBezierCalc(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, t);
        }

        public static void ImBezierClosestPoint(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 p1, global::ImGui.ImVec2 p2, global::ImGui.ImVec2 p3, global::ImGui.ImVec2 p4, global::ImGui.ImVec2 p, int num_segments)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg5 = p.__Instance;
            __Internal.ImBezierClosestPoint(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, *(global::ImGui.ImVec2.__Internal*) __arg5, num_segments);
        }

        public static void ImBezierClosestPointCasteljau(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 p1, global::ImGui.ImVec2 p2, global::ImGui.ImVec2 p3, global::ImGui.ImVec2 p4, global::ImGui.ImVec2 p, float tess_tol)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg5 = p.__Instance;
            __Internal.ImBezierClosestPointCasteljau(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, *(global::ImGui.ImVec2.__Internal*) __arg5, tess_tol);
        }

        public static void ImLineClosestPoint(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 a, global::ImGui.ImVec2 b, global::ImGui.ImVec2 p)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg3 = p.__Instance;
            __Internal.ImLineClosestPoint(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3);
        }

        public static bool ImTriangleContainsPoint(global::ImGui.ImVec2 a, global::ImGui.ImVec2 b, global::ImGui.ImVec2 c, global::ImGui.ImVec2 p)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg2 = c.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg3 = p.__Instance;
            var __ret = __Internal.ImTriangleContainsPoint(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3);
            return __ret;
        }

        public static void ImTriangleClosestPoint(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 a, global::ImGui.ImVec2 b, global::ImGui.ImVec2 c, global::ImGui.ImVec2 p)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg3 = c.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg4 = p.__Instance;
            __Internal.ImTriangleClosestPoint(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4);
        }

        public static void ImTriangleBarycentricCoords(global::ImGui.ImVec2 a, global::ImGui.ImVec2 b, global::ImGui.ImVec2 c, global::ImGui.ImVec2 p, float out_u, float out_v, float out_w)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg2 = c.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg3 = p.__Instance;
            __Internal.ImTriangleBarycentricCoords(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, *(global::ImGui.ImVec2.__Internal*) __arg3, out_u, out_v, out_w);
        }

        public static float ImTriangleArea(global::ImGui.ImVec2 a, global::ImGui.ImVec2 b, global::ImGui.ImVec2 c)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg2 = c.__Instance;
            var __ret = __Internal.ImTriangleArea(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2);
            return __ret;
        }

        public static int ImGetDirQuadrantFromDelta(float dx, float dy)
        {
            var __ret = __Internal.ImGetDirQuadrantFromDelta(dx, dy);
            return __ret;
        }

        public static global::ImGui.ImBoolVector ImBoolVectorImBoolVector()
        {
            var __ret = __Internal.ImBoolVectorImBoolVector();
            global::ImGui.ImBoolVector __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImBoolVector.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImBoolVector) global::ImGui.ImBoolVector.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImBoolVector.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImBoolVector_destroy(global::ImGui.ImBoolVector self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImBoolVector_destroy(__arg0);
        }

        public static void ImBoolVectorResize(global::ImGui.ImBoolVector self, int sz)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImBoolVectorResize(__arg0, sz);
        }

        public static void ImBoolVectorClear(global::ImGui.ImBoolVector self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImBoolVectorClear(__arg0);
        }

        public static bool ImBoolVectorGetBit(global::ImGui.ImBoolVector self, int n)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImBoolVectorGetBit(__arg0, n);
            return __ret;
        }

        public static void ImBoolVectorSetBit(global::ImGui.ImBoolVector self, int n, bool v)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImBoolVectorSetBit(__arg0, n, v);
        }

        public static global::ImGui.ImVec1 ImVec1ImVec1Nil()
        {
            var __ret = __Internal.ImVec1ImVec1Nil();
            global::ImGui.ImVec1 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImVec1.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImVec1) global::ImGui.ImVec1.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImVec1.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImVec1_destroy(global::ImGui.ImVec1 self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImVec1_destroy(__arg0);
        }

        public static global::ImGui.ImVec1 ImVec1ImVec1Float(float _x)
        {
            var __ret = __Internal.ImVec1ImVec1Float(_x);
            global::ImGui.ImVec1 __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImVec1.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImVec1) global::ImGui.ImVec1.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImVec1.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImVec2ih ImVec2ihImVec2ihNil()
        {
            var __ret = __Internal.ImVec2ihImVec2ihNil();
            global::ImGui.ImVec2ih __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImVec2ih.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImVec2ih) global::ImGui.ImVec2ih.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImVec2ih.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImVec2ih_destroy(global::ImGui.ImVec2ih self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImVec2ih_destroy(__arg0);
        }

        public static global::ImGui.ImVec2ih ImVec2ihImVec2ihshort(short _x, short _y)
        {
            var __ret = __Internal.ImVec2ihImVec2ihshort(_x, _y);
            global::ImGui.ImVec2ih __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImVec2ih.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImVec2ih) global::ImGui.ImVec2ih.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImVec2ih.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImRect ImRectImRectNil()
        {
            var __ret = __Internal.ImRectImRectNil();
            global::ImGui.ImRect __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImRect.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImRect) global::ImGui.ImRect.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImRect.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImRect_destroy(global::ImGui.ImRect self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImRect_destroy(__arg0);
        }

        public static global::ImGui.ImRect ImRectImRectVec2(global::ImGui.ImVec2 min, global::ImGui.ImVec2 max)
        {
            if (ReferenceEquals(min, null))
                throw new global::System.ArgumentNullException("min", "Cannot be null because it is passed by value.");
            var __arg0 = min.__Instance;
            if (ReferenceEquals(max, null))
                throw new global::System.ArgumentNullException("max", "Cannot be null because it is passed by value.");
            var __arg1 = max.__Instance;
            var __ret = __Internal.ImRectImRectVec2(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1);
            global::ImGui.ImRect __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImRect.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImRect) global::ImGui.ImRect.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImRect.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImRect ImRectImRectVec4(global::ImGui.ImVec4 v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg0 = v.__Instance;
            var __ret = __Internal.ImRectImRectVec4(__arg0);
            global::ImGui.ImRect __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImRect.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImRect) global::ImGui.ImRect.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImRect.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImRect ImRectImRectFloat(float x1, float y1, float x2, float y2)
        {
            var __ret = __Internal.ImRectImRectFloat(x1, y1, x2, y2);
            global::ImGui.ImRect __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImRect.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImRect) global::ImGui.ImRect.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImRect.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImRectGetCenter(global::ImGui.ImVec2 pOut, global::ImGui.ImRect self)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetCenter(__arg0, __arg1);
        }

        public static void ImRectGetSize(global::ImGui.ImVec2 pOut, global::ImGui.ImRect self)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetSize(__arg0, __arg1);
        }

        public static float ImRectGetWidth(global::ImGui.ImRect self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImRectGetWidth(__arg0);
            return __ret;
        }

        public static float ImRectGetHeight(global::ImGui.ImRect self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImRectGetHeight(__arg0);
            return __ret;
        }

        public static void ImRectGetTL(global::ImGui.ImVec2 pOut, global::ImGui.ImRect self)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetTL(__arg0, __arg1);
        }

        public static void ImRectGetTR(global::ImGui.ImVec2 pOut, global::ImGui.ImRect self)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetTR(__arg0, __arg1);
        }

        public static void ImRectGetBL(global::ImGui.ImVec2 pOut, global::ImGui.ImRect self)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetBL(__arg0, __arg1);
        }

        public static void ImRectGetBR(global::ImGui.ImVec2 pOut, global::ImGui.ImRect self)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetBR(__arg0, __arg1);
        }

        public static bool ImRectContainsVec2(global::ImGui.ImRect self, global::ImGui.ImVec2 p)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg1 = p.__Instance;
            var __ret = __Internal.ImRectContainsVec2(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool ImRectContainsRect(global::ImGui.ImRect self, global::ImGui.ImRect r)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            var __ret = __Internal.ImRectContainsRect(__arg0, __arg1);
            return __ret;
        }

        public static bool ImRectOverlaps(global::ImGui.ImRect self, global::ImGui.ImRect r)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            var __ret = __Internal.ImRectOverlaps(__arg0, __arg1);
            return __ret;
        }

        public static void ImRectAddVec2(global::ImGui.ImRect self, global::ImGui.ImVec2 p)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg1 = p.__Instance;
            __Internal.ImRectAddVec2(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1);
        }

        public static void ImRectAddRect(global::ImGui.ImRect self, global::ImGui.ImRect r)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            __Internal.ImRectAddRect(__arg0, __arg1);
        }

        public static void ImRectExpandFloat(global::ImGui.ImRect self, float amount)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImRectExpandFloat(__arg0, amount);
        }

        public static void ImRectExpandVec2(global::ImGui.ImRect self, global::ImGui.ImVec2 amount)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(amount, null))
                throw new global::System.ArgumentNullException("amount", "Cannot be null because it is passed by value.");
            var __arg1 = amount.__Instance;
            __Internal.ImRectExpandVec2(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1);
        }

        public static void ImRectTranslate(global::ImGui.ImRect self, global::ImGui.ImVec2 d)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(d, null))
                throw new global::System.ArgumentNullException("d", "Cannot be null because it is passed by value.");
            var __arg1 = d.__Instance;
            __Internal.ImRectTranslate(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1);
        }

        public static void ImRectTranslateX(global::ImGui.ImRect self, float dx)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImRectTranslateX(__arg0, dx);
        }

        public static void ImRectTranslateY(global::ImGui.ImRect self, float dy)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImRectTranslateY(__arg0, dy);
        }

        public static void ImRectClipWith(global::ImGui.ImRect self, global::ImGui.ImRect r)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            __Internal.ImRectClipWith(__arg0, __arg1);
        }

        public static void ImRectClipWithFull(global::ImGui.ImRect self, global::ImGui.ImRect r)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            __Internal.ImRectClipWithFull(__arg0, __arg1);
        }

        public static void ImRectFloor(global::ImGui.ImRect self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImRectFloor(__arg0);
        }

        public static bool ImRectIsInverted(global::ImGui.ImRect self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImRectIsInverted(__arg0);
            return __ret;
        }

        public static global::ImGui.ImGuiStyleMod ImGuiStyleModImGuiStyleModInt(int idx, int v)
        {
            var __ret = __Internal.ImGuiStyleModImGuiStyleModInt(idx, v);
            global::ImGui.ImGuiStyleMod __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiStyleMod.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiStyleMod) global::ImGui.ImGuiStyleMod.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiStyleMod.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiStyleMod_destroy(global::ImGui.ImGuiStyleMod self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStyleMod_destroy(__arg0);
        }

        public static global::ImGui.ImGuiStyleMod ImGuiStyleModImGuiStyleModFloat(int idx, float v)
        {
            var __ret = __Internal.ImGuiStyleModImGuiStyleModFloat(idx, v);
            global::ImGui.ImGuiStyleMod __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiStyleMod.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiStyleMod) global::ImGui.ImGuiStyleMod.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiStyleMod.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiStyleMod ImGuiStyleModImGuiStyleModVec2(int idx, global::ImGui.ImVec2 v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            var __ret = __Internal.ImGuiStyleModImGuiStyleModVec2(idx, *(global::ImGui.ImVec2.__Internal*) __arg1);
            global::ImGui.ImGuiStyleMod __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiStyleMod.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiStyleMod) global::ImGui.ImGuiStyleMod.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiStyleMod.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiMenuColumns ImGuiMenuColumnsImGuiMenuColumns()
        {
            var __ret = __Internal.ImGuiMenuColumnsImGuiMenuColumns();
            global::ImGui.ImGuiMenuColumns __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiMenuColumns.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiMenuColumns) global::ImGui.ImGuiMenuColumns.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiMenuColumns.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiMenuColumns_destroy(global::ImGui.ImGuiMenuColumns self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiMenuColumns_destroy(__arg0);
        }

        public static void ImGuiMenuColumnsUpdate(global::ImGui.ImGuiMenuColumns self, int count, float spacing, bool clear)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiMenuColumnsUpdate(__arg0, count, spacing, clear);
        }

        public static float ImGuiMenuColumnsDeclColumns(global::ImGui.ImGuiMenuColumns self, float w0, float w1, float w2)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiMenuColumnsDeclColumns(__arg0, w0, w1, w2);
            return __ret;
        }

        public static float ImGuiMenuColumnsCalcExtraSpace(global::ImGui.ImGuiMenuColumns self, float avail_w)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiMenuColumnsCalcExtraSpace(__arg0, avail_w);
            return __ret;
        }

        public static global::ImGui.ImGuiInputTextState ImGuiInputTextStateImGuiInputTextState()
        {
            var __ret = __Internal.ImGuiInputTextStateImGuiInputTextState();
            global::ImGui.ImGuiInputTextState __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiInputTextState.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiInputTextState) global::ImGui.ImGuiInputTextState.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiInputTextState.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiInputTextState_destroy(global::ImGui.ImGuiInputTextState self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextState_destroy(__arg0);
        }

        public static void ImGuiInputTextStateClearText(global::ImGui.ImGuiInputTextState self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateClearText(__arg0);
        }

        public static void ImGuiInputTextStateClearFreeMemory(global::ImGui.ImGuiInputTextState self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateClearFreeMemory(__arg0);
        }

        public static int ImGuiInputTextStateGetUndoAvailCount(global::ImGui.ImGuiInputTextState self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetUndoAvailCount(__arg0);
            return __ret;
        }

        public static int ImGuiInputTextStateGetRedoAvailCount(global::ImGui.ImGuiInputTextState self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetRedoAvailCount(__arg0);
            return __ret;
        }

        public static void ImGuiInputTextStateOnKeyPressed(global::ImGui.ImGuiInputTextState self, int key)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateOnKeyPressed(__arg0, key);
        }

        public static void ImGuiInputTextStateCursorAnimReset(global::ImGui.ImGuiInputTextState self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateCursorAnimReset(__arg0);
        }

        public static void ImGuiInputTextStateCursorClamp(global::ImGui.ImGuiInputTextState self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateCursorClamp(__arg0);
        }

        public static bool ImGuiInputTextStateHasSelection(global::ImGui.ImGuiInputTextState self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateHasSelection(__arg0);
            return __ret;
        }

        public static void ImGuiInputTextStateClearSelection(global::ImGui.ImGuiInputTextState self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateClearSelection(__arg0);
        }

        public static void ImGuiInputTextStateSelectAll(global::ImGui.ImGuiInputTextState self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateSelectAll(__arg0);
        }

        public static global::ImGui.ImGuiWindowSettings ImGuiWindowSettingsImGuiWindowSettings()
        {
            var __ret = __Internal.ImGuiWindowSettingsImGuiWindowSettings();
            global::ImGui.ImGuiWindowSettings __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiWindowSettings.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiWindowSettings) global::ImGui.ImGuiWindowSettings.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiWindowSettings.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiWindowSettings_destroy(global::ImGui.ImGuiWindowSettings self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowSettings_destroy(__arg0);
        }

        public static sbyte* ImGuiWindowSettingsGetName(global::ImGui.ImGuiWindowSettings self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowSettingsGetName(__arg0);
            return __ret;
        }

        public static global::ImGui.ImGuiSettingsHandler ImGuiSettingsHandlerImGuiSettingsHandler()
        {
            var __ret = __Internal.ImGuiSettingsHandlerImGuiSettingsHandler();
            global::ImGui.ImGuiSettingsHandler __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiSettingsHandler.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiSettingsHandler) global::ImGui.ImGuiSettingsHandler.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiSettingsHandler.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiSettingsHandler_destroy(global::ImGui.ImGuiSettingsHandler self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiSettingsHandler_destroy(__arg0);
        }

        public static global::ImGui.ImGuiPopupData ImGuiPopupDataImGuiPopupData()
        {
            var __ret = __Internal.ImGuiPopupDataImGuiPopupData();
            global::ImGui.ImGuiPopupData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiPopupData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiPopupData) global::ImGui.ImGuiPopupData.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiPopupData.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiPopupData_destroy(global::ImGui.ImGuiPopupData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPopupData_destroy(__arg0);
        }

        public static global::ImGui.ImGuiColumnData ImGuiColumnDataImGuiColumnData()
        {
            var __ret = __Internal.ImGuiColumnDataImGuiColumnData();
            global::ImGui.ImGuiColumnData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiColumnData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiColumnData) global::ImGui.ImGuiColumnData.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiColumnData.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiColumnData_destroy(global::ImGui.ImGuiColumnData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiColumnData_destroy(__arg0);
        }

        public static global::ImGui.ImGuiColumns ImGuiColumnsImGuiColumns()
        {
            var __ret = __Internal.ImGuiColumnsImGuiColumns();
            global::ImGui.ImGuiColumns __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiColumns.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiColumns) global::ImGui.ImGuiColumns.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiColumns.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiColumns_destroy(global::ImGui.ImGuiColumns self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiColumns_destroy(__arg0);
        }

        public static void ImGuiColumnsClear(global::ImGui.ImGuiColumns self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiColumnsClear(__arg0);
        }

        public static global::ImGui.ImDrawListSharedData ImDrawListSharedDataImDrawListSharedData()
        {
            var __ret = __Internal.ImDrawListSharedDataImDrawListSharedData();
            global::ImGui.ImDrawListSharedData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawListSharedData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawListSharedData) global::ImGui.ImDrawListSharedData.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawListSharedData.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImDrawListSharedData_destroy(global::ImGui.ImDrawListSharedData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSharedData_destroy(__arg0);
        }

        public static void ImDrawListSharedDataSetCircleSegmentMaxError(global::ImGui.ImDrawListSharedData self, float max_error)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSharedDataSetCircleSegmentMaxError(__arg0, max_error);
        }

        public static void ImDrawDataBuilderClear(global::ImGui.ImDrawDataBuilder self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataBuilderClear(__arg0);
        }

        public static void ImDrawDataBuilderClearFreeMemory(global::ImGui.ImDrawDataBuilder self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataBuilderClearFreeMemory(__arg0);
        }

        public static void ImDrawDataBuilderFlattenIntoSingleLayer(global::ImGui.ImDrawDataBuilder self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataBuilderFlattenIntoSingleLayer(__arg0);
        }

        public static global::ImGui.ImGuiNavMoveResult ImGuiNavMoveResultImGuiNavMoveResult()
        {
            var __ret = __Internal.ImGuiNavMoveResultImGuiNavMoveResult();
            global::ImGui.ImGuiNavMoveResult __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiNavMoveResult.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiNavMoveResult) global::ImGui.ImGuiNavMoveResult.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiNavMoveResult.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiNavMoveResult_destroy(global::ImGui.ImGuiNavMoveResult self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNavMoveResult_destroy(__arg0);
        }

        public static void ImGuiNavMoveResultClear(global::ImGui.ImGuiNavMoveResult self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNavMoveResultClear(__arg0);
        }

        public static global::ImGui.ImGuiNextWindowData ImGuiNextWindowDataImGuiNextWindowData()
        {
            var __ret = __Internal.ImGuiNextWindowDataImGuiNextWindowData();
            global::ImGui.ImGuiNextWindowData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiNextWindowData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiNextWindowData) global::ImGui.ImGuiNextWindowData.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiNextWindowData.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiNextWindowData_destroy(global::ImGui.ImGuiNextWindowData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextWindowData_destroy(__arg0);
        }

        public static void ImGuiNextWindowDataClearFlags(global::ImGui.ImGuiNextWindowData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextWindowDataClearFlags(__arg0);
        }

        public static global::ImGui.ImGuiNextItemData ImGuiNextItemDataImGuiNextItemData()
        {
            var __ret = __Internal.ImGuiNextItemDataImGuiNextItemData();
            global::ImGui.ImGuiNextItemData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiNextItemData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiNextItemData) global::ImGui.ImGuiNextItemData.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiNextItemData.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiNextItemData_destroy(global::ImGui.ImGuiNextItemData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextItemData_destroy(__arg0);
        }

        public static void ImGuiNextItemDataClearFlags(global::ImGui.ImGuiNextItemData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextItemDataClearFlags(__arg0);
        }

        public static global::ImGui.ImGuiPtrOrIndex ImGuiPtrOrIndexImGuiPtrOrIndexPtr(global::System.IntPtr ptr)
        {
            var __ret = __Internal.ImGuiPtrOrIndexImGuiPtrOrIndexPtr(ptr);
            global::ImGui.ImGuiPtrOrIndex __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiPtrOrIndex.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiPtrOrIndex) global::ImGui.ImGuiPtrOrIndex.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiPtrOrIndex.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiPtrOrIndex_destroy(global::ImGui.ImGuiPtrOrIndex self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPtrOrIndex_destroy(__arg0);
        }

        public static global::ImGui.ImGuiPtrOrIndex ImGuiPtrOrIndexImGuiPtrOrIndexInt(int index)
        {
            var __ret = __Internal.ImGuiPtrOrIndexImGuiPtrOrIndexInt(index);
            global::ImGui.ImGuiPtrOrIndex __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiPtrOrIndex.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiPtrOrIndex) global::ImGui.ImGuiPtrOrIndex.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiPtrOrIndex.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiContext ImGuiContextImGuiContext(global::ImGui.ImFontAtlas shared_font_atlas)
        {
            var __arg0 = ReferenceEquals(shared_font_atlas, null) ? global::System.IntPtr.Zero : shared_font_atlas.__Instance;
            var __ret = __Internal.ImGuiContextImGuiContext(__arg0);
            global::ImGui.ImGuiContext __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiContext.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiContext) global::ImGui.ImGuiContext.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiContext.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiContext_destroy(global::ImGui.ImGuiContext self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiContext_destroy(__arg0);
        }

        public static global::ImGui.ImGuiWindowTempData ImGuiWindowTempDataImGuiWindowTempData()
        {
            var __ret = __Internal.ImGuiWindowTempDataImGuiWindowTempData();
            global::ImGui.ImGuiWindowTempData __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiWindowTempData.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiWindowTempData) global::ImGui.ImGuiWindowTempData.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiWindowTempData.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiWindowTempData_destroy(global::ImGui.ImGuiWindowTempData self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowTempData_destroy(__arg0);
        }

        public static global::ImGui.ImGuiWindow ImGuiWindowImGuiWindow(global::ImGui.ImGuiContext context, string name)
        {
            var __arg0 = ReferenceEquals(context, null) ? global::System.IntPtr.Zero : context.__Instance;
            var __ret = __Internal.ImGuiWindowImGuiWindow(__arg0, name);
            global::ImGui.ImGuiWindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiWindow_destroy(global::ImGui.ImGuiWindow self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindow_destroy(__arg0);
        }

        public static uint ImGuiWindowGetIDStr(global::ImGui.ImGuiWindow self, string str, string str_end)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDStr(__arg0, str, str_end);
            return __ret;
        }

        public static uint ImGuiWindowGetIDPtr(global::ImGui.ImGuiWindow self, global::System.IntPtr ptr)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDPtr(__arg0, ptr);
            return __ret;
        }

        public static uint ImGuiWindowGetIDInt(global::ImGui.ImGuiWindow self, int n)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDInt(__arg0, n);
            return __ret;
        }

        public static uint ImGuiWindowGetIDNoKeepAliveStr(global::ImGui.ImGuiWindow self, string str, string str_end)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDNoKeepAliveStr(__arg0, str, str_end);
            return __ret;
        }

        public static uint ImGuiWindowGetIDNoKeepAlivePtr(global::ImGui.ImGuiWindow self, global::System.IntPtr ptr)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDNoKeepAlivePtr(__arg0, ptr);
            return __ret;
        }

        public static uint ImGuiWindowGetIDNoKeepAliveInt(global::ImGui.ImGuiWindow self, int n)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDNoKeepAliveInt(__arg0, n);
            return __ret;
        }

        public static uint ImGuiWindowGetIDFromRectangle(global::ImGui.ImGuiWindow self, global::ImGui.ImRect r_abs)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r_abs, null))
                throw new global::System.ArgumentNullException("r_abs", "Cannot be null because it is passed by value.");
            var __arg1 = r_abs.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDFromRectangle(__arg0, __arg1);
            return __ret;
        }

        public static void ImGuiWindowRect(global::ImGui.ImRect pOut, global::ImGui.ImGuiWindow self)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowRect(__arg0, __arg1);
        }

        public static float ImGuiWindowCalcFontSize(global::ImGui.ImGuiWindow self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowCalcFontSize(__arg0);
            return __ret;
        }

        public static float ImGuiWindowTitleBarHeight(global::ImGui.ImGuiWindow self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowTitleBarHeight(__arg0);
            return __ret;
        }

        public static void ImGuiWindowTitleBarRect(global::ImGui.ImRect pOut, global::ImGui.ImGuiWindow self)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowTitleBarRect(__arg0, __arg1);
        }

        public static float ImGuiWindowMenuBarHeight(global::ImGui.ImGuiWindow self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowMenuBarHeight(__arg0);
            return __ret;
        }

        public static void ImGuiWindowMenuBarRect(global::ImGui.ImRect pOut, global::ImGui.ImGuiWindow self)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowMenuBarRect(__arg0, __arg1);
        }

        public static global::ImGui.ImGuiItemHoveredDataBackup ImGuiItemHoveredDataBackupImGuiItemHoveredDataBackup()
        {
            var __ret = __Internal.ImGuiItemHoveredDataBackupImGuiItemHoveredDataBackup();
            global::ImGui.ImGuiItemHoveredDataBackup __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiItemHoveredDataBackup.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiItemHoveredDataBackup) global::ImGui.ImGuiItemHoveredDataBackup.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiItemHoveredDataBackup.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiItemHoveredDataBackup_destroy(global::ImGui.ImGuiItemHoveredDataBackup self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiItemHoveredDataBackup_destroy(__arg0);
        }

        public static void ImGuiItemHoveredDataBackupBackup(global::ImGui.ImGuiItemHoveredDataBackup self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiItemHoveredDataBackupBackup(__arg0);
        }

        public static void ImGuiItemHoveredDataBackupRestore(global::ImGui.ImGuiItemHoveredDataBackup self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiItemHoveredDataBackupRestore(__arg0);
        }

        public static global::ImGui.ImGuiTabItem ImGuiTabItemImGuiTabItem()
        {
            var __ret = __Internal.ImGuiTabItemImGuiTabItem();
            global::ImGui.ImGuiTabItem __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiTabItem.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiTabItem) global::ImGui.ImGuiTabItem.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiTabItem.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiTabItem_destroy(global::ImGui.ImGuiTabItem self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTabItem_destroy(__arg0);
        }

        public static global::ImGui.ImGuiTabBar ImGuiTabBarImGuiTabBar()
        {
            var __ret = __Internal.ImGuiTabBarImGuiTabBar();
            global::ImGui.ImGuiTabBar __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiTabBar.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiTabBar) global::ImGui.ImGuiTabBar.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiTabBar.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImGuiTabBar_destroy(global::ImGui.ImGuiTabBar self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTabBar_destroy(__arg0);
        }

        public static int ImGuiTabBarGetTabOrder(global::ImGui.ImGuiTabBar self, global::ImGui.ImGuiTabItem tab)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(tab, null) ? global::System.IntPtr.Zero : tab.__Instance;
            var __ret = __Internal.ImGuiTabBarGetTabOrder(__arg0, __arg1);
            return __ret;
        }

        public static string ImGuiTabBarGetTabName(global::ImGui.ImGuiTabBar self, global::ImGui.ImGuiTabItem tab)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            var __arg1 = ReferenceEquals(tab, null) ? global::System.IntPtr.Zero : tab.__Instance;
            var __ret = __Internal.ImGuiTabBarGetTabName(__arg0, __arg1);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static global::ImGui.ImGuiWindow GetCurrentWindowRead()
        {
            var __ret = __Internal.GetCurrentWindowRead();
            global::ImGui.ImGuiWindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiWindow GetCurrentWindow()
        {
            var __ret = __Internal.GetCurrentWindow();
            global::ImGui.ImGuiWindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiWindow FindWindowByID(uint id)
        {
            var __ret = __Internal.FindWindowByID(id);
            global::ImGui.ImGuiWindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiWindow FindWindowByName(string name)
        {
            var __ret = __Internal.FindWindowByName(name);
            global::ImGui.ImGuiWindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(__ret);
            return __result0;
        }

        public static void UpdateWindowParentAndRootLinks(global::ImGui.ImGuiWindow window, int flags, global::ImGui.ImGuiWindow parent_window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg2 = ReferenceEquals(parent_window, null) ? global::System.IntPtr.Zero : parent_window.__Instance;
            __Internal.UpdateWindowParentAndRootLinks(__arg0, flags, __arg2);
        }

        public static void CalcWindowExpectedSize(global::ImGui.ImVec2 pOut, global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.CalcWindowExpectedSize(__arg0, __arg1);
        }

        public static bool IsWindowChildOf(global::ImGui.ImGuiWindow window, global::ImGui.ImGuiWindow potential_parent)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __arg1 = ReferenceEquals(potential_parent, null) ? global::System.IntPtr.Zero : potential_parent.__Instance;
            var __ret = __Internal.IsWindowChildOf(__arg0, __arg1);
            return __ret;
        }

        public static bool IsWindowNavFocusable(global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.IsWindowNavFocusable(__arg0);
            return __ret;
        }

        public static void GetWindowAllowedExtentRect(global::ImGui.ImRect pOut, global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GetWindowAllowedExtentRect(__arg0, __arg1);
        }

        public static void SetWindowPosWindowPtr(global::ImGui.ImGuiWindow window, global::ImGui.ImVec2 pos, int cond)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.SetWindowPosWindowPtr(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowSizeWindowPtr(global::ImGui.ImGuiWindow window, global::ImGui.ImVec2 size, int cond)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            __Internal.SetWindowSizeWindowPtr(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowCollapsedWindowPtr(global::ImGui.ImGuiWindow window, bool collapsed, int cond)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetWindowCollapsedWindowPtr(__arg0, collapsed, cond);
        }

        public static void FocusWindow(global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.FocusWindow(__arg0);
        }

        public static void FocusTopMostWindowUnderOne(global::ImGui.ImGuiWindow under_this_window, global::ImGui.ImGuiWindow ignore_window)
        {
            var __arg0 = ReferenceEquals(under_this_window, null) ? global::System.IntPtr.Zero : under_this_window.__Instance;
            var __arg1 = ReferenceEquals(ignore_window, null) ? global::System.IntPtr.Zero : ignore_window.__Instance;
            __Internal.FocusTopMostWindowUnderOne(__arg0, __arg1);
        }

        public static void BringWindowToFocusFront(global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.BringWindowToFocusFront(__arg0);
        }

        public static void BringWindowToDisplayFront(global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.BringWindowToDisplayFront(__arg0);
        }

        public static void BringWindowToDisplayBack(global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.BringWindowToDisplayBack(__arg0);
        }

        public static void SetCurrentFont(global::ImGui.ImFont font)
        {
            var __arg0 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            __Internal.SetCurrentFont(__arg0);
        }

        public static global::ImGui.ImFont GetDefaultFont()
        {
            var __ret = __Internal.GetDefaultFont();
            global::ImGui.ImFont __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImFont.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImFont) global::ImGui.ImFont.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImFont.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImDrawList GetForegroundDrawListWindowPtr(global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetForegroundDrawListWindowPtr(__arg0);
            global::ImGui.ImDrawList __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImDrawList.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImDrawList) global::ImGui.ImDrawList.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImDrawList.__CreateInstance(__ret);
            return __result0;
        }

        public static void Initialize(global::ImGui.ImGuiContext context)
        {
            var __arg0 = ReferenceEquals(context, null) ? global::System.IntPtr.Zero : context.__Instance;
            __Internal.Initialize(__arg0);
        }

        public static void Shutdown(global::ImGui.ImGuiContext context)
        {
            var __arg0 = ReferenceEquals(context, null) ? global::System.IntPtr.Zero : context.__Instance;
            __Internal.Shutdown(__arg0);
        }

        public static void UpdateHoveredWindowAndCaptureFlags()
        {
            __Internal.UpdateHoveredWindowAndCaptureFlags();
        }

        public static void StartMouseMovingWindow(global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.StartMouseMovingWindow(__arg0);
        }

        public static void UpdateMouseMovingWindowNewFrame()
        {
            __Internal.UpdateMouseMovingWindowNewFrame();
        }

        public static void UpdateMouseMovingWindowEndFrame()
        {
            __Internal.UpdateMouseMovingWindowEndFrame();
        }

        public static void MarkIniSettingsDirtyNil()
        {
            __Internal.MarkIniSettingsDirtyNil();
        }

        public static void MarkIniSettingsDirtyWindowPtr(global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.MarkIniSettingsDirtyWindowPtr(__arg0);
        }

        public static global::ImGui.ImGuiWindowSettings CreateNewWindowSettings(string name)
        {
            var __ret = __Internal.CreateNewWindowSettings(name);
            global::ImGui.ImGuiWindowSettings __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiWindowSettings.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiWindowSettings) global::ImGui.ImGuiWindowSettings.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiWindowSettings.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiWindowSettings FindWindowSettings(uint id)
        {
            var __ret = __Internal.FindWindowSettings(id);
            global::ImGui.ImGuiWindowSettings __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiWindowSettings.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiWindowSettings) global::ImGui.ImGuiWindowSettings.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiWindowSettings.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiWindowSettings FindOrCreateWindowSettings(string name)
        {
            var __ret = __Internal.FindOrCreateWindowSettings(name);
            global::ImGui.ImGuiWindowSettings __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiWindowSettings.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiWindowSettings) global::ImGui.ImGuiWindowSettings.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiWindowSettings.__CreateInstance(__ret);
            return __result0;
        }

        public static global::ImGui.ImGuiSettingsHandler FindSettingsHandler(string type_name)
        {
            var __ret = __Internal.FindSettingsHandler(type_name);
            global::ImGui.ImGuiSettingsHandler __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiSettingsHandler.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiSettingsHandler) global::ImGui.ImGuiSettingsHandler.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiSettingsHandler.__CreateInstance(__ret);
            return __result0;
        }

        public static void SetScrollXWindowPtr(global::ImGui.ImGuiWindow window, float new_scroll_x)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetScrollXWindowPtr(__arg0, new_scroll_x);
        }

        public static void SetScrollYWindowPtr(global::ImGui.ImGuiWindow window, float new_scroll_y)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetScrollYWindowPtr(__arg0, new_scroll_y);
        }

        public static void SetScrollFromPosXWindowPtr(global::ImGui.ImGuiWindow window, float local_x, float center_x_ratio)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetScrollFromPosXWindowPtr(__arg0, local_x, center_x_ratio);
        }

        public static void SetScrollFromPosYWindowPtr(global::ImGui.ImGuiWindow window, float local_y, float center_y_ratio)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetScrollFromPosYWindowPtr(__arg0, local_y, center_y_ratio);
        }

        public static void ScrollToBringRectIntoView(global::ImGui.ImVec2 pOut, global::ImGui.ImGuiWindow window, global::ImGui.ImRect item_rect)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(item_rect, null))
                throw new global::System.ArgumentNullException("item_rect", "Cannot be null because it is passed by value.");
            var __arg2 = item_rect.__Instance;
            __Internal.ScrollToBringRectIntoView(__arg0, __arg1, __arg2);
        }

        public static uint GetItemID()
        {
            var __ret = __Internal.GetItemID();
            return __ret;
        }

        public static int GetItemStatusFlags()
        {
            var __ret = __Internal.GetItemStatusFlags();
            return __ret;
        }

        public static uint GetActiveID()
        {
            var __ret = __Internal.GetActiveID();
            return __ret;
        }

        public static uint GetFocusID()
        {
            var __ret = __Internal.GetFocusID();
            return __ret;
        }

        public static void SetActiveID(uint id, global::ImGui.ImGuiWindow window)
        {
            var __arg1 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetActiveID(id, __arg1);
        }

        public static void SetFocusID(uint id, global::ImGui.ImGuiWindow window)
        {
            var __arg1 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.SetFocusID(id, __arg1);
        }

        public static void ClearActiveID()
        {
            __Internal.ClearActiveID();
        }

        public static uint GetHoveredID()
        {
            var __ret = __Internal.GetHoveredID();
            return __ret;
        }

        public static void SetHoveredID(uint id)
        {
            __Internal.SetHoveredID(id);
        }

        public static void KeepAliveID(uint id)
        {
            __Internal.KeepAliveID(id);
        }

        public static void MarkItemEdited(uint id)
        {
            __Internal.MarkItemEdited(id);
        }

        public static void PushOverrideID(uint id)
        {
            __Internal.PushOverrideID(id);
        }

        public static void ItemSizeVec2(global::ImGui.ImVec2 size, float text_baseline_y)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.ItemSizeVec2(*(global::ImGui.ImVec2.__Internal*) __arg0, text_baseline_y);
        }

        public static void ItemSizeRect(global::ImGui.ImRect bb, float text_baseline_y)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            __Internal.ItemSizeRect(__arg0, text_baseline_y);
        }

        public static bool ItemAdd(global::ImGui.ImRect bb, uint id, global::ImGui.ImRect nav_bb)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __arg2 = ReferenceEquals(nav_bb, null) ? global::System.IntPtr.Zero : nav_bb.__Instance;
            var __ret = __Internal.ItemAdd(__arg0, id, __arg2);
            return __ret;
        }

        public static bool ItemHoverable(global::ImGui.ImRect bb, uint id)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.ItemHoverable(__arg0, id);
            return __ret;
        }

        public static bool IsClippedEx(global::ImGui.ImRect bb, uint id, bool clip_even_when_logged)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.IsClippedEx(__arg0, id, clip_even_when_logged);
            return __ret;
        }

        public static bool FocusableItemRegister(global::ImGui.ImGuiWindow window, uint id)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.FocusableItemRegister(__arg0, id);
            return __ret;
        }

        public static void FocusableItemUnregister(global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.FocusableItemUnregister(__arg0);
        }

        public static void CalcItemSize(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 size, float default_w, float default_h)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            __Internal.CalcItemSize(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, default_w, default_h);
        }

        public static float CalcWrapWidthForPos(global::ImGui.ImVec2 pos, float wrap_pos_x)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            var __ret = __Internal.CalcWrapWidthForPos(*(global::ImGui.ImVec2.__Internal*) __arg0, wrap_pos_x);
            return __ret;
        }

        public static void PushMultiItemsWidths(int components, float width_full)
        {
            __Internal.PushMultiItemsWidths(components, width_full);
        }

        public static void PushItemFlag(int option, bool enabled)
        {
            __Internal.PushItemFlag(option, enabled);
        }

        public static void PopItemFlag()
        {
            __Internal.PopItemFlag();
        }

        public static bool IsItemToggledSelection()
        {
            var __ret = __Internal.IsItemToggledSelection();
            return __ret;
        }

        public static void GetContentRegionMaxAbs(global::ImGui.ImVec2 pOut)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetContentRegionMaxAbs(__arg0);
        }

        public static void ShrinkWidths(global::ImGui.ImGuiShrinkWidthItem items, int count, float width_excess)
        {
            var __arg0 = ReferenceEquals(items, null) ? global::System.IntPtr.Zero : items.__Instance;
            __Internal.ShrinkWidths(__arg0, count, width_excess);
        }

        public static void LogBegin(global::ImGui.ImGuiLogType type, int auto_open_depth)
        {
            __Internal.LogBegin(type, auto_open_depth);
        }

        public static void LogToBuffer(int auto_open_depth)
        {
            __Internal.LogToBuffer(auto_open_depth);
        }

        public static bool BeginChildEx(string name, uint id, global::ImGui.ImVec2 size_arg, bool border, int flags)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg2 = size_arg.__Instance;
            var __ret = __Internal.BeginChildEx(name, id, *(global::ImGui.ImVec2.__Internal*) __arg2, border, flags);
            return __ret;
        }

        public static void OpenPopupEx(uint id)
        {
            __Internal.OpenPopupEx(id);
        }

        public static void ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup)
        {
            __Internal.ClosePopupToLevel(remaining, restore_focus_to_window_under_popup);
        }

        public static void ClosePopupsOverWindow(global::ImGui.ImGuiWindow ref_window, bool restore_focus_to_window_under_popup)
        {
            var __arg0 = ReferenceEquals(ref_window, null) ? global::System.IntPtr.Zero : ref_window.__Instance;
            __Internal.ClosePopupsOverWindow(__arg0, restore_focus_to_window_under_popup);
        }

        public static bool IsPopupOpenID(uint id)
        {
            var __ret = __Internal.IsPopupOpenID(id);
            return __ret;
        }

        public static bool BeginPopupEx(uint id, int extra_flags)
        {
            var __ret = __Internal.BeginPopupEx(id, extra_flags);
            return __ret;
        }

        public static void BeginTooltipEx(int extra_flags, int tooltip_flags)
        {
            __Internal.BeginTooltipEx(extra_flags, tooltip_flags);
        }

        public static global::ImGui.ImGuiWindow GetTopMostPopupModal()
        {
            var __ret = __Internal.GetTopMostPopupModal();
            global::ImGui.ImGuiWindow __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiWindow.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiWindow) global::ImGui.ImGuiWindow.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiWindow.__CreateInstance(__ret);
            return __result0;
        }

        public static void FindBestWindowPosForPopup(global::ImGui.ImVec2 pOut, global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            var __arg1 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.FindBestWindowPosForPopup(__arg0, __arg1);
        }

        public static void FindBestWindowPosForPopupEx(global::ImGui.ImVec2 pOut, global::ImGui.ImVec2 ref_pos, global::ImGui.ImVec2 size, ref int last_dir, global::ImGui.ImRect r_outer, global::ImGui.ImRect r_avoid, global::ImGui.ImGuiPopupPositionPolicy policy)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(ref_pos, null))
                throw new global::System.ArgumentNullException("ref_pos", "Cannot be null because it is passed by value.");
            var __arg1 = ref_pos.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg2 = size.__Instance;
            fixed (int* __last_dir3 = &last_dir)
            {
                var __arg3 = __last_dir3;
                if (ReferenceEquals(r_outer, null))
                    throw new global::System.ArgumentNullException("r_outer", "Cannot be null because it is passed by value.");
                var __arg4 = r_outer.__Instance;
                if (ReferenceEquals(r_avoid, null))
                    throw new global::System.ArgumentNullException("r_avoid", "Cannot be null because it is passed by value.");
                var __arg5 = r_avoid.__Instance;
                __Internal.FindBestWindowPosForPopupEx(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, __arg3, __arg4, __arg5, policy);
            }
        }

        public static void NavInitWindow(global::ImGui.ImGuiWindow window, bool force_reinit)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.NavInitWindow(__arg0, force_reinit);
        }

        public static bool NavMoveRequestButNoResultYet()
        {
            var __ret = __Internal.NavMoveRequestButNoResultYet();
            return __ret;
        }

        public static void NavMoveRequestCancel()
        {
            __Internal.NavMoveRequestCancel();
        }

        public static void NavMoveRequestForward(int move_dir, int clip_dir, global::ImGui.ImRect bb_rel, int move_flags)
        {
            if (ReferenceEquals(bb_rel, null))
                throw new global::System.ArgumentNullException("bb_rel", "Cannot be null because it is passed by value.");
            var __arg2 = bb_rel.__Instance;
            __Internal.NavMoveRequestForward(move_dir, clip_dir, __arg2, move_flags);
        }

        public static void NavMoveRequestTryWrapping(global::ImGui.ImGuiWindow window, int move_flags)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.NavMoveRequestTryWrapping(__arg0, move_flags);
        }

        public static float GetNavInputAmount(int n, global::ImGui.ImGuiInputReadMode mode)
        {
            var __ret = __Internal.GetNavInputAmount(n, mode);
            return __ret;
        }

        public static void GetNavInputAmount2d(global::ImGui.ImVec2 pOut, int dir_sources, global::ImGui.ImGuiInputReadMode mode, float slow_factor, float fast_factor)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.GetNavInputAmount2d(__arg0, dir_sources, mode, slow_factor, fast_factor);
        }

        public static int CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate)
        {
            var __ret = __Internal.CalcTypematicRepeatAmount(t0, t1, repeat_delay, repeat_rate);
            return __ret;
        }

        public static void ActivateItem(uint id)
        {
            __Internal.ActivateItem(id);
        }

        public static void SetNavID(uint id, int nav_layer, uint focus_scope_id)
        {
            __Internal.SetNavID(id, nav_layer, focus_scope_id);
        }

        public static void SetNavIDWithRectRel(uint id, int nav_layer, uint focus_scope_id, global::ImGui.ImRect rect_rel)
        {
            if (ReferenceEquals(rect_rel, null))
                throw new global::System.ArgumentNullException("rect_rel", "Cannot be null because it is passed by value.");
            var __arg3 = rect_rel.__Instance;
            __Internal.SetNavIDWithRectRel(id, nav_layer, focus_scope_id, __arg3);
        }

        public static void PushFocusScope(uint id)
        {
            __Internal.PushFocusScope(id);
        }

        public static void PopFocusScope()
        {
            __Internal.PopFocusScope();
        }

        public static uint GetFocusScopeID()
        {
            var __ret = __Internal.GetFocusScopeID();
            return __ret;
        }

        public static bool IsActiveIdUsingNavDir(int dir)
        {
            var __ret = __Internal.IsActiveIdUsingNavDir(dir);
            return __ret;
        }

        public static bool IsActiveIdUsingNavInput(int input)
        {
            var __ret = __Internal.IsActiveIdUsingNavInput(input);
            return __ret;
        }

        public static bool IsActiveIdUsingKey(int key)
        {
            var __ret = __Internal.IsActiveIdUsingKey(key);
            return __ret;
        }

        public static bool IsMouseDragPastThreshold(int button, float lock_threshold)
        {
            var __ret = __Internal.IsMouseDragPastThreshold(button, lock_threshold);
            return __ret;
        }

        public static bool IsKeyPressedMap(int key, bool repeat)
        {
            var __ret = __Internal.IsKeyPressedMap(key, repeat);
            return __ret;
        }

        public static bool IsNavInputDown(int n)
        {
            var __ret = __Internal.IsNavInputDown(n);
            return __ret;
        }

        public static bool IsNavInputTest(int n, global::ImGui.ImGuiInputReadMode rm)
        {
            var __ret = __Internal.IsNavInputTest(n, rm);
            return __ret;
        }

        public static bool BeginDragDropTargetCustom(global::ImGui.ImRect bb, uint id)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.BeginDragDropTargetCustom(__arg0, id);
            return __ret;
        }

        public static void ClearDragDrop()
        {
            __Internal.ClearDragDrop();
        }

        public static bool IsDragDropPayloadBeingAccepted()
        {
            var __ret = __Internal.IsDragDropPayloadBeingAccepted();
            return __ret;
        }

        public static void BeginColumns(string str_id, int count, int flags)
        {
            __Internal.BeginColumns(str_id, count, flags);
        }

        public static void EndColumns()
        {
            __Internal.EndColumns();
        }

        public static void PushColumnClipRect(int column_index)
        {
            __Internal.PushColumnClipRect(column_index);
        }

        public static void PushColumnsBackground()
        {
            __Internal.PushColumnsBackground();
        }

        public static void PopColumnsBackground()
        {
            __Internal.PopColumnsBackground();
        }

        public static uint GetColumnsID(string str_id, int count)
        {
            var __ret = __Internal.GetColumnsID(str_id, count);
            return __ret;
        }

        public static global::ImGui.ImGuiColumns FindOrCreateColumns(global::ImGui.ImGuiWindow window, uint id)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.FindOrCreateColumns(__arg0, id);
            global::ImGui.ImGuiColumns __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiColumns.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiColumns) global::ImGui.ImGuiColumns.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiColumns.__CreateInstance(__ret);
            return __result0;
        }

        public static float GetColumnOffsetFromNorm(global::ImGui.ImGuiColumns columns, float offset_norm)
        {
            var __arg0 = ReferenceEquals(columns, null) ? global::System.IntPtr.Zero : columns.__Instance;
            var __ret = __Internal.GetColumnOffsetFromNorm(__arg0, offset_norm);
            return __ret;
        }

        public static float GetColumnNormFromOffset(global::ImGui.ImGuiColumns columns, float offset)
        {
            var __arg0 = ReferenceEquals(columns, null) ? global::System.IntPtr.Zero : columns.__Instance;
            var __ret = __Internal.GetColumnNormFromOffset(__arg0, offset);
            return __ret;
        }

        public static bool BeginTabBarEx(global::ImGui.ImGuiTabBar tab_bar, global::ImGui.ImRect bb, int flags)
        {
            var __arg0 = ReferenceEquals(tab_bar, null) ? global::System.IntPtr.Zero : tab_bar.__Instance;
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg1 = bb.__Instance;
            var __ret = __Internal.BeginTabBarEx(__arg0, __arg1, flags);
            return __ret;
        }

        public static global::ImGui.ImGuiTabItem TabBarFindTabByID(global::ImGui.ImGuiTabBar tab_bar, uint tab_id)
        {
            var __arg0 = ReferenceEquals(tab_bar, null) ? global::System.IntPtr.Zero : tab_bar.__Instance;
            var __ret = __Internal.TabBarFindTabByID(__arg0, tab_id);
            global::ImGui.ImGuiTabItem __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiTabItem.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiTabItem) global::ImGui.ImGuiTabItem.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiTabItem.__CreateInstance(__ret);
            return __result0;
        }

        public static void TabBarRemoveTab(global::ImGui.ImGuiTabBar tab_bar, uint tab_id)
        {
            var __arg0 = ReferenceEquals(tab_bar, null) ? global::System.IntPtr.Zero : tab_bar.__Instance;
            __Internal.TabBarRemoveTab(__arg0, tab_id);
        }

        public static void TabBarCloseTab(global::ImGui.ImGuiTabBar tab_bar, global::ImGui.ImGuiTabItem tab)
        {
            var __arg0 = ReferenceEquals(tab_bar, null) ? global::System.IntPtr.Zero : tab_bar.__Instance;
            var __arg1 = ReferenceEquals(tab, null) ? global::System.IntPtr.Zero : tab.__Instance;
            __Internal.TabBarCloseTab(__arg0, __arg1);
        }

        public static void TabBarQueueChangeTabOrder(global::ImGui.ImGuiTabBar tab_bar, global::ImGui.ImGuiTabItem tab, int dir)
        {
            var __arg0 = ReferenceEquals(tab_bar, null) ? global::System.IntPtr.Zero : tab_bar.__Instance;
            var __arg1 = ReferenceEquals(tab, null) ? global::System.IntPtr.Zero : tab.__Instance;
            __Internal.TabBarQueueChangeTabOrder(__arg0, __arg1, dir);
        }

        public static bool TabItemEx(global::ImGui.ImGuiTabBar tab_bar, string label, ref bool p_open, int flags)
        {
            var __arg0 = ReferenceEquals(tab_bar, null) ? global::System.IntPtr.Zero : tab_bar.__Instance;
            fixed (bool* __p_open2 = &p_open)
            {
                var __arg2 = __p_open2;
                var __ret = __Internal.TabItemEx(__arg0, label, __arg2, flags);
                return __ret;
            }
        }

        public static void TabItemCalcSize(global::ImGui.ImVec2 pOut, string label, bool has_close_button)
        {
            var __arg0 = ReferenceEquals(pOut, null) ? global::System.IntPtr.Zero : pOut.__Instance;
            __Internal.TabItemCalcSize(__arg0, label, has_close_button);
        }

        public static void TabItemBackground(global::ImGui.ImDrawList draw_list, global::ImGui.ImRect bb, int flags, uint col)
        {
            var __arg0 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg1 = bb.__Instance;
            __Internal.TabItemBackground(__arg0, __arg1, flags, col);
        }

        public static bool TabItemLabelAndCloseButton(global::ImGui.ImDrawList draw_list, global::ImGui.ImRect bb, int flags, global::ImGui.ImVec2 frame_padding, string label, uint tab_id, uint close_button_id)
        {
            var __arg0 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg1 = bb.__Instance;
            if (ReferenceEquals(frame_padding, null))
                throw new global::System.ArgumentNullException("frame_padding", "Cannot be null because it is passed by value.");
            var __arg3 = frame_padding.__Instance;
            var __ret = __Internal.TabItemLabelAndCloseButton(__arg0, __arg1, flags, *(global::ImGui.ImVec2.__Internal*) __arg3, label, tab_id, close_button_id);
            return __ret;
        }

        public static void RenderText(global::ImGui.ImVec2 pos, string text, string text_end, bool hide_text_after_hash)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.RenderText(*(global::ImGui.ImVec2.__Internal*) __arg0, text, text_end, hide_text_after_hash);
        }

        public static void RenderTextWrapped(global::ImGui.ImVec2 pos, string text, string text_end, float wrap_width)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.RenderTextWrapped(*(global::ImGui.ImVec2.__Internal*) __arg0, text, text_end, wrap_width);
        }

        public static void RenderTextClipped(global::ImGui.ImVec2 pos_min, global::ImGui.ImVec2 pos_max, string text, string text_end, global::ImGui.ImVec2 text_size_if_known, global::ImGui.ImVec2 align, global::ImGui.ImRect clip_rect)
        {
            if (ReferenceEquals(pos_min, null))
                throw new global::System.ArgumentNullException("pos_min", "Cannot be null because it is passed by value.");
            var __arg0 = pos_min.__Instance;
            if (ReferenceEquals(pos_max, null))
                throw new global::System.ArgumentNullException("pos_max", "Cannot be null because it is passed by value.");
            var __arg1 = pos_max.__Instance;
            var __arg4 = ReferenceEquals(text_size_if_known, null) ? global::System.IntPtr.Zero : text_size_if_known.__Instance;
            if (ReferenceEquals(align, null))
                throw new global::System.ArgumentNullException("align", "Cannot be null because it is passed by value.");
            var __arg5 = align.__Instance;
            var __arg6 = ReferenceEquals(clip_rect, null) ? global::System.IntPtr.Zero : clip_rect.__Instance;
            __Internal.RenderTextClipped(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, text, text_end, __arg4, *(global::ImGui.ImVec2.__Internal*) __arg5, __arg6);
        }

        public static void RenderTextClippedEx(global::ImGui.ImDrawList draw_list, global::ImGui.ImVec2 pos_min, global::ImGui.ImVec2 pos_max, string text, string text_end, global::ImGui.ImVec2 text_size_if_known, global::ImGui.ImVec2 align, global::ImGui.ImRect clip_rect)
        {
            var __arg0 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos_min, null))
                throw new global::System.ArgumentNullException("pos_min", "Cannot be null because it is passed by value.");
            var __arg1 = pos_min.__Instance;
            if (ReferenceEquals(pos_max, null))
                throw new global::System.ArgumentNullException("pos_max", "Cannot be null because it is passed by value.");
            var __arg2 = pos_max.__Instance;
            var __arg5 = ReferenceEquals(text_size_if_known, null) ? global::System.IntPtr.Zero : text_size_if_known.__Instance;
            if (ReferenceEquals(align, null))
                throw new global::System.ArgumentNullException("align", "Cannot be null because it is passed by value.");
            var __arg6 = align.__Instance;
            var __arg7 = ReferenceEquals(clip_rect, null) ? global::System.IntPtr.Zero : clip_rect.__Instance;
            __Internal.RenderTextClippedEx(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, text, text_end, __arg5, *(global::ImGui.ImVec2.__Internal*) __arg6, __arg7);
        }

        public static void RenderTextEllipsis(global::ImGui.ImDrawList draw_list, global::ImGui.ImVec2 pos_min, global::ImGui.ImVec2 pos_max, float clip_max_x, float ellipsis_max_x, string text, string text_end, global::ImGui.ImVec2 text_size_if_known)
        {
            var __arg0 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos_min, null))
                throw new global::System.ArgumentNullException("pos_min", "Cannot be null because it is passed by value.");
            var __arg1 = pos_min.__Instance;
            if (ReferenceEquals(pos_max, null))
                throw new global::System.ArgumentNullException("pos_max", "Cannot be null because it is passed by value.");
            var __arg2 = pos_max.__Instance;
            var __arg7 = ReferenceEquals(text_size_if_known, null) ? global::System.IntPtr.Zero : text_size_if_known.__Instance;
            __Internal.RenderTextEllipsis(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, clip_max_x, ellipsis_max_x, text, text_end, __arg7);
        }

        public static void RenderFrame(global::ImGui.ImVec2 p_min, global::ImGui.ImVec2 p_max, uint fill_col, bool border, float rounding)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg0 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg1 = p_max.__Instance;
            __Internal.RenderFrame(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, fill_col, border, rounding);
        }

        public static void RenderFrameBorder(global::ImGui.ImVec2 p_min, global::ImGui.ImVec2 p_max, float rounding)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg0 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg1 = p_max.__Instance;
            __Internal.RenderFrameBorder(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, rounding);
        }

        public static void RenderColorRectWithAlphaCheckerboard(global::ImGui.ImVec2 p_min, global::ImGui.ImVec2 p_max, uint fill_col, float grid_step, global::ImGui.ImVec2 grid_off, float rounding, int rounding_corners_flags)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg0 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg1 = p_max.__Instance;
            if (ReferenceEquals(grid_off, null))
                throw new global::System.ArgumentNullException("grid_off", "Cannot be null because it is passed by value.");
            var __arg4 = grid_off.__Instance;
            __Internal.RenderColorRectWithAlphaCheckerboard(*(global::ImGui.ImVec2.__Internal*) __arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, fill_col, grid_step, *(global::ImGui.ImVec2.__Internal*) __arg4, rounding, rounding_corners_flags);
        }

        public static void RenderCheckMark(global::ImGui.ImVec2 pos, uint col, float sz)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.RenderCheckMark(*(global::ImGui.ImVec2.__Internal*) __arg0, col, sz);
        }

        public static void RenderNavHighlight(global::ImGui.ImRect bb, uint id, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            __Internal.RenderNavHighlight(__arg0, id, flags);
        }

        public static string FindRenderedTextEnd(string text, string text_end)
        {
            var __ret = __Internal.FindRenderedTextEnd(text, text_end);
            if (__ret == global::System.IntPtr.Zero)
                return default(string);
            var __retPtr = (byte*) __ret;
            int __length = 0;
            while (*(__retPtr++) != 0) __length += sizeof(byte);
            return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
        }

        public static void LogRenderedText(global::ImGui.ImVec2 ref_pos, string text, string text_end)
        {
            var __arg0 = ReferenceEquals(ref_pos, null) ? global::System.IntPtr.Zero : ref_pos.__Instance;
            __Internal.LogRenderedText(__arg0, text, text_end);
        }

        public static void RenderArrow(global::ImGui.ImDrawList draw_list, global::ImGui.ImVec2 pos, uint col, int dir, float scale)
        {
            var __arg0 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.RenderArrow(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, col, dir, scale);
        }

        public static void RenderBullet(global::ImGui.ImDrawList draw_list, global::ImGui.ImVec2 pos, uint col)
        {
            var __arg0 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.RenderBullet(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, col);
        }

        public static void RenderMouseCursor(global::ImGui.ImDrawList draw_list, global::ImGui.ImVec2 pos, float scale, int mouse_cursor, uint col_fill, uint col_border, uint col_shadow)
        {
            var __arg0 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.RenderMouseCursor(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, scale, mouse_cursor, col_fill, col_border, col_shadow);
        }

        public static void RenderArrowPointingAt(global::ImGui.ImDrawList draw_list, global::ImGui.ImVec2 pos, global::ImGui.ImVec2 half_sz, int direction, uint col)
        {
            var __arg0 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(half_sz, null))
                throw new global::System.ArgumentNullException("half_sz", "Cannot be null because it is passed by value.");
            var __arg2 = half_sz.__Instance;
            __Internal.RenderArrowPointingAt(__arg0, *(global::ImGui.ImVec2.__Internal*) __arg1, *(global::ImGui.ImVec2.__Internal*) __arg2, direction, col);
        }

        public static void RenderRectFilledRangeH(global::ImGui.ImDrawList draw_list, global::ImGui.ImRect rect, uint col, float x_start_norm, float x_end_norm, float rounding)
        {
            var __arg0 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(rect, null))
                throw new global::System.ArgumentNullException("rect", "Cannot be null because it is passed by value.");
            var __arg1 = rect.__Instance;
            __Internal.RenderRectFilledRangeH(__arg0, __arg1, col, x_start_norm, x_end_norm, rounding);
        }

        public static void TextEx(string text, string text_end, int flags)
        {
            __Internal.TextEx(text, text_end, flags);
        }

        public static bool ButtonEx(string label, global::ImGui.ImVec2 size_arg, int flags)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg1 = size_arg.__Instance;
            var __ret = __Internal.ButtonEx(label, *(global::ImGui.ImVec2.__Internal*) __arg1, flags);
            return __ret;
        }

        public static bool CloseButton(uint id, global::ImGui.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            var __ret = __Internal.CloseButton(id, *(global::ImGui.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool CollapseButton(uint id, global::ImGui.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            var __ret = __Internal.CollapseButton(id, *(global::ImGui.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool ArrowButtonEx(string str_id, int dir, global::ImGui.ImVec2 size_arg, int flags)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg2 = size_arg.__Instance;
            var __ret = __Internal.ArrowButtonEx(str_id, dir, *(global::ImGui.ImVec2.__Internal*) __arg2, flags);
            return __ret;
        }

        public static void Scrollbar(global::ImGui.ImGuiAxis axis)
        {
            __Internal.Scrollbar(axis);
        }

        public static bool ScrollbarEx(global::ImGui.ImRect bb, uint id, global::ImGui.ImGuiAxis axis, ref float p_scroll_v, float avail_v, float contents_v, int rounding_corners)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            fixed (float* __p_scroll_v3 = &p_scroll_v)
            {
                var __arg3 = __p_scroll_v3;
                var __ret = __Internal.ScrollbarEx(__arg0, id, axis, __arg3, avail_v, contents_v, rounding_corners);
                return __ret;
            }
        }

        public static uint GetWindowScrollbarID(global::ImGui.ImGuiWindow window, global::ImGui.ImGuiAxis axis)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowScrollbarID(__arg0, axis);
            return __ret;
        }

        public static uint GetWindowResizeID(global::ImGui.ImGuiWindow window, int n)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowResizeID(__arg0, n);
            return __ret;
        }

        public static void SeparatorEx(int flags)
        {
            __Internal.SeparatorEx(flags);
        }

        public static bool ButtonBehavior(global::ImGui.ImRect bb, uint id, ref bool out_hovered, ref bool out_held, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            fixed (bool* __out_hovered2 = &out_hovered)
            {
                var __arg2 = __out_hovered2;
                fixed (bool* __out_held3 = &out_held)
                {
                    var __arg3 = __out_held3;
                    var __ret = __Internal.ButtonBehavior(__arg0, id, __arg2, __arg3, flags);
                    return __ret;
                }
            }
        }

        public static bool DragBehavior(uint id, int data_type, global::System.IntPtr p_v, float v_speed, global::System.IntPtr p_min, global::System.IntPtr p_max, string format, float power, int flags)
        {
            var __ret = __Internal.DragBehavior(id, data_type, p_v, v_speed, p_min, p_max, format, power, flags);
            return __ret;
        }

        public static bool SliderBehavior(global::ImGui.ImRect bb, uint id, int data_type, global::System.IntPtr p_v, global::System.IntPtr p_min, global::System.IntPtr p_max, string format, float power, int flags, global::ImGui.ImRect out_grab_bb)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __arg9 = ReferenceEquals(out_grab_bb, null) ? global::System.IntPtr.Zero : out_grab_bb.__Instance;
            var __ret = __Internal.SliderBehavior(__arg0, id, data_type, p_v, p_min, p_max, format, power, flags, __arg9);
            return __ret;
        }

        public static bool SplitterBehavior(global::ImGui.ImRect bb, uint id, global::ImGui.ImGuiAxis axis, ref float size1, ref float size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            fixed (float* __size13 = &size1)
            {
                var __arg3 = __size13;
                fixed (float* __size24 = &size2)
                {
                    var __arg4 = __size24;
                    var __ret = __Internal.SplitterBehavior(__arg0, id, axis, __arg3, __arg4, min_size1, min_size2, hover_extend, hover_visibility_delay);
                    return __ret;
                }
            }
        }

        public static bool TreeNodeBehavior(uint id, int flags, string label, string label_end)
        {
            var __ret = __Internal.TreeNodeBehavior(id, flags, label, label_end);
            return __ret;
        }

        public static bool TreeNodeBehaviorIsOpen(uint id, int flags)
        {
            var __ret = __Internal.TreeNodeBehaviorIsOpen(id, flags);
            return __ret;
        }

        public static void TreePushOverrideID(uint id)
        {
            __Internal.TreePushOverrideID(id);
        }

        public static global::ImGui.ImGuiDataTypeInfo DataTypeGetInfo(int data_type)
        {
            var __ret = __Internal.DataTypeGetInfo(data_type);
            global::ImGui.ImGuiDataTypeInfo __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImGuiDataTypeInfo.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImGuiDataTypeInfo) global::ImGui.ImGuiDataTypeInfo.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImGuiDataTypeInfo.__CreateInstance(__ret);
            return __result0;
        }

        public static int DataTypeFormatString(sbyte* buf, int buf_size, int data_type, global::System.IntPtr p_data, string format)
        {
            var __ret = __Internal.DataTypeFormatString(buf, buf_size, data_type, p_data, format);
            return __ret;
        }

        public static void DataTypeApplyOp(int data_type, int op, global::System.IntPtr output, global::System.IntPtr arg_1, global::System.IntPtr arg_2)
        {
            __Internal.DataTypeApplyOp(data_type, op, output, arg_1, arg_2);
        }

        public static bool DataTypeApplyOpFromText(string buf, string initial_value_buf, int data_type, global::System.IntPtr p_data, string format)
        {
            var __ret = __Internal.DataTypeApplyOpFromText(buf, initial_value_buf, data_type, p_data, format);
            return __ret;
        }

        public static bool InputTextEx(string label, string hint, sbyte* buf, int buf_size, global::ImGui.ImVec2 size_arg, int flags, global::ImGui.ImGuiInputTextCallback callback, global::System.IntPtr user_data)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg4 = size_arg.__Instance;
            var __arg6 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputTextEx(label, hint, buf, buf_size, *(global::ImGui.ImVec2.__Internal*) __arg4, flags, __arg6, user_data);
            return __ret;
        }

        public static bool TempInputTextScalar(global::ImGui.ImRect bb, uint id, string label, int data_type, global::System.IntPtr p_data, string format)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.TempInputTextScalar(__arg0, id, label, data_type, p_data, format);
            return __ret;
        }

        public static bool TempInputTextIsActive(uint id)
        {
            var __ret = __Internal.TempInputTextIsActive(id);
            return __ret;
        }

        public static void ColorTooltip(string text, ref float col, int flags)
        {
            fixed (float* __col1 = &col)
            {
                var __arg1 = __col1;
                __Internal.ColorTooltip(text, __arg1, flags);
            }
        }

        public static void ColorEditOptionsPopup(ref float col, int flags)
        {
            fixed (float* __col0 = &col)
            {
                var __arg0 = __col0;
                __Internal.ColorEditOptionsPopup(__arg0, flags);
            }
        }

        public static void ColorPickerOptionsPopup(ref float ref_col, int flags)
        {
            fixed (float* __ref_col0 = &ref_col)
            {
                var __arg0 = __ref_col0;
                __Internal.ColorPickerOptionsPopup(__arg0, flags);
            }
        }

        public static void PlotEx(global::ImGui.ImGuiPlotType plot_type, string label, global::ImGui.Delegates.Func_float_IntPtr_int values_getter, global::System.IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::ImGui.ImVec2 frame_size)
        {
            var __arg2 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
            if (ReferenceEquals(frame_size, null))
                throw new global::System.ArgumentNullException("frame_size", "Cannot be null because it is passed by value.");
            var __arg9 = frame_size.__Instance;
            __Internal.PlotEx(plot_type, label, __arg2, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::ImGui.ImVec2.__Internal*) __arg9);
        }

        public static void ShadeVertsLinearColorGradientKeepAlpha(global::ImGui.ImDrawList draw_list, int vert_start_idx, int vert_end_idx, global::ImGui.ImVec2 gradient_p0, global::ImGui.ImVec2 gradient_p1, uint col0, uint col1)
        {
            var __arg0 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(gradient_p0, null))
                throw new global::System.ArgumentNullException("gradient_p0", "Cannot be null because it is passed by value.");
            var __arg3 = gradient_p0.__Instance;
            if (ReferenceEquals(gradient_p1, null))
                throw new global::System.ArgumentNullException("gradient_p1", "Cannot be null because it is passed by value.");
            var __arg4 = gradient_p1.__Instance;
            __Internal.ShadeVertsLinearColorGradientKeepAlpha(__arg0, vert_start_idx, vert_end_idx, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, col0, col1);
        }

        public static void ShadeVertsLinearUV(global::ImGui.ImDrawList draw_list, int vert_start_idx, int vert_end_idx, global::ImGui.ImVec2 a, global::ImGui.ImVec2 b, global::ImGui.ImVec2 uv_a, global::ImGui.ImVec2 uv_b, bool clamp)
        {
            var __arg0 = ReferenceEquals(draw_list, null) ? global::System.IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg3 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg4 = b.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is passed by value.");
            var __arg5 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is passed by value.");
            var __arg6 = uv_b.__Instance;
            __Internal.ShadeVertsLinearUV(__arg0, vert_start_idx, vert_end_idx, *(global::ImGui.ImVec2.__Internal*) __arg3, *(global::ImGui.ImVec2.__Internal*) __arg4, *(global::ImGui.ImVec2.__Internal*) __arg5, *(global::ImGui.ImVec2.__Internal*) __arg6, clamp);
        }

        public static void GcCompactTransientWindowBuffers(global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GcCompactTransientWindowBuffers(__arg0);
        }

        public static void GcAwakeTransientWindowBuffers(global::ImGui.ImGuiWindow window)
        {
            var __arg0 = ReferenceEquals(window, null) ? global::System.IntPtr.Zero : window.__Instance;
            __Internal.GcAwakeTransientWindowBuffers(__arg0);
        }

        public static void DebugDrawItemRect(uint col)
        {
            __Internal.DebugDrawItemRect(col);
        }

        public static void DebugStartItemPicker()
        {
            __Internal.DebugStartItemPicker();
        }

        public static bool ImFontAtlasBuildWithStbTruetype(global::ImGui.ImFontAtlas atlas)
        {
            var __arg0 = ReferenceEquals(atlas, null) ? global::System.IntPtr.Zero : atlas.__Instance;
            var __ret = __Internal.ImFontAtlasBuildWithStbTruetype(__arg0);
            return __ret;
        }

        public static void ImFontAtlasBuildRegisterDefaultCustomRects(global::ImGui.ImFontAtlas atlas)
        {
            var __arg0 = ReferenceEquals(atlas, null) ? global::System.IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildRegisterDefaultCustomRects(__arg0);
        }

        public static void ImFontAtlasBuildSetupFont(global::ImGui.ImFontAtlas atlas, global::ImGui.ImFont font, global::ImGui.ImFontConfig font_config, float ascent, float descent)
        {
            var __arg0 = ReferenceEquals(atlas, null) ? global::System.IntPtr.Zero : atlas.__Instance;
            var __arg1 = ReferenceEquals(font, null) ? global::System.IntPtr.Zero : font.__Instance;
            var __arg2 = ReferenceEquals(font_config, null) ? global::System.IntPtr.Zero : font_config.__Instance;
            __Internal.ImFontAtlasBuildSetupFont(__arg0, __arg1, __arg2, ascent, descent);
        }

        public static void ImFontAtlasBuildPackCustomRects(global::ImGui.ImFontAtlas atlas, global::System.IntPtr stbrp_context_opaque)
        {
            var __arg0 = ReferenceEquals(atlas, null) ? global::System.IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildPackCustomRects(__arg0, stbrp_context_opaque);
        }

        public static void ImFontAtlasBuildFinish(global::ImGui.ImFontAtlas atlas)
        {
            var __arg0 = ReferenceEquals(atlas, null) ? global::System.IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildFinish(__arg0);
        }

        public static void ImFontAtlasBuildMultiplyCalcLookupTable(byte[] out_table, float in_multiply_factor)
        {
            if (out_table == null || out_table.Length != 256)
                throw new ArgumentOutOfRangeException("out_table", "The dimensions of the provided array don't match the required size.");
            __Internal.ImFontAtlasBuildMultiplyCalcLookupTable(out_table, in_multiply_factor);
        }

        public static void ImFontAtlasBuildMultiplyRectAlpha8(byte[] table, byte* pixels, int x, int y, int w, int h, int stride)
        {
            if (table == null || table.Length != 256)
                throw new ArgumentOutOfRangeException("table", "The dimensions of the provided array don't match the required size.");
            __Internal.ImFontAtlasBuildMultiplyRectAlpha8(table, pixels, x, y, w, h, stride);
        }

        /// <summary>//////////////////////hand written functions</summary>
        public static void LogText(string fmt)
        {
            __Internal.LogText(fmt);
        }

        public static float GET_FLT_MAX()
        {
            var __ret = __Internal.GET_FLT_MAX();
            return __ret;
        }

        public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float out_h, ref float out_s, ref float out_v)
        {
            fixed (float* __out_h3 = &out_h)
            {
                var __arg3 = __out_h3;
                fixed (float* __out_s4 = &out_s)
                {
                    var __arg4 = __out_s4;
                    fixed (float* __out_v5 = &out_v)
                    {
                        var __arg5 = __out_v5;
                        __Internal.ColorConvertRGBtoHSV(r, g, b, __arg3, __arg4, __arg5);
                    }
                }
            }
        }

        public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float out_r, ref float out_g, ref float out_b)
        {
            fixed (float* __out_r3 = &out_r)
            {
                var __arg3 = __out_r3;
                fixed (float* __out_g4 = &out_g)
                {
                    var __arg4 = __out_g4;
                    fixed (float* __out_b5 = &out_b)
                    {
                        var __arg5 = __out_b5;
                        __Internal.ColorConvertHSVtoRGB(h, s, v, __arg3, __arg4, __arg5);
                    }
                }
            }
        }

        public static global::ImGui.ImVectorImWchar ImVectorImWchar_create()
        {
            var __ret = __Internal.ImVectorImWchar_create();
            global::ImGui.ImVectorImWchar __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (global::ImGui.ImVectorImWchar.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (global::ImGui.ImVectorImWchar) global::ImGui.ImVectorImWchar.NativeToManagedMap[__ret];
            else __result0 = global::ImGui.ImVectorImWchar.__CreateInstance(__ret);
            return __result0;
        }

        public static void ImVectorImWchar_destroy(global::ImGui.ImVectorImWchar self)
        {
            var __arg0 = ReferenceEquals(self, null) ? global::System.IntPtr.Zero : self.__Instance;
            __Internal.ImVectorImWchar_destroy(__arg0);
        }

        public static void ImVectorImWcharInit(global::ImGui.ImVectorImWchar p)
        {
            var __arg0 = ReferenceEquals(p, null) ? global::System.IntPtr.Zero : p.__Instance;
            __Internal.ImVectorImWcharInit(__arg0);
        }

        public static void ImVectorImWcharUnInit(global::ImGui.ImVectorImWchar p)
        {
            var __arg0 = ReferenceEquals(p, null) ? global::System.IntPtr.Zero : p.__Instance;
            __Internal.ImVectorImWcharUnInit(__arg0);
        }
    }

    public unsafe partial class ID3D11DeviceContext
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ID3D11DeviceContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ID3D11DeviceContext>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ID3D11DeviceContext __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ID3D11DeviceContext(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ID3D11DeviceContext __CreateInstance(global::ImGui.ID3D11DeviceContext.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ID3D11DeviceContext(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ID3D11DeviceContext.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ID3D11DeviceContext.__Internal));
            *(global::ImGui.ID3D11DeviceContext.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ID3D11DeviceContext(global::ImGui.ID3D11DeviceContext.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ID3D11DeviceContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class ID3D11Device
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ID3D11Device> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.ID3D11Device>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.ID3D11Device __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.ID3D11Device(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.ID3D11Device __CreateInstance(global::ImGui.ID3D11Device.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.ID3D11Device(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.ID3D11Device.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.ID3D11Device.__Internal));
            *(global::ImGui.ID3D11Device.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ID3D11Device(global::ImGui.ID3D11Device.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ID3D11Device(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class IDirect3DDevice9
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
        }

        public global::System.IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.IDirect3DDevice9> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ImGui.IDirect3DDevice9>();

        protected bool __ownsNativeInstance;

        internal static global::ImGui.IDirect3DDevice9 __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::ImGui.IDirect3DDevice9(native.ToPointer(), skipVTables);
        }

        internal static global::ImGui.IDirect3DDevice9 __CreateInstance(global::ImGui.IDirect3DDevice9.__Internal native, bool skipVTables = false)
        {
            return new global::ImGui.IDirect3DDevice9(native, skipVTables);
        }

        private static void* __CopyValue(global::ImGui.IDirect3DDevice9.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::ImGui.IDirect3DDevice9.__Internal));
            *(global::ImGui.IDirect3DDevice9.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IDirect3DDevice9(global::ImGui.IDirect3DDevice9.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected IDirect3DDevice9(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }
    }

    public unsafe partial class cimgui_impl
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplWin32_Init")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiImplWin32Init(global::System.IntPtr hwnd);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplWin32_Shutdown")]
            internal static extern void ImGuiImplWin32Shutdown();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplWin32_NewFrame")]
            internal static extern void ImGuiImplWin32NewFrame();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX9_Init")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiImplDX9Init(global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX9_Shutdown")]
            internal static extern void ImGuiImplDX9Shutdown();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX9_NewFrame")]
            internal static extern void ImGuiImplDX9NewFrame();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX9_RenderDrawData")]
            internal static extern void ImGuiImplDX9RenderDrawData(global::System.IntPtr draw_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX9_CreateDeviceObjects")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiImplDX9CreateDeviceObjects();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX9_InvalidateDeviceObjects")]
            internal static extern void ImGuiImplDX9InvalidateDeviceObjects();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX11_Init")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiImplDX11Init(global::System.IntPtr device, global::System.IntPtr device_context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX11_Shutdown")]
            internal static extern void ImGuiImplDX11Shutdown();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX11_NewFrame")]
            internal static extern void ImGuiImplDX11NewFrame();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX11_RenderDrawData")]
            internal static extern void ImGuiImplDX11RenderDrawData(global::System.IntPtr draw_data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX11_InvalidateDeviceObjects")]
            internal static extern void ImGuiImplDX11InvalidateDeviceObjects();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("cimgui.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="ImGui_ImplDX11_CreateDeviceObjects")]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ImGuiImplDX11CreateDeviceObjects();
        }

        public static bool ImGuiImplWin32Init(global::System.IntPtr hwnd)
        {
            var __ret = __Internal.ImGuiImplWin32Init(hwnd);
            return __ret;
        }

        public static void ImGuiImplWin32Shutdown()
        {
            __Internal.ImGuiImplWin32Shutdown();
        }

        public static void ImGuiImplWin32NewFrame()
        {
            __Internal.ImGuiImplWin32NewFrame();
        }

        public static bool ImGuiImplDX9Init(global::ImGui.IDirect3DDevice9 device)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            var __ret = __Internal.ImGuiImplDX9Init(__arg0);
            return __ret;
        }

        public static void ImGuiImplDX9Shutdown()
        {
            __Internal.ImGuiImplDX9Shutdown();
        }

        public static void ImGuiImplDX9NewFrame()
        {
            __Internal.ImGuiImplDX9NewFrame();
        }

        public static void ImGuiImplDX9RenderDrawData(global::ImGui.ImDrawData draw_data)
        {
            var __arg0 = ReferenceEquals(draw_data, null) ? global::System.IntPtr.Zero : draw_data.__Instance;
            __Internal.ImGuiImplDX9RenderDrawData(__arg0);
        }

        public static bool ImGuiImplDX9CreateDeviceObjects()
        {
            var __ret = __Internal.ImGuiImplDX9CreateDeviceObjects();
            return __ret;
        }

        public static void ImGuiImplDX9InvalidateDeviceObjects()
        {
            __Internal.ImGuiImplDX9InvalidateDeviceObjects();
        }

        public static bool ImGuiImplDX11Init(global::ImGui.ID3D11Device device, global::ImGui.ID3D11DeviceContext device_context)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            var __arg1 = ReferenceEquals(device_context, null) ? global::System.IntPtr.Zero : device_context.__Instance;
            var __ret = __Internal.ImGuiImplDX11Init(__arg0, __arg1);
            return __ret;
        }

        public static void ImGuiImplDX11Shutdown()
        {
            __Internal.ImGuiImplDX11Shutdown();
        }

        public static void ImGuiImplDX11NewFrame()
        {
            __Internal.ImGuiImplDX11NewFrame();
        }

        public static void ImGuiImplDX11RenderDrawData(global::ImGui.ImDrawData draw_data)
        {
            var __arg0 = ReferenceEquals(draw_data, null) ? global::System.IntPtr.Zero : draw_data.__Instance;
            __Internal.ImGuiImplDX11RenderDrawData(__arg0);
        }

        public static void ImGuiImplDX11InvalidateDeviceObjects()
        {
            __Internal.ImGuiImplDX11InvalidateDeviceObjects();
        }

        public static bool ImGuiImplDX11CreateDeviceObjects()
        {
            var __ret = __Internal.ImGuiImplDX11CreateDeviceObjects();
            return __ret;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr_IntPtr_string(global::System.IntPtr ctx, global::System.IntPtr handler, [MarshalAs(UnmanagedType.LPUTF8Str)] string name);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr_IntPtr_string(global::System.IntPtr ctx, global::System.IntPtr handler, global::System.IntPtr entry, [MarshalAs(UnmanagedType.LPUTF8Str)] string line);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr_IntPtr(global::System.IntPtr ctx, global::System.IntPtr handler, global::System.IntPtr out_buf);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate global::System.IntPtr Func_IntPtr_IntPtr(global::System.IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_string(global::System.IntPtr user_data, [MarshalAs(UnmanagedType.LPUTF8Str)] string text);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_int_int(int x, int y);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        public unsafe delegate bool Func_bool_IntPtr_int_sbytePtrPtr(global::System.IntPtr data, int idx, sbyte** out_text);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate float Func_float_IntPtr_int(global::System.IntPtr data, int idx);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate global::System.IntPtr Func_IntPtr_ulong_IntPtr(ulong sz, global::System.IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_IntPtr(global::System.IntPtr ptr, global::System.IntPtr user_data);
    }
}
