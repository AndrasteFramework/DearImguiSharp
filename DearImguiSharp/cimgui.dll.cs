// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace DearImguiSharp
{
    public enum ImGuiWindowFlags
    {
        ImGuiWindowFlagsNone = 0,
        ImGuiWindowFlagsNoTitleBar = 1,
        ImGuiWindowFlagsNoResize = 2,
        ImGuiWindowFlagsNoMove = 4,
        ImGuiWindowFlagsNoScrollbar = 8,
        ImGuiWindowFlagsNoScrollWithMouse = 16,
        ImGuiWindowFlagsNoCollapse = 32,
        ImGuiWindowFlagsAlwaysAutoResize = 64,
        ImGuiWindowFlagsNoBackground = 128,
        ImGuiWindowFlagsNoSavedSettings = 256,
        ImGuiWindowFlagsNoMouseInputs = 512,
        ImGuiWindowFlagsMenuBar = 1024,
        ImGuiWindowFlagsHorizontalScrollbar = 2048,
        ImGuiWindowFlagsNoFocusOnAppearing = 4096,
        ImGuiWindowFlagsNoBringToFrontOnFocus = 8192,
        ImGuiWindowFlagsAlwaysVerticalScrollbar = 16384,
        ImGuiWindowFlagsAlwaysHorizontalScrollbar = 32768,
        ImGuiWindowFlagsAlwaysUseWindowPadding = 65536,
        ImGuiWindowFlagsNoNavInputs = 262144,
        ImGuiWindowFlagsNoNavFocus = 524288,
        ImGuiWindowFlagsUnsavedDocument = 1048576,
        ImGuiWindowFlagsNoNav = 786432,
        ImGuiWindowFlagsNoDecoration = 43,
        ImGuiWindowFlagsNoInputs = 786944,
        ImGuiWindowFlagsNavFlattened = 8388608,
        ImGuiWindowFlagsChildWindow = 16777216,
        ImGuiWindowFlagsTooltip = 33554432,
        ImGuiWindowFlagsPopup = 67108864,
        ImGuiWindowFlagsModal = 134217728,
        ImGuiWindowFlagsChildMenu = 268435456
    }

    [Flags]
    public enum ImGuiInputTextFlags
    {
        ImGuiInputTextFlagsNone = 0,
        ImGuiInputTextFlagsCharsDecimal = 1,
        ImGuiInputTextFlagsCharsHexadecimal = 2,
        ImGuiInputTextFlagsCharsUppercase = 4,
        ImGuiInputTextFlagsCharsNoBlank = 8,
        ImGuiInputTextFlagsAutoSelectAll = 16,
        ImGuiInputTextFlagsEnterReturnsTrue = 32,
        ImGuiInputTextFlagsCallbackCompletion = 64,
        ImGuiInputTextFlagsCallbackHistory = 128,
        ImGuiInputTextFlagsCallbackAlways = 256,
        ImGuiInputTextFlagsCallbackCharFilter = 512,
        ImGuiInputTextFlagsAllowTabInput = 1024,
        ImGuiInputTextFlagsCtrlEnterForNewLine = 2048,
        ImGuiInputTextFlagsNoHorizontalScroll = 4096,
        ImGuiInputTextFlagsAlwaysInsertMode = 8192,
        ImGuiInputTextFlagsReadOnly = 16384,
        ImGuiInputTextFlagsPassword = 32768,
        ImGuiInputTextFlagsNoUndoRedo = 65536,
        ImGuiInputTextFlagsCharsScientific = 131072,
        ImGuiInputTextFlagsCallbackResize = 262144,
        ImGuiInputTextFlagsCallbackEdit = 524288,
        ImGuiInputTextFlagsMultiline = 1048576,
        ImGuiInputTextFlagsNoMarkEdited = 2097152
    }

    public enum ImGuiTreeNodeFlags
    {
        ImGuiTreeNodeFlagsNone = 0,
        ImGuiTreeNodeFlagsSelected = 1,
        ImGuiTreeNodeFlagsFramed = 2,
        ImGuiTreeNodeFlagsAllowItemOverlap = 4,
        ImGuiTreeNodeFlagsNoTreePushOnOpen = 8,
        ImGuiTreeNodeFlagsNoAutoOpenOnLog = 16,
        ImGuiTreeNodeFlagsDefaultOpen = 32,
        ImGuiTreeNodeFlagsOpenOnDoubleClick = 64,
        ImGuiTreeNodeFlagsOpenOnArrow = 128,
        ImGuiTreeNodeFlagsLeaf = 256,
        ImGuiTreeNodeFlagsBullet = 512,
        ImGuiTreeNodeFlagsFramePadding = 1024,
        ImGuiTreeNodeFlagsSpanAvailWidth = 2048,
        ImGuiTreeNodeFlagsSpanFullWidth = 4096,
        ImGuiTreeNodeFlagsNavLeftJumpsBackHere = 8192,
        ImGuiTreeNodeFlagsCollapsingHeader = 26
    }

    public enum ImGuiPopupFlags
    {
        ImGuiPopupFlagsNone = 0,
        ImGuiPopupFlagsMouseButtonLeft = 0,
        ImGuiPopupFlagsMouseButtonRight = 1,
        ImGuiPopupFlagsMouseButtonMiddle = 2,
        ImGuiPopupFlagsMouseButtonMask = 31,
        ImGuiPopupFlagsMouseButtonDefault = 1,
        ImGuiPopupFlagsNoOpenOverExistingPopup = 32,
        ImGuiPopupFlagsNoOpenOverItems = 64,
        ImGuiPopupFlagsAnyPopupId = 128,
        ImGuiPopupFlagsAnyPopupLevel = 256,
        ImGuiPopupFlagsAnyPopup = 384
    }

    [Flags]
    public enum ImGuiSelectableFlags
    {
        ImGuiSelectableFlagsNone = 0,
        ImGuiSelectableFlagsDontClosePopups = 1,
        ImGuiSelectableFlagsSpanAllColumns = 2,
        ImGuiSelectableFlagsAllowDoubleClick = 4,
        ImGuiSelectableFlagsDisabled = 8,
        ImGuiSelectableFlagsAllowItemOverlap = 16
    }

    public enum ImGuiComboFlags
    {
        ImGuiComboFlagsNone = 0,
        ImGuiComboFlagsPopupAlignLeft = 1,
        ImGuiComboFlagsHeightSmall = 2,
        ImGuiComboFlagsHeightRegular = 4,
        ImGuiComboFlagsHeightLarge = 8,
        ImGuiComboFlagsHeightLargest = 16,
        ImGuiComboFlagsNoArrowButton = 32,
        ImGuiComboFlagsNoPreview = 64,
        ImGuiComboFlagsHeightMask = 30
    }

    public enum ImGuiTabBarFlags
    {
        ImGuiTabBarFlagsNone = 0,
        ImGuiTabBarFlagsReorderable = 1,
        ImGuiTabBarFlagsAutoSelectNewTabs = 2,
        ImGuiTabBarFlagsTabListPopupButton = 4,
        ImGuiTabBarFlagsNoCloseWithMiddleMouseButton = 8,
        ImGuiTabBarFlagsNoTabListScrollingButtons = 16,
        ImGuiTabBarFlagsNoTooltip = 32,
        ImGuiTabBarFlagsFittingPolicyResizeDown = 64,
        ImGuiTabBarFlagsFittingPolicyScroll = 128,
        ImGuiTabBarFlagsFittingPolicyMask = 192,
        ImGuiTabBarFlagsFittingPolicyDefault = 64
    }

    [Flags]
    public enum ImGuiTabItemFlags
    {
        ImGuiTabItemFlagsNone = 0,
        ImGuiTabItemFlagsUnsavedDocument = 1,
        ImGuiTabItemFlagsSetSelected = 2,
        ImGuiTabItemFlagsNoCloseWithMiddleMouseButton = 4,
        ImGuiTabItemFlagsNoPushId = 8,
        ImGuiTabItemFlagsNoTooltip = 16,
        ImGuiTabItemFlagsNoReorder = 32,
        ImGuiTabItemFlagsLeading = 64,
        ImGuiTabItemFlagsTrailing = 128
    }

    public enum ImGuiTableFlags
    {
        ImGuiTableFlagsNone = 0,
        ImGuiTableFlagsResizable = 1,
        ImGuiTableFlagsReorderable = 2,
        ImGuiTableFlagsHideable = 4,
        ImGuiTableFlagsSortable = 8,
        ImGuiTableFlagsNoSavedSettings = 16,
        ImGuiTableFlagsContextMenuInBody = 32,
        ImGuiTableFlagsRowBg = 64,
        ImGuiTableFlagsBordersInnerH = 128,
        ImGuiTableFlagsBordersOuterH = 256,
        ImGuiTableFlagsBordersInnerV = 512,
        ImGuiTableFlagsBordersOuterV = 1024,
        ImGuiTableFlagsBordersH = 384,
        ImGuiTableFlagsBordersV = 1536,
        ImGuiTableFlagsBordersInner = 640,
        ImGuiTableFlagsBordersOuter = 1280,
        ImGuiTableFlagsBorders = 1920,
        ImGuiTableFlagsNoBordersInBody = 2048,
        ImGuiTableFlagsNoBordersInBodyUntilResize = 4096,
        ImGuiTableFlagsSizingFixedFit = 8192,
        ImGuiTableFlagsSizingFixedSame = 16384,
        ImGuiTableFlagsSizingStretchProp = 24576,
        ImGuiTableFlagsSizingStretchSame = 32768,
        ImGuiTableFlagsNoHostExtendX = 65536,
        ImGuiTableFlagsNoHostExtendY = 131072,
        ImGuiTableFlagsNoKeepColumnsVisible = 262144,
        ImGuiTableFlagsPreciseWidths = 524288,
        ImGuiTableFlagsNoClip = 1048576,
        ImGuiTableFlagsPadOuterX = 2097152,
        ImGuiTableFlagsNoPadOuterX = 4194304,
        ImGuiTableFlagsNoPadInnerX = 8388608,
        ImGuiTableFlagsScrollX = 16777216,
        ImGuiTableFlagsScrollY = 33554432,
        ImGuiTableFlagsSortMulti = 67108864,
        ImGuiTableFlagsSortTristate = 134217728,
        ImGuiTableFlagsSizingMask = 57344
    }

    public enum ImGuiTableColumnFlags
    {
        ImGuiTableColumnFlagsNone = 0,
        ImGuiTableColumnFlagsDefaultHide = 1,
        ImGuiTableColumnFlagsDefaultSort = 2,
        ImGuiTableColumnFlagsWidthStretch = 4,
        ImGuiTableColumnFlagsWidthFixed = 8,
        ImGuiTableColumnFlagsNoResize = 16,
        ImGuiTableColumnFlagsNoReorder = 32,
        ImGuiTableColumnFlagsNoHide = 64,
        ImGuiTableColumnFlagsNoClip = 128,
        ImGuiTableColumnFlagsNoSort = 256,
        ImGuiTableColumnFlagsNoSortAscending = 512,
        ImGuiTableColumnFlagsNoSortDescending = 1024,
        ImGuiTableColumnFlagsNoHeaderWidth = 2048,
        ImGuiTableColumnFlagsPreferSortAscending = 4096,
        ImGuiTableColumnFlagsPreferSortDescending = 8192,
        ImGuiTableColumnFlagsIndentEnable = 16384,
        ImGuiTableColumnFlagsIndentDisable = 32768,
        ImGuiTableColumnFlagsIsEnabled = 1048576,
        ImGuiTableColumnFlagsIsVisible = 2097152,
        ImGuiTableColumnFlagsIsSorted = 4194304,
        ImGuiTableColumnFlagsIsHovered = 8388608,
        ImGuiTableColumnFlagsWidthMask = 12,
        ImGuiTableColumnFlagsIndentMask = 49152,
        ImGuiTableColumnFlagsStatusMask = 15728640,
        ImGuiTableColumnFlagsNoDirectResize = 1073741824
    }

    public enum ImGuiTableRowFlags
    {
        ImGuiTableRowFlagsNone = 0,
        ImGuiTableRowFlagsHeaders = 1
    }

    public enum ImGuiTableBgTarget
    {
        ImGuiTableBgTargetNone = 0,
        ImGuiTableBgTargetRowBg0 = 1,
        ImGuiTableBgTargetRowBg1 = 2,
        ImGuiTableBgTargetCellBg = 3
    }

    public enum ImGuiFocusedFlags
    {
        ImGuiFocusedFlagsNone = 0,
        ImGuiFocusedFlagsChildWindows = 1,
        ImGuiFocusedFlagsRootWindow = 2,
        ImGuiFocusedFlagsAnyWindow = 4,
        ImGuiFocusedFlagsRootAndChildWindows = 3
    }

    public enum ImGuiHoveredFlags
    {
        ImGuiHoveredFlagsNone = 0,
        ImGuiHoveredFlagsChildWindows = 1,
        ImGuiHoveredFlagsRootWindow = 2,
        ImGuiHoveredFlagsAnyWindow = 4,
        ImGuiHoveredFlagsAllowWhenBlockedByPopup = 8,
        ImGuiHoveredFlagsAllowWhenBlockedByActiveItem = 32,
        ImGuiHoveredFlagsAllowWhenOverlapped = 64,
        ImGuiHoveredFlagsAllowWhenDisabled = 128,
        ImGuiHoveredFlagsRectOnly = 104,
        ImGuiHoveredFlagsRootAndChildWindows = 3
    }

    public enum ImGuiDragDropFlags
    {
        ImGuiDragDropFlagsNone = 0,
        ImGuiDragDropFlagsSourceNoPreviewTooltip = 1,
        ImGuiDragDropFlagsSourceNoDisableHover = 2,
        ImGuiDragDropFlagsSourceNoHoldToOpenOthers = 4,
        ImGuiDragDropFlagsSourceAllowNullID = 8,
        ImGuiDragDropFlagsSourceExtern = 16,
        ImGuiDragDropFlagsSourceAutoExpirePayload = 32,
        ImGuiDragDropFlagsAcceptBeforeDelivery = 1024,
        ImGuiDragDropFlagsAcceptNoDrawDefaultRect = 2048,
        ImGuiDragDropFlagsAcceptNoPreviewTooltip = 4096,
        ImGuiDragDropFlagsAcceptPeekOnly = 3072
    }

    public enum ImGuiDataType
    {
        ImGuiDataTypeS8 = 0,
        ImGuiDataTypeU8 = 1,
        ImGuiDataTypeS16 = 2,
        ImGuiDataTypeU16 = 3,
        ImGuiDataTypeS32 = 4,
        ImGuiDataTypeU32 = 5,
        ImGuiDataTypeS64 = 6,
        ImGuiDataTypeU64 = 7,
        ImGuiDataTypeFloat = 8,
        ImGuiDataTypeDouble = 9,
        ImGuiDataTypeCOUNT = 10
    }

    public enum ImGuiDir
    {
        ImGuiDirNone = -1,
        ImGuiDirLeft = 0,
        ImGuiDirRight = 1,
        ImGuiDirUp = 2,
        ImGuiDirDown = 3,
        ImGuiDirCOUNT = 4
    }

    public enum ImGuiSortDirection
    {
        ImGuiSortDirectionNone = 0,
        ImGuiSortDirectionAscending = 1,
        ImGuiSortDirectionDescending = 2
    }

    public enum ImGuiKey
    {
        ImGuiKeyTab = 0,
        ImGuiKeyLeftArrow = 1,
        ImGuiKeyRightArrow = 2,
        ImGuiKeyUpArrow = 3,
        ImGuiKeyDownArrow = 4,
        ImGuiKeyPageUp = 5,
        ImGuiKeyPageDown = 6,
        ImGuiKeyHome = 7,
        ImGuiKeyEnd = 8,
        ImGuiKeyInsert = 9,
        ImGuiKeyDelete = 10,
        ImGuiKeyBackspace = 11,
        ImGuiKeySpace = 12,
        ImGuiKeyEnter = 13,
        ImGuiKeyEscape = 14,
        ImGuiKeyKeyPadEnter = 15,
        ImGuiKeyA = 16,
        ImGuiKeyC = 17,
        ImGuiKeyV = 18,
        ImGuiKeyX = 19,
        ImGuiKeyY = 20,
        ImGuiKeyZ = 21,
        ImGuiKeyCOUNT = 22
    }

    [Flags]
    public enum ImGuiKeyModFlags
    {
        ImGuiKeyModFlagsNone = 0,
        ImGuiKeyModFlagsCtrl = 1,
        ImGuiKeyModFlagsShift = 2,
        ImGuiKeyModFlagsAlt = 4,
        ImGuiKeyModFlagsSuper = 8
    }

    public enum ImGuiNavInput
    {
        ImGuiNavInputActivate = 0,
        ImGuiNavInputCancel = 1,
        ImGuiNavInputInput = 2,
        ImGuiNavInputMenu = 3,
        ImGuiNavInputDpadLeft = 4,
        ImGuiNavInputDpadRight = 5,
        ImGuiNavInputDpadUp = 6,
        ImGuiNavInputDpadDown = 7,
        ImGuiNavInputLStickLeft = 8,
        ImGuiNavInputLStickRight = 9,
        ImGuiNavInputLStickUp = 10,
        ImGuiNavInputLStickDown = 11,
        ImGuiNavInputFocusPrev = 12,
        ImGuiNavInputFocusNext = 13,
        ImGuiNavInputTweakSlow = 14,
        ImGuiNavInputTweakFast = 15,
        ImGuiNavInputKeyMenu = 16,
        ImGuiNavInputKeyLeft = 17,
        ImGuiNavInputKeyRight = 18,
        ImGuiNavInputKeyUp = 19,
        ImGuiNavInputKeyDown = 20,
        ImGuiNavInputCOUNT = 21,
        ImGuiNavInputInternalStart = 16
    }

    [Flags]
    public enum ImGuiConfigFlags
    {
        ImGuiConfigFlagsNone = 0,
        ImGuiConfigFlagsNavEnableKeyboard = 1,
        ImGuiConfigFlagsNavEnableGamepad = 2,
        ImGuiConfigFlagsNavEnableSetMousePos = 4,
        ImGuiConfigFlagsNavNoCaptureKeyboard = 8,
        ImGuiConfigFlagsNoMouse = 16,
        ImGuiConfigFlagsNoMouseCursorChange = 32,
        ImGuiConfigFlagsIsSRGB = 1048576,
        ImGuiConfigFlagsIsTouchScreen = 2097152
    }

    [Flags]
    public enum ImGuiBackendFlags
    {
        ImGuiBackendFlagsNone = 0,
        ImGuiBackendFlagsHasGamepad = 1,
        ImGuiBackendFlagsHasMouseCursors = 2,
        ImGuiBackendFlagsHasSetMousePos = 4,
        ImGuiBackendFlagsRendererHasVtxOffset = 8
    }

    public enum ImGuiCol
    {
        ImGuiColText = 0,
        ImGuiColTextDisabled = 1,
        ImGuiColWindowBg = 2,
        ImGuiColChildBg = 3,
        ImGuiColPopupBg = 4,
        ImGuiColBorder = 5,
        ImGuiColBorderShadow = 6,
        ImGuiColFrameBg = 7,
        ImGuiColFrameBgHovered = 8,
        ImGuiColFrameBgActive = 9,
        ImGuiColTitleBg = 10,
        ImGuiColTitleBgActive = 11,
        ImGuiColTitleBgCollapsed = 12,
        ImGuiColMenuBarBg = 13,
        ImGuiColScrollbarBg = 14,
        ImGuiColScrollbarGrab = 15,
        ImGuiColScrollbarGrabHovered = 16,
        ImGuiColScrollbarGrabActive = 17,
        ImGuiColCheckMark = 18,
        ImGuiColSliderGrab = 19,
        ImGuiColSliderGrabActive = 20,
        ImGuiColButton = 21,
        ImGuiColButtonHovered = 22,
        ImGuiColButtonActive = 23,
        ImGuiColHeader = 24,
        ImGuiColHeaderHovered = 25,
        ImGuiColHeaderActive = 26,
        ImGuiColSeparator = 27,
        ImGuiColSeparatorHovered = 28,
        ImGuiColSeparatorActive = 29,
        ImGuiColResizeGrip = 30,
        ImGuiColResizeGripHovered = 31,
        ImGuiColResizeGripActive = 32,
        ImGuiColTab = 33,
        ImGuiColTabHovered = 34,
        ImGuiColTabActive = 35,
        ImGuiColTabUnfocused = 36,
        ImGuiColTabUnfocusedActive = 37,
        ImGuiColPlotLines = 38,
        ImGuiColPlotLinesHovered = 39,
        ImGuiColPlotHistogram = 40,
        ImGuiColPlotHistogramHovered = 41,
        ImGuiColTableHeaderBg = 42,
        ImGuiColTableBorderStrong = 43,
        ImGuiColTableBorderLight = 44,
        ImGuiColTableRowBg = 45,
        ImGuiColTableRowBgAlt = 46,
        ImGuiColTextSelectedBg = 47,
        ImGuiColDragDropTarget = 48,
        ImGuiColNavHighlight = 49,
        ImGuiColNavWindowingHighlight = 50,
        ImGuiColNavWindowingDimBg = 51,
        ImGuiColModalWindowDimBg = 52,
        ImGuiColCOUNT = 53
    }

    public enum ImGuiStyleVar
    {
        ImGuiStyleVarAlpha = 0,
        ImGuiStyleVarWindowPadding = 1,
        ImGuiStyleVarWindowRounding = 2,
        ImGuiStyleVarWindowBorderSize = 3,
        ImGuiStyleVarWindowMinSize = 4,
        ImGuiStyleVarWindowTitleAlign = 5,
        ImGuiStyleVarChildRounding = 6,
        ImGuiStyleVarChildBorderSize = 7,
        ImGuiStyleVarPopupRounding = 8,
        ImGuiStyleVarPopupBorderSize = 9,
        ImGuiStyleVarFramePadding = 10,
        ImGuiStyleVarFrameRounding = 11,
        ImGuiStyleVarFrameBorderSize = 12,
        ImGuiStyleVarItemSpacing = 13,
        ImGuiStyleVarItemInnerSpacing = 14,
        ImGuiStyleVarIndentSpacing = 15,
        ImGuiStyleVarCellPadding = 16,
        ImGuiStyleVarScrollbarSize = 17,
        ImGuiStyleVarScrollbarRounding = 18,
        ImGuiStyleVarGrabMinSize = 19,
        ImGuiStyleVarGrabRounding = 20,
        ImGuiStyleVarTabRounding = 21,
        ImGuiStyleVarButtonTextAlign = 22,
        ImGuiStyleVarSelectableTextAlign = 23,
        ImGuiStyleVarCOUNT = 24
    }

    public enum ImGuiButtonFlags
    {
        ImGuiButtonFlagsNone = 0,
        ImGuiButtonFlagsMouseButtonLeft = 1,
        ImGuiButtonFlagsMouseButtonRight = 2,
        ImGuiButtonFlagsMouseButtonMiddle = 4,
        ImGuiButtonFlagsMouseButtonMask = 7,
        ImGuiButtonFlagsMouseButtonDefault = 1
    }

    public enum ImGuiColorEditFlags
    {
        ImGuiColorEditFlagsNone = 0,
        ImGuiColorEditFlagsNoAlpha = 2,
        ImGuiColorEditFlagsNoPicker = 4,
        ImGuiColorEditFlagsNoOptions = 8,
        ImGuiColorEditFlagsNoSmallPreview = 16,
        ImGuiColorEditFlagsNoInputs = 32,
        ImGuiColorEditFlagsNoTooltip = 64,
        ImGuiColorEditFlagsNoLabel = 128,
        ImGuiColorEditFlagsNoSidePreview = 256,
        ImGuiColorEditFlagsNoDragDrop = 512,
        ImGuiColorEditFlagsNoBorder = 1024,
        ImGuiColorEditFlagsAlphaBar = 65536,
        ImGuiColorEditFlagsAlphaPreview = 131072,
        ImGuiColorEditFlagsAlphaPreviewHalf = 262144,
        ImGuiColorEditFlagsHDR = 524288,
        ImGuiColorEditFlagsDisplayRGB = 1048576,
        ImGuiColorEditFlagsDisplayHSV = 2097152,
        ImGuiColorEditFlagsDisplayHex = 4194304,
        ImGuiColorEditFlagsUint8 = 8388608,
        ImGuiColorEditFlagsFloat = 16777216,
        ImGuiColorEditFlagsPickerHueBar = 33554432,
        ImGuiColorEditFlagsPickerHueWheel = 67108864,
        ImGuiColorEditFlagsInputRGB = 134217728,
        ImGuiColorEditFlagsInputHSV = 268435456,
        ImGuiColorEditFlagsOptionsDefault = 177209344,
        ImGuiColorEditFlagsDisplayMask = 7340032,
        ImGuiColorEditFlagsDataTypeMask = 25165824,
        ImGuiColorEditFlagsPickerMask = 100663296,
        ImGuiColorEditFlagsInputMask = 402653184
    }

    public enum ImGuiSliderFlags
    {
        ImGuiSliderFlagsNone = 0,
        ImGuiSliderFlagsAlwaysClamp = 16,
        ImGuiSliderFlagsLogarithmic = 32,
        ImGuiSliderFlagsNoRoundToFormat = 64,
        ImGuiSliderFlagsNoInput = 128,
        ImGuiSliderFlagsInvalidMask = 1879048207
    }

    public enum ImGuiMouseButton
    {
        ImGuiMouseButtonLeft = 0,
        ImGuiMouseButtonRight = 1,
        ImGuiMouseButtonMiddle = 2,
        ImGuiMouseButtonCOUNT = 5
    }

    public enum ImGuiMouseCursor
    {
        ImGuiMouseCursorNone = -1,
        ImGuiMouseCursorArrow = 0,
        ImGuiMouseCursorTextInput = 1,
        ImGuiMouseCursorResizeAll = 2,
        ImGuiMouseCursorResizeNS = 3,
        ImGuiMouseCursorResizeEW = 4,
        ImGuiMouseCursorResizeNESW = 5,
        ImGuiMouseCursorResizeNWSE = 6,
        ImGuiMouseCursorHand = 7,
        ImGuiMouseCursorNotAllowed = 8,
        ImGuiMouseCursorCOUNT = 9
    }

    [Flags]
    public enum ImGuiCond
    {
        ImGuiCondNone = 0,
        ImGuiCondAlways = 1,
        ImGuiCondOnce = 2,
        ImGuiCondFirstUseEver = 4,
        ImGuiCondAppearing = 8
    }

    public enum ImDrawCornerFlags
    {
        ImDrawCornerFlagsNone = 0,
        ImDrawCornerFlagsTopLeft = 1,
        ImDrawCornerFlagsTopRight = 2,
        ImDrawCornerFlagsBotLeft = 4,
        ImDrawCornerFlagsBotRight = 8,
        ImDrawCornerFlagsTop = 3,
        ImDrawCornerFlagsBot = 12,
        ImDrawCornerFlagsLeft = 5,
        ImDrawCornerFlagsRight = 10,
        ImDrawCornerFlagsAll = 15
    }

    [Flags]
    public enum ImDrawListFlags
    {
        ImDrawListFlagsNone = 0,
        ImDrawListFlagsAntiAliasedLines = 1,
        ImDrawListFlagsAntiAliasedLinesUseTex = 2,
        ImDrawListFlagsAntiAliasedFill = 4,
        ImDrawListFlagsAllowVtxOffset = 8
    }

    [Flags]
    public enum ImFontAtlasFlags
    {
        ImFontAtlasFlagsNone = 0,
        ImFontAtlasFlagsNoPowerOfTwoHeight = 1,
        ImFontAtlasFlagsNoMouseCursors = 2,
        ImFontAtlasFlagsNoBakedLines = 4
    }

    [Flags]
    public enum ImGuiViewportFlags
    {
        ImGuiViewportFlagsNone = 0,
        ImGuiViewportFlagsIsPlatformWindow = 1,
        ImGuiViewportFlagsIsPlatformMonitor = 2,
        ImGuiViewportFlagsOwnedByApp = 4
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImDrawCallback(__IntPtr parent_list, __IntPtr cmd);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int ImGuiInputTextCallback(__IntPtr data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiSizeCallback(__IntPtr data);

    public unsafe partial class ImFontBuilderIO
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontBuilderIO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontBuilderIO>();

        protected bool __ownsNativeInstance;

        internal static ImFontBuilderIO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontBuilderIO(native.ToPointer(), skipVTables);
        }

        internal static ImFontBuilderIO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontBuilderIO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontBuilderIO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontBuilderIO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontBuilderIO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontBuilderIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImGuiContext
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiContext>();

        protected bool __ownsNativeInstance;

        internal static ImGuiContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiContext(native.ToPointer(), skipVTables);
        }

        internal static ImGuiContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImDrawListSharedData
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawListSharedData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawListSharedData>();

        protected bool __ownsNativeInstance;

        internal static ImDrawListSharedData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawListSharedData(native.ToPointer(), skipVTables);
        }

        internal static ImDrawListSharedData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawListSharedData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawListSharedData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawListSharedData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawListSharedData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawListSharedData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImVector : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVector> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVector>();

        protected bool __ownsNativeInstance;

        internal static ImVector __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVector(native.ToPointer(), skipVTables);
        }

        internal static ImVector __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVector)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVector __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVector(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVector(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVector()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVector(global::DearImguiSharp.ImVector _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVector.__Internal*) __Instance) = *((global::DearImguiSharp.ImVector.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public __IntPtr Data
        {
            get
            {
                return ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImDrawChannel : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImDrawChannel@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImDrawChannel> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImDrawChannel>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawChannel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawChannel(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawChannel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImDrawChannel)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImDrawChannel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawChannel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawChannel(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawChannel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawChannel()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawChannel(global::DearImguiSharp.ImVectorImDrawChannel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImDrawChannel.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImDrawChannel.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImDrawChannel Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawChannel.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImDrawCmd : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImDrawCmd@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImDrawCmd> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImDrawCmd>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawCmd __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawCmd(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawCmd __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImDrawCmd)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImDrawCmd __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawCmd(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawCmd(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawCmd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawCmd()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawCmd(global::DearImguiSharp.ImVectorImDrawCmd _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImDrawCmd.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImDrawCmd.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImDrawCmd Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawCmd.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImDrawIdx : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImDrawIdx@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImDrawIdx> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImDrawIdx>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawIdx __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawIdx(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawIdx __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImDrawIdx)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImDrawIdx __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawIdx(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawIdx(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawIdx(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawIdx()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawIdx.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawIdx(global::DearImguiSharp.ImVectorImDrawIdx _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawIdx.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImDrawIdx.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImDrawIdx.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public ushort* Data
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImDrawVert : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImDrawVert@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImDrawVert> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImDrawVert>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawVert __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawVert(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawVert __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImDrawVert)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImDrawVert __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawVert(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawVert(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawVert(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawVert()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawVert.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImDrawVert(global::DearImguiSharp.ImVectorImDrawVert _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawVert.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImDrawVert.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImDrawVert.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImDrawVert Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawVert.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImFontPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImFontPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImFontPtr> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImFontPtr>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontPtr(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImFontPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImFontPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontPtr.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontPtr(global::DearImguiSharp.ImVectorImFontPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontPtr.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImFontPtr.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImFontPtr.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImFont Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->Data = new __IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImVectorImFontAtlasCustomRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImFontAtlasCustomRect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImFontAtlasCustomRect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImFontAtlasCustomRect>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontAtlasCustomRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontAtlasCustomRect(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontAtlasCustomRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImFontAtlasCustomRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImFontAtlasCustomRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontAtlasCustomRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontAtlasCustomRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontAtlasCustomRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontAtlasCustomRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontAtlasCustomRect(global::DearImguiSharp.ImVectorImFontAtlasCustomRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImFontAtlasCustomRect Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontAtlasCustomRect.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImFontConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImFontConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImFontConfig> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImFontConfig>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontConfig(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImFontConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImFontConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontConfig(global::DearImguiSharp.ImVectorImFontConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImFontConfig.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImFontConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImFontConfig Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontConfig.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImFontGlyph : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImFontGlyph@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImFontGlyph> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImFontGlyph>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontGlyph __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontGlyph(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontGlyph __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImFontGlyph)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImFontGlyph __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontGlyph(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontGlyph(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontGlyph(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontGlyph()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImFontGlyph(global::DearImguiSharp.ImVectorImFontGlyph _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImFontGlyph.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImFontGlyph.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImFontGlyph Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontGlyph.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiStoragePair : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImGuiStoragePair@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImGuiStoragePair> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImGuiStoragePair>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiStoragePair __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiStoragePair(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiStoragePair __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImGuiStoragePair)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImGuiStoragePair __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiStoragePair(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiStoragePair(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiStoragePair(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiStoragePair()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiStoragePair(global::DearImguiSharp.ImVectorImGuiStoragePair _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiStoragePair Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiStoragePair.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTextRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImGuiTextRange@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImGuiTextRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImGuiTextRange>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTextRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTextRange(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTextRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImGuiTextRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImGuiTextRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTextRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTextRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiTextRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTextRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImGuiTextRange(global::DearImguiSharp.ImVectorImGuiTextRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImGuiTextRange.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiTextRange.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiTextRange Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTextRange.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImTextureID : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImTextureID@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImTextureID> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImTextureID>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImTextureID __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImTextureID(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImTextureID __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImTextureID)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImTextureID __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImTextureID(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImTextureID(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImTextureID(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImTextureID()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImTextureID.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImTextureID(global::DearImguiSharp.ImVectorImTextureID _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImTextureID.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImTextureID.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImTextureID.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }
    }

    public unsafe partial class ImVectorImU32 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImU32@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImU32> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImU32>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImU32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImU32(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImU32 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImU32)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImU32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImU32(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImU32(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImU32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImU32()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImU32.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImU32(global::DearImguiSharp.ImVectorImU32 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImU32.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImU32.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImU32.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public uint* Data
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImVec2 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImVec2@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImVec2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImVec2>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImVec2 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImVec2(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImVec2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImVec2)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImVec2 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImVec2(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImVec2(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImVec2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImVec2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImVec2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImVec2(global::DearImguiSharp.ImVectorImVec2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImVec2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImVec2.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImVec2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImVec2 Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImVec2.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImVec4 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImVec4@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImVec4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImVec4>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImVec4 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImVec4(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImVec4 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImVec4)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImVec4 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImVec4(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImVec4(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImVec4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImVec4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImVec4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImVec4(global::DearImguiSharp.ImVectorImVec4 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImVec4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImVec4.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImVec4.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImVec4 Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImVec4.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImWchar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_ImWchar@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImWchar> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVectorImWchar>();

        protected bool __ownsNativeInstance;

        internal static ImVectorImWchar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImWchar(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImWchar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVectorImWchar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVectorImWchar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImWchar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImWchar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImWchar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImWchar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImWchar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVectorImWchar(global::DearImguiSharp.ImVectorImWchar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImWchar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVectorImWchar.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImWchar.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public ushort* Data
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVector_char : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_char@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVector_char> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVector_char>();

        protected bool __ownsNativeInstance;

        internal static ImVector_char __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVector_char(native.ToPointer(), skipVTables);
        }

        internal static ImVector_char __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVector_char)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVector_char __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVector_char(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_char(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVector_char(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVector_char()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_char.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVector_char(global::DearImguiSharp.ImVector_char _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_char.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVector_char.__Internal*) __Instance) = *((global::DearImguiSharp.ImVector_char.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public sbyte* Data
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVector_float : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVector_float@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVector_float> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVector_float>();

        protected bool __ownsNativeInstance;

        internal static ImVector_float __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVector_float(native.ToPointer(), skipVTables);
        }

        internal static ImVector_float __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVector_float)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVector_float __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVector_float(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_float(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVector_float(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVector_float()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_float.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVector_float(global::DearImguiSharp.ImVector_float _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_float.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVector_float.__Internal*) __Instance) = *((global::DearImguiSharp.ImVector_float.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public float* Data
        {
            get
            {
                return (float*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVec2 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public float x;
            public float y;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVec2@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVec2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVec2>();

        protected bool __ownsNativeInstance;

        internal static ImVec2 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec2(native.ToPointer(), skipVTables);
        }

        internal static ImVec2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVec2)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVec2 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec2(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec2(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVec2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVec2(global::DearImguiSharp.ImVec2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVec2.__Internal*) __Instance) = *((global::DearImguiSharp.ImVec2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    public unsafe partial class ImVec4 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public float x;
            public float y;
            public float z;
            public float w;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImVec4@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVec4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImVec4>();

        protected bool __ownsNativeInstance;

        internal static ImVec4 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec4(native.ToPointer(), skipVTables);
        }

        internal static ImVec4 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVec4)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVec4 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec4(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec4(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVec4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImVec4(global::DearImguiSharp.ImVec4 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImVec4.__Internal*) __Instance) = *((global::DearImguiSharp.ImVec4.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((__Internal*)__Instance)->z;
            }

            set
            {
                ((__Internal*)__Instance)->z = value;
            }
        }

        public float W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }
    }

    public unsafe partial class ImGuiStyle : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1044)]
        public partial struct __Internal
        {
            public float Alpha;
            public global::DearImguiSharp.ImVec2.__Internal WindowPadding;
            public float WindowRounding;
            public float WindowBorderSize;
            public global::DearImguiSharp.ImVec2.__Internal WindowMinSize;
            public global::DearImguiSharp.ImVec2.__Internal WindowTitleAlign;
            public int WindowMenuButtonPosition;
            public float ChildRounding;
            public float ChildBorderSize;
            public float PopupRounding;
            public float PopupBorderSize;
            public global::DearImguiSharp.ImVec2.__Internal FramePadding;
            public float FrameRounding;
            public float FrameBorderSize;
            public global::DearImguiSharp.ImVec2.__Internal ItemSpacing;
            public global::DearImguiSharp.ImVec2.__Internal ItemInnerSpacing;
            public global::DearImguiSharp.ImVec2.__Internal CellPadding;
            public global::DearImguiSharp.ImVec2.__Internal TouchExtraPadding;
            public float IndentSpacing;
            public float ColumnsMinSpacing;
            public float ScrollbarSize;
            public float ScrollbarRounding;
            public float GrabMinSize;
            public float GrabRounding;
            public float LogSliderDeadzone;
            public float TabRounding;
            public float TabBorderSize;
            public float TabMinWidthForCloseButton;
            public int ColorButtonPosition;
            public global::DearImguiSharp.ImVec2.__Internal ButtonTextAlign;
            public global::DearImguiSharp.ImVec2.__Internal SelectableTextAlign;
            public global::DearImguiSharp.ImVec2.__Internal DisplayWindowPadding;
            public global::DearImguiSharp.ImVec2.__Internal DisplaySafeAreaPadding;
            public float MouseCursorScale;
            public byte AntiAliasedLines;
            public byte AntiAliasedLinesUseTex;
            public byte AntiAliasedFill;
            public float CurveTessellationTol;
            public float CircleSegmentMaxError;
            public fixed byte Colors[848];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiStyle@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiStyle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiStyle>();

        protected bool __ownsNativeInstance;

        internal static ImGuiStyle __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStyle(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStyle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiStyle)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiStyle __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStyle(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStyle(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiStyle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStyle()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStyle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiStyle(global::DearImguiSharp.ImGuiStyle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStyle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiStyle.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiStyle.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Alpha
        {
            get
            {
                return ((__Internal*)__Instance)->Alpha;
            }

            set
            {
                ((__Internal*)__Instance)->Alpha = value;
            }
        }

        public global::DearImguiSharp.ImVec2 WindowPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float WindowRounding
        {
            get
            {
                return ((__Internal*)__Instance)->WindowRounding;
            }

            set
            {
                ((__Internal*)__Instance)->WindowRounding = value;
            }
        }

        public float WindowBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->WindowBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->WindowBorderSize = value;
            }
        }

        public global::DearImguiSharp.ImVec2 WindowMinSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowMinSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowMinSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WindowTitleAlign
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowTitleAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowTitleAlign = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public int WindowMenuButtonPosition
        {
            get
            {
                return ((__Internal*)__Instance)->WindowMenuButtonPosition;
            }

            set
            {
                ((__Internal*)__Instance)->WindowMenuButtonPosition = value;
            }
        }

        public float ChildRounding
        {
            get
            {
                return ((__Internal*)__Instance)->ChildRounding;
            }

            set
            {
                ((__Internal*)__Instance)->ChildRounding = value;
            }
        }

        public float ChildBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->ChildBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->ChildBorderSize = value;
            }
        }

        public float PopupRounding
        {
            get
            {
                return ((__Internal*)__Instance)->PopupRounding;
            }

            set
            {
                ((__Internal*)__Instance)->PopupRounding = value;
            }
        }

        public float PopupBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->PopupBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->PopupBorderSize = value;
            }
        }

        public global::DearImguiSharp.ImVec2 FramePadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FramePadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FramePadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float FrameRounding
        {
            get
            {
                return ((__Internal*)__Instance)->FrameRounding;
            }

            set
            {
                ((__Internal*)__Instance)->FrameRounding = value;
            }
        }

        public float FrameBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->FrameBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->FrameBorderSize = value;
            }
        }

        public global::DearImguiSharp.ImVec2 ItemSpacing
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemSpacing = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ItemInnerSpacing
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemInnerSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemInnerSpacing = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 CellPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CellPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CellPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 TouchExtraPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TouchExtraPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TouchExtraPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float IndentSpacing
        {
            get
            {
                return ((__Internal*)__Instance)->IndentSpacing;
            }

            set
            {
                ((__Internal*)__Instance)->IndentSpacing = value;
            }
        }

        public float ColumnsMinSpacing
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsMinSpacing;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsMinSpacing = value;
            }
        }

        public float ScrollbarSize
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarSize;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarSize = value;
            }
        }

        public float ScrollbarRounding
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarRounding;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarRounding = value;
            }
        }

        public float GrabMinSize
        {
            get
            {
                return ((__Internal*)__Instance)->GrabMinSize;
            }

            set
            {
                ((__Internal*)__Instance)->GrabMinSize = value;
            }
        }

        public float GrabRounding
        {
            get
            {
                return ((__Internal*)__Instance)->GrabRounding;
            }

            set
            {
                ((__Internal*)__Instance)->GrabRounding = value;
            }
        }

        public float LogSliderDeadzone
        {
            get
            {
                return ((__Internal*)__Instance)->LogSliderDeadzone;
            }

            set
            {
                ((__Internal*)__Instance)->LogSliderDeadzone = value;
            }
        }

        public float TabRounding
        {
            get
            {
                return ((__Internal*)__Instance)->TabRounding;
            }

            set
            {
                ((__Internal*)__Instance)->TabRounding = value;
            }
        }

        public float TabBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->TabBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->TabBorderSize = value;
            }
        }

        public float TabMinWidthForCloseButton
        {
            get
            {
                return ((__Internal*)__Instance)->TabMinWidthForCloseButton;
            }

            set
            {
                ((__Internal*)__Instance)->TabMinWidthForCloseButton = value;
            }
        }

        public int ColorButtonPosition
        {
            get
            {
                return ((__Internal*)__Instance)->ColorButtonPosition;
            }

            set
            {
                ((__Internal*)__Instance)->ColorButtonPosition = value;
            }
        }

        public global::DearImguiSharp.ImVec2 ButtonTextAlign
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ButtonTextAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ButtonTextAlign = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 SelectableTextAlign
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SelectableTextAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SelectableTextAlign = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 DisplayWindowPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayWindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayWindowPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 DisplaySafeAreaPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySafeAreaPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySafeAreaPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float MouseCursorScale
        {
            get
            {
                return ((__Internal*)__Instance)->MouseCursorScale;
            }

            set
            {
                ((__Internal*)__Instance)->MouseCursorScale = value;
            }
        }

        public bool AntiAliasedLines
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedLines != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedLines = (byte) (value ? 1 : 0);
            }
        }

        public bool AntiAliasedLinesUseTex
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedLinesUseTex != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedLinesUseTex = (byte) (value ? 1 : 0);
            }
        }

        public bool AntiAliasedFill
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedFill != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedFill = (byte) (value ? 1 : 0);
            }
        }

        public float CurveTessellationTol
        {
            get
            {
                return ((__Internal*)__Instance)->CurveTessellationTol;
            }

            set
            {
                ((__Internal*)__Instance)->CurveTessellationTol = value;
            }
        }

        public float CircleSegmentMaxError
        {
            get
            {
                return ((__Internal*)__Instance)->CircleSegmentMaxError;
            }

            set
            {
                ((__Internal*)__Instance)->CircleSegmentMaxError = value;
            }
        }

        public global::DearImguiSharp.ImVec4[] Colors
        {
            get
            {
                global::DearImguiSharp.ImVec4[] __value = null;
                if (((__Internal*)__Instance)->Colors != null)
                {
                    __value = new global::DearImguiSharp.ImVec4[53];
                    for (int i = 0; i < 53; i++)
                        __value[i] = global::DearImguiSharp.ImVec4.__CreateInstance(*((global::DearImguiSharp.ImVec4.__Internal*)&(((__Internal*)__Instance)->Colors[i * sizeof(global::DearImguiSharp.ImVec4.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 53)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 53; i++)
                        *(global::DearImguiSharp.ImVec4.__Internal*) &((__Internal*)__Instance)->Colors[i * sizeof(global::DearImguiSharp.ImVec4.__Internal)] = *(global::DearImguiSharp.ImVec4.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class ImGuiIO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 5464)]
        public partial struct __Internal
        {
            public int ConfigFlags;
            public int BackendFlags;
            public global::DearImguiSharp.ImVec2.__Internal DisplaySize;
            public float DeltaTime;
            public float IniSavingRate;
            public __IntPtr IniFilename;
            public __IntPtr LogFilename;
            public float MouseDoubleClickTime;
            public float MouseDoubleClickMaxDist;
            public float MouseDragThreshold;
            public fixed int KeyMap[22];
            public float KeyRepeatDelay;
            public float KeyRepeatRate;
            public __IntPtr UserData;
            public __IntPtr Fonts;
            public float FontGlobalScale;
            public byte FontAllowUserScaling;
            public __IntPtr FontDefault;
            public global::DearImguiSharp.ImVec2.__Internal DisplayFramebufferScale;
            public byte MouseDrawCursor;
            public byte ConfigMacOSXBehaviors;
            public byte ConfigInputTextCursorBlink;
            public byte ConfigDragClickToInputText;
            public byte ConfigWindowsResizeFromEdges;
            public byte ConfigWindowsMoveFromTitleBarOnly;
            public float ConfigMemoryCompactTimer;
            public __IntPtr BackendPlatformName;
            public __IntPtr BackendRendererName;
            public __IntPtr BackendPlatformUserData;
            public __IntPtr BackendRendererUserData;
            public __IntPtr BackendLanguageUserData;
            public __IntPtr GetClipboardTextFn;
            public __IntPtr SetClipboardTextFn;
            public __IntPtr ClipboardUserData;
            public __IntPtr ImeSetInputScreenPosFn;
            public __IntPtr ImeWindowHandle;
            public global::DearImguiSharp.ImVec2.__Internal MousePos;
            public fixed byte MouseDown[5];
            public float MouseWheel;
            public float MouseWheelH;
            public byte KeyCtrl;
            public byte KeyShift;
            public byte KeyAlt;
            public byte KeySuper;
            public fixed byte KeysDown[512];
            public fixed float NavInputs[21];
            public byte WantCaptureMouse;
            public byte WantCaptureKeyboard;
            public byte WantTextInput;
            public byte WantSetMousePos;
            public byte WantSaveIniSettings;
            public byte NavActive;
            public byte NavVisible;
            public float Framerate;
            public int MetricsRenderVertices;
            public int MetricsRenderIndices;
            public int MetricsRenderWindows;
            public int MetricsActiveWindows;
            public int MetricsActiveAllocations;
            public global::DearImguiSharp.ImVec2.__Internal MouseDelta;
            public int KeyMods;
            public global::DearImguiSharp.ImVec2.__Internal MousePosPrev;
            public fixed byte MouseClickedPos[40];
            public fixed double MouseClickedTime[5];
            public fixed byte MouseClicked[5];
            public fixed byte MouseDoubleClicked[5];
            public fixed byte MouseReleased[5];
            public fixed byte MouseDownOwned[5];
            public fixed byte MouseDownWasDoubleClick[5];
            public fixed float MouseDownDuration[5];
            public fixed float MouseDownDurationPrev[5];
            public fixed byte MouseDragMaxDistanceAbs[40];
            public fixed float MouseDragMaxDistanceSqr[5];
            public fixed float KeysDownDuration[512];
            public fixed float KeysDownDurationPrev[512];
            public fixed float NavInputsDownDuration[21];
            public fixed float NavInputsDownDurationPrev[21];
            public float PenPressure;
            public ushort InputQueueSurrogate;
            public global::DearImguiSharp.ImVectorImWchar.__Internal InputQueueCharacters;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiIO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiIO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiIO>();

        protected bool __ownsNativeInstance;

        internal static ImGuiIO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiIO(native.ToPointer(), skipVTables);
        }

        internal static ImGuiIO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiIO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiIO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiIO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiIO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiIO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiIO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiIO(global::DearImguiSharp.ImGuiIO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiIO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiIO.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiIO.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int ConfigFlags
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigFlags;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigFlags = value;
            }
        }

        public int BackendFlags
        {
            get
            {
                return ((__Internal*)__Instance)->BackendFlags;
            }

            set
            {
                ((__Internal*)__Instance)->BackendFlags = value;
            }
        }

        public global::DearImguiSharp.ImVec2 DisplaySize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float DeltaTime
        {
            get
            {
                return ((__Internal*)__Instance)->DeltaTime;
            }

            set
            {
                ((__Internal*)__Instance)->DeltaTime = value;
            }
        }

        public float IniSavingRate
        {
            get
            {
                return ((__Internal*)__Instance)->IniSavingRate;
            }

            set
            {
                ((__Internal*)__Instance)->IniSavingRate = value;
            }
        }

        public string IniFilename
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->IniFilename);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->IniFilename = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string LogFilename
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->LogFilename);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->LogFilename = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public float MouseDoubleClickTime
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDoubleClickTime;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDoubleClickTime = value;
            }
        }

        public float MouseDoubleClickMaxDist
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDoubleClickMaxDist;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDoubleClickMaxDist = value;
            }
        }

        public float MouseDragThreshold
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDragThreshold;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDragThreshold = value;
            }
        }

        public int[] KeyMap
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->KeyMap, 22);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 22; i++)
                        ((__Internal*)__Instance)->KeyMap[i] = value[i];
                }
            }
        }

        public float KeyRepeatDelay
        {
            get
            {
                return ((__Internal*)__Instance)->KeyRepeatDelay;
            }

            set
            {
                ((__Internal*)__Instance)->KeyRepeatDelay = value;
            }
        }

        public float KeyRepeatRate
        {
            get
            {
                return ((__Internal*)__Instance)->KeyRepeatRate;
            }

            set
            {
                ((__Internal*)__Instance)->KeyRepeatRate = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.ImFontAtlas Fonts
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontAtlas.__GetOrCreateInstance(((__Internal*)__Instance)->Fonts, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Fonts = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float FontGlobalScale
        {
            get
            {
                return ((__Internal*)__Instance)->FontGlobalScale;
            }

            set
            {
                ((__Internal*)__Instance)->FontGlobalScale = value;
            }
        }

        public bool FontAllowUserScaling
        {
            get
            {
                return ((__Internal*)__Instance)->FontAllowUserScaling != 0;
            }

            set
            {
                ((__Internal*)__Instance)->FontAllowUserScaling = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImFont FontDefault
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->FontDefault, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->FontDefault = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 DisplayFramebufferScale
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayFramebufferScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayFramebufferScale = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool MouseDrawCursor
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDrawCursor != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDrawCursor = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigMacOSXBehaviors
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigMacOSXBehaviors != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigMacOSXBehaviors = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigInputTextCursorBlink
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigInputTextCursorBlink != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigInputTextCursorBlink = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigDragClickToInputText
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDragClickToInputText != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDragClickToInputText = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigWindowsResizeFromEdges
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigWindowsResizeFromEdges != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigWindowsResizeFromEdges = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigWindowsMoveFromTitleBarOnly
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigWindowsMoveFromTitleBarOnly != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigWindowsMoveFromTitleBarOnly = (byte) (value ? 1 : 0);
            }
        }

        public float ConfigMemoryCompactTimer
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigMemoryCompactTimer;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigMemoryCompactTimer = value;
            }
        }

        public string BackendPlatformName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->BackendPlatformName);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->BackendPlatformName = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string BackendRendererName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->BackendRendererName);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->BackendRendererName = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public __IntPtr BackendPlatformUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendPlatformUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendPlatformUserData = (__IntPtr) value;
            }
        }

        public __IntPtr BackendRendererUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendRendererUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendRendererUserData = (__IntPtr) value;
            }
        }

        public __IntPtr BackendLanguageUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendLanguageUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendLanguageUserData = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.Delegates.Func___IntPtr___IntPtr GetClipboardTextFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->GetClipboardTextFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Func___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Func___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->GetClipboardTextFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr__MarshalAs_UnmanagedType_CustomMarshaler__MarshalTypeRef___typeof_CppSharp_Runtime_UTF8Marshaller____string SetClipboardTextFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->SetClipboardTextFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr__MarshalAs_UnmanagedType_CustomMarshaler__MarshalTypeRef___typeof_CppSharp_Runtime_UTF8Marshaller____string) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr__MarshalAs_UnmanagedType_CustomMarshaler__MarshalTypeRef___typeof_CppSharp_Runtime_UTF8Marshaller____string));
            }

            set
            {
                ((__Internal*)__Instance)->SetClipboardTextFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr ClipboardUserData
        {
            get
            {
                return ((__Internal*)__Instance)->ClipboardUserData;
            }

            set
            {
                ((__Internal*)__Instance)->ClipboardUserData = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.Delegates.Action_int_int ImeSetInputScreenPosFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ImeSetInputScreenPosFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action_int_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action_int_int));
            }

            set
            {
                ((__Internal*)__Instance)->ImeSetInputScreenPosFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr ImeWindowHandle
        {
            get
            {
                return ((__Internal*)__Instance)->ImeWindowHandle;
            }

            set
            {
                ((__Internal*)__Instance)->ImeWindowHandle = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.ImVec2 MousePos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MousePos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool[] MouseDown
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDown, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDown[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float MouseWheel
        {
            get
            {
                return ((__Internal*)__Instance)->MouseWheel;
            }

            set
            {
                ((__Internal*)__Instance)->MouseWheel = value;
            }
        }

        public float MouseWheelH
        {
            get
            {
                return ((__Internal*)__Instance)->MouseWheelH;
            }

            set
            {
                ((__Internal*)__Instance)->MouseWheelH = value;
            }
        }

        public bool KeyCtrl
        {
            get
            {
                return ((__Internal*)__Instance)->KeyCtrl != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyCtrl = (byte) (value ? 1 : 0);
            }
        }

        public bool KeyShift
        {
            get
            {
                return ((__Internal*)__Instance)->KeyShift != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyShift = (byte) (value ? 1 : 0);
            }
        }

        public bool KeyAlt
        {
            get
            {
                return ((__Internal*)__Instance)->KeyAlt != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyAlt = (byte) (value ? 1 : 0);
            }
        }

        public bool KeySuper
        {
            get
            {
                return ((__Internal*)__Instance)->KeySuper != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeySuper = (byte) (value ? 1 : 0);
            }
        }

        public bool[] KeysDown
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->KeysDown, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->KeysDown[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float[] NavInputs
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputs, 21);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 21; i++)
                        ((__Internal*)__Instance)->NavInputs[i] = value[i];
                }
            }
        }

        public bool WantCaptureMouse
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureMouse != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureMouse = (byte) (value ? 1 : 0);
            }
        }

        public bool WantCaptureKeyboard
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureKeyboard != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureKeyboard = (byte) (value ? 1 : 0);
            }
        }

        public bool WantTextInput
        {
            get
            {
                return ((__Internal*)__Instance)->WantTextInput != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantTextInput = (byte) (value ? 1 : 0);
            }
        }

        public bool WantSetMousePos
        {
            get
            {
                return ((__Internal*)__Instance)->WantSetMousePos != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantSetMousePos = (byte) (value ? 1 : 0);
            }
        }

        public bool WantSaveIniSettings
        {
            get
            {
                return ((__Internal*)__Instance)->WantSaveIniSettings != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantSaveIniSettings = (byte) (value ? 1 : 0);
            }
        }

        public bool NavActive
        {
            get
            {
                return ((__Internal*)__Instance)->NavActive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavActive = (byte) (value ? 1 : 0);
            }
        }

        public bool NavVisible
        {
            get
            {
                return ((__Internal*)__Instance)->NavVisible != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavVisible = (byte) (value ? 1 : 0);
            }
        }

        public float Framerate
        {
            get
            {
                return ((__Internal*)__Instance)->Framerate;
            }

            set
            {
                ((__Internal*)__Instance)->Framerate = value;
            }
        }

        public int MetricsRenderVertices
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderVertices;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderVertices = value;
            }
        }

        public int MetricsRenderIndices
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderIndices;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderIndices = value;
            }
        }

        public int MetricsRenderWindows
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderWindows;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderWindows = value;
            }
        }

        public int MetricsActiveWindows
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsActiveWindows;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsActiveWindows = value;
            }
        }

        public int MetricsActiveAllocations
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsActiveAllocations;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsActiveAllocations = value;
            }
        }

        public global::DearImguiSharp.ImVec2 MouseDelta
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MouseDelta));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MouseDelta = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public int KeyMods
        {
            get
            {
                return ((__Internal*)__Instance)->KeyMods;
            }

            set
            {
                ((__Internal*)__Instance)->KeyMods = value;
            }
        }

        public global::DearImguiSharp.ImVec2 MousePosPrev
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MousePosPrev));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MousePosPrev = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2[] MouseClickedPos
        {
            get
            {
                global::DearImguiSharp.ImVec2[] __value = null;
                if (((__Internal*)__Instance)->MouseClickedPos != null)
                {
                    __value = new global::DearImguiSharp.ImVec2[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = global::DearImguiSharp.ImVec2.__CreateInstance(*((global::DearImguiSharp.ImVec2.__Internal*)&(((__Internal*)__Instance)->MouseClickedPos[i * sizeof(global::DearImguiSharp.ImVec2.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 5)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 5; i++)
                        *(global::DearImguiSharp.ImVec2.__Internal*) &((__Internal*)__Instance)->MouseClickedPos[i * sizeof(global::DearImguiSharp.ImVec2.__Internal)] = *(global::DearImguiSharp.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public double[] MouseClickedTime
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<double>(((__Internal*)__Instance)->MouseClickedTime, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClickedTime[i] = value[i];
                }
            }
        }

        public bool[] MouseClicked
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseClicked, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClicked[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDoubleClicked
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDoubleClicked, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDoubleClicked[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseReleased
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseReleased, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseReleased[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDownOwned
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDownOwned, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownOwned[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDownWasDoubleClick
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDownWasDoubleClick, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownWasDoubleClick[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float[] MouseDownDuration
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDownDuration, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownDuration[i] = value[i];
                }
            }
        }

        public float[] MouseDownDurationPrev
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDownDurationPrev, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownDurationPrev[i] = value[i];
                }
            }
        }

        public global::DearImguiSharp.ImVec2[] MouseDragMaxDistanceAbs
        {
            get
            {
                global::DearImguiSharp.ImVec2[] __value = null;
                if (((__Internal*)__Instance)->MouseDragMaxDistanceAbs != null)
                {
                    __value = new global::DearImguiSharp.ImVec2[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = global::DearImguiSharp.ImVec2.__CreateInstance(*((global::DearImguiSharp.ImVec2.__Internal*)&(((__Internal*)__Instance)->MouseDragMaxDistanceAbs[i * sizeof(global::DearImguiSharp.ImVec2.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 5)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 5; i++)
                        *(global::DearImguiSharp.ImVec2.__Internal*) &((__Internal*)__Instance)->MouseDragMaxDistanceAbs[i * sizeof(global::DearImguiSharp.ImVec2.__Internal)] = *(global::DearImguiSharp.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public float[] MouseDragMaxDistanceSqr
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDragMaxDistanceSqr, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDragMaxDistanceSqr[i] = value[i];
                }
            }
        }

        public float[] KeysDownDuration
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->KeysDownDuration, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->KeysDownDuration[i] = value[i];
                }
            }
        }

        public float[] KeysDownDurationPrev
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->KeysDownDurationPrev, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->KeysDownDurationPrev[i] = value[i];
                }
            }
        }

        public float[] NavInputsDownDuration
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputsDownDuration, 21);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 21; i++)
                        ((__Internal*)__Instance)->NavInputsDownDuration[i] = value[i];
                }
            }
        }

        public float[] NavInputsDownDurationPrev
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputsDownDurationPrev, 21);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 21; i++)
                        ((__Internal*)__Instance)->NavInputsDownDurationPrev[i] = value[i];
                }
            }
        }

        public float PenPressure
        {
            get
            {
                return ((__Internal*)__Instance)->PenPressure;
            }

            set
            {
                ((__Internal*)__Instance)->PenPressure = value;
            }
        }

        public ushort InputQueueSurrogate
        {
            get
            {
                return ((__Internal*)__Instance)->InputQueueSurrogate;
            }

            set
            {
                ((__Internal*)__Instance)->InputQueueSurrogate = value;
            }
        }

        public global::DearImguiSharp.ImVectorImWchar InputQueueCharacters
        {
            get
            {
                return global::DearImguiSharp.ImVectorImWchar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputQueueCharacters));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputQueueCharacters = *(global::DearImguiSharp.ImVectorImWchar.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiInputTextCallbackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            public int EventFlag;
            public int Flags;
            public __IntPtr UserData;
            public ushort EventChar;
            public int EventKey;
            public __IntPtr Buf;
            public int BufTextLen;
            public int BufSize;
            public byte BufDirty;
            public int CursorPos;
            public int SelectionStart;
            public int SelectionEnd;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiInputTextCallbackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiInputTextCallbackData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiInputTextCallbackData>();

        protected bool __ownsNativeInstance;

        internal static ImGuiInputTextCallbackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputTextCallbackData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputTextCallbackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiInputTextCallbackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiInputTextCallbackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputTextCallbackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputTextCallbackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiInputTextCallbackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputTextCallbackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputTextCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiInputTextCallbackData(global::DearImguiSharp.ImGuiInputTextCallbackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputTextCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiInputTextCallbackData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiInputTextCallbackData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int EventFlag
        {
            get
            {
                return ((__Internal*)__Instance)->EventFlag;
            }

            set
            {
                ((__Internal*)__Instance)->EventFlag = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public ushort EventChar
        {
            get
            {
                return ((__Internal*)__Instance)->EventChar;
            }

            set
            {
                ((__Internal*)__Instance)->EventChar = value;
            }
        }

        public int EventKey
        {
            get
            {
                return ((__Internal*)__Instance)->EventKey;
            }

            set
            {
                ((__Internal*)__Instance)->EventKey = value;
            }
        }

        public sbyte* Buf
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->Buf;
            }

            set
            {
                ((__Internal*)__Instance)->Buf = (__IntPtr) value;
            }
        }

        public int BufTextLen
        {
            get
            {
                return ((__Internal*)__Instance)->BufTextLen;
            }

            set
            {
                ((__Internal*)__Instance)->BufTextLen = value;
            }
        }

        public int BufSize
        {
            get
            {
                return ((__Internal*)__Instance)->BufSize;
            }

            set
            {
                ((__Internal*)__Instance)->BufSize = value;
            }
        }

        public bool BufDirty
        {
            get
            {
                return ((__Internal*)__Instance)->BufDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->BufDirty = (byte) (value ? 1 : 0);
            }
        }

        public int CursorPos
        {
            get
            {
                return ((__Internal*)__Instance)->CursorPos;
            }

            set
            {
                ((__Internal*)__Instance)->CursorPos = value;
            }
        }

        public int SelectionStart
        {
            get
            {
                return ((__Internal*)__Instance)->SelectionStart;
            }

            set
            {
                ((__Internal*)__Instance)->SelectionStart = value;
            }
        }

        public int SelectionEnd
        {
            get
            {
                return ((__Internal*)__Instance)->SelectionEnd;
            }

            set
            {
                ((__Internal*)__Instance)->SelectionEnd = value;
            }
        }
    }

    public unsafe partial class ImGuiSizeCallbackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public __IntPtr UserData;
            public global::DearImguiSharp.ImVec2.__Internal Pos;
            public global::DearImguiSharp.ImVec2.__Internal CurrentSize;
            public global::DearImguiSharp.ImVec2.__Internal DesiredSize;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiSizeCallbackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiSizeCallbackData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiSizeCallbackData>();

        protected bool __ownsNativeInstance;

        internal static ImGuiSizeCallbackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiSizeCallbackData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiSizeCallbackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiSizeCallbackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiSizeCallbackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiSizeCallbackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiSizeCallbackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiSizeCallbackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiSizeCallbackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiSizeCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiSizeCallbackData(global::DearImguiSharp.ImGuiSizeCallbackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiSizeCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiSizeCallbackData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiSizeCallbackData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.ImVec2 Pos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 CurrentSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CurrentSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CurrentSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 DesiredSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DesiredSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DesiredSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiPayload : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            public __IntPtr Data;
            public int DataSize;
            public uint SourceId;
            public uint SourceParentId;
            public int DataFrameCount;
            public fixed sbyte DataType[33];
            public byte Preview;
            public byte Delivery;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiPayload@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiPayload> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiPayload>();

        protected bool __ownsNativeInstance;

        internal static ImGuiPayload __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPayload(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPayload __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiPayload)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiPayload __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPayload(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPayload(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiPayload(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPayload()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPayload.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiPayload(global::DearImguiSharp.ImGuiPayload _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPayload.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiPayload.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiPayload.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Data
        {
            get
            {
                return ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }

        public int DataSize
        {
            get
            {
                return ((__Internal*)__Instance)->DataSize;
            }

            set
            {
                ((__Internal*)__Instance)->DataSize = value;
            }
        }

        public uint SourceId
        {
            get
            {
                return ((__Internal*)__Instance)->SourceId;
            }

            set
            {
                ((__Internal*)__Instance)->SourceId = value;
            }
        }

        public uint SourceParentId
        {
            get
            {
                return ((__Internal*)__Instance)->SourceParentId;
            }

            set
            {
                ((__Internal*)__Instance)->SourceParentId = value;
            }
        }

        public int DataFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->DataFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->DataFrameCount = value;
            }
        }

        public sbyte[] DataType
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->DataType, 33);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 33; i++)
                        ((__Internal*)__Instance)->DataType[i] = value[i];
                }
            }
        }

        public bool Preview
        {
            get
            {
                return ((__Internal*)__Instance)->Preview != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Preview = (byte) (value ? 1 : 0);
            }
        }

        public bool Delivery
        {
            get
            {
                return ((__Internal*)__Instance)->Delivery != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Delivery = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiTableColumnSortSpecs : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            public uint ColumnUserID;
            public short ColumnIndex;
            public short SortOrder;
            public int SortDirection;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiTableColumnSortSpecs@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiTableColumnSortSpecs> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiTableColumnSortSpecs>();

        protected bool __ownsNativeInstance;

        internal static ImGuiTableColumnSortSpecs __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSortSpecs(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableColumnSortSpecs __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiTableColumnSortSpecs)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiTableColumnSortSpecs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSortSpecs(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableColumnSortSpecs(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTableColumnSortSpecs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableColumnSortSpecs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTableColumnSortSpecs(global::DearImguiSharp.ImGuiTableColumnSortSpecs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiTableColumnSortSpecs.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTableColumnSortSpecs.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ColumnUserID
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnUserID;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnUserID = value;
            }
        }

        public short ColumnIndex
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnIndex;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnIndex = value;
            }
        }

        public short SortOrder
        {
            get
            {
                return ((__Internal*)__Instance)->SortOrder;
            }

            set
            {
                ((__Internal*)__Instance)->SortOrder = value;
            }
        }

        public int SortDirection
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirection;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirection = value;
            }
        }
    }

    public unsafe partial class ImGuiTableSortSpecs : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr Specs;
            public int SpecsCount;
            public byte SpecsDirty;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiTableSortSpecs@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiTableSortSpecs> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiTableSortSpecs>();

        protected bool __ownsNativeInstance;

        internal static ImGuiTableSortSpecs __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableSortSpecs(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableSortSpecs __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiTableSortSpecs)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiTableSortSpecs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableSortSpecs(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableSortSpecs(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTableSortSpecs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableSortSpecs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableSortSpecs.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTableSortSpecs(global::DearImguiSharp.ImGuiTableSortSpecs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableSortSpecs.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiTableSortSpecs.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTableSortSpecs.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImGuiTableColumnSortSpecs Specs
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTableColumnSortSpecs.__GetOrCreateInstance(((__Internal*)__Instance)->Specs, false);
                return __result0;
            }
        }

        public int SpecsCount
        {
            get
            {
                return ((__Internal*)__Instance)->SpecsCount;
            }

            set
            {
                ((__Internal*)__Instance)->SpecsCount = value;
            }
        }

        public bool SpecsDirty
        {
            get
            {
                return ((__Internal*)__Instance)->SpecsDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SpecsDirty = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiOnceUponAFrame : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            public int RefFrame;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiOnceUponAFrame@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiOnceUponAFrame> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiOnceUponAFrame>();

        protected bool __ownsNativeInstance;

        internal static ImGuiOnceUponAFrame __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiOnceUponAFrame(native.ToPointer(), skipVTables);
        }

        internal static ImGuiOnceUponAFrame __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiOnceUponAFrame)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiOnceUponAFrame __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiOnceUponAFrame(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiOnceUponAFrame(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiOnceUponAFrame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiOnceUponAFrame()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiOnceUponAFrame.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiOnceUponAFrame(global::DearImguiSharp.ImGuiOnceUponAFrame _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiOnceUponAFrame.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiOnceUponAFrame.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiOnceUponAFrame.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int RefFrame
        {
            get
            {
                return ((__Internal*)__Instance)->RefFrame;
            }

            set
            {
                ((__Internal*)__Instance)->RefFrame = value;
            }
        }
    }

    public unsafe partial class ImGuiTextRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr b;
            public __IntPtr e;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiTextRange@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiTextRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiTextRange>();

        protected bool __ownsNativeInstance;

        internal static ImGuiTextRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTextRange(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTextRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiTextRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiTextRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTextRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTextRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTextRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTextRange(global::DearImguiSharp.ImGuiTextRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiTextRange.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTextRange.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string B
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->b);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->b = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string E
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->e);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->e = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class ImGuiTextFilter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 280)]
        public partial struct __Internal
        {
            public fixed sbyte InputBuf[256];
            public global::DearImguiSharp.ImVectorImGuiTextRange.__Internal Filters;
            public int CountGrep;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiTextFilter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiTextFilter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiTextFilter>();

        protected bool __ownsNativeInstance;

        internal static ImGuiTextFilter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTextFilter(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTextFilter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiTextFilter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiTextFilter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTextFilter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextFilter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTextFilter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTextFilter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextFilter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTextFilter(global::DearImguiSharp.ImGuiTextFilter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextFilter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiTextFilter.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTextFilter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] InputBuf
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->InputBuf, 256);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 256; i++)
                        ((__Internal*)__Instance)->InputBuf[i] = value[i];
                }
            }
        }

        public global::DearImguiSharp.ImVectorImGuiTextRange Filters
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiTextRange.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Filters));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Filters = *(global::DearImguiSharp.ImVectorImGuiTextRange.__Internal*) value.__Instance;
            }
        }

        public int CountGrep
        {
            get
            {
                return ((__Internal*)__Instance)->CountGrep;
            }

            set
            {
                ((__Internal*)__Instance)->CountGrep = value;
            }
        }
    }

    public unsafe partial class ImGuiTextBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVector_char.__Internal Buf;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiTextBuffer@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextBuffer_appendf", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Appendf(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiTextBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiTextBuffer>();

        protected bool __ownsNativeInstance;

        internal static ImGuiTextBuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTextBuffer(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTextBuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiTextBuffer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiTextBuffer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTextBuffer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextBuffer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTextBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTextBuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiTextBuffer(global::DearImguiSharp.ImGuiTextBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiTextBuffer.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTextBuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Appendf(string fmt)
        {
            __Internal.Appendf(__Instance, fmt);
        }

        public global::DearImguiSharp.ImVector_char Buf
        {
            get
            {
                return global::DearImguiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Buf = *(global::DearImguiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStoragePair : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public uint key;

            [FieldOffset(8)]
            public int val_i;

            [FieldOffset(8)]
            public float val_f;

            [FieldOffset(8)]
            public __IntPtr val_p;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiStoragePair@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiStoragePair> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiStoragePair>();

        protected bool __ownsNativeInstance;

        internal static ImGuiStoragePair __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStoragePair(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStoragePair __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiStoragePair)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiStoragePair __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStoragePair(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStoragePair(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiStoragePair(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStoragePair()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiStoragePair(global::DearImguiSharp.ImGuiStoragePair _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiStoragePair.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiStoragePair.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Key
        {
            get
            {
                return ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = value;
            }
        }

        public int ValI
        {
            get
            {
                return ((__Internal*)__Instance)->val_i;
            }

            set
            {
                ((__Internal*)__Instance)->val_i = value;
            }
        }

        public float ValF
        {
            get
            {
                return ((__Internal*)__Instance)->val_f;
            }

            set
            {
                ((__Internal*)__Instance)->val_f = value;
            }
        }

        public __IntPtr ValP
        {
            get
            {
                return ((__Internal*)__Instance)->val_p;
            }

            set
            {
                ((__Internal*)__Instance)->val_p = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImGuiStorage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiStorage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiStorage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiStorage>();

        protected bool __ownsNativeInstance;

        internal static ImGuiStorage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStorage(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStorage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiStorage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiStorage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStorage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStorage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiStorage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStorage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStorage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiStorage(global::DearImguiSharp.ImGuiStorage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStorage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiStorage.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiStorage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImGuiStoragePair Data
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiStoragePair.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Data));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Data = *(global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiListClipper : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            public int DisplayStart;
            public int DisplayEnd;
            public int ItemsCount;
            public int StepNo;
            public int ItemsFrozen;
            public float ItemsHeight;
            public float StartPosY;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiListClipper@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiListClipper> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiListClipper>();

        protected bool __ownsNativeInstance;

        internal static ImGuiListClipper __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiListClipper(native.ToPointer(), skipVTables);
        }

        internal static ImGuiListClipper __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiListClipper)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiListClipper __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiListClipper(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiListClipper(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiListClipper(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiListClipper()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiListClipper.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiListClipper(global::DearImguiSharp.ImGuiListClipper _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiListClipper.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiListClipper.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiListClipper.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int DisplayStart
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayStart;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayStart = value;
            }
        }

        public int DisplayEnd
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayEnd;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayEnd = value;
            }
        }

        public int ItemsCount
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsCount;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsCount = value;
            }
        }

        public int StepNo
        {
            get
            {
                return ((__Internal*)__Instance)->StepNo;
            }

            set
            {
                ((__Internal*)__Instance)->StepNo = value;
            }
        }

        public int ItemsFrozen
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsFrozen;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsFrozen = value;
            }
        }

        public float ItemsHeight
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsHeight;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsHeight = value;
            }
        }

        public float StartPosY
        {
            get
            {
                return ((__Internal*)__Instance)->StartPosY;
            }

            set
            {
                ((__Internal*)__Instance)->StartPosY = value;
            }
        }
    }

    public unsafe partial class ImColor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec4.__Internal Value;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImColor@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImColor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImColor>();

        protected bool __ownsNativeInstance;

        internal static ImColor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImColor(native.ToPointer(), skipVTables);
        }

        internal static ImColor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImColor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImColor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImColor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImColor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImColor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImColor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImColor(global::DearImguiSharp.ImColor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImColor.__Internal*) __Instance) = *((global::DearImguiSharp.ImColor.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec4 Value
        {
            get
            {
                return global::DearImguiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Value));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Value = *(global::DearImguiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawCmd : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec4.__Internal ClipRect;
            public __IntPtr TextureId;
            public uint VtxOffset;
            public uint IdxOffset;
            public uint ElemCount;
            public __IntPtr UserCallback;
            public __IntPtr UserCallbackData;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImDrawCmd@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawCmd> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawCmd>();

        protected bool __ownsNativeInstance;

        internal static ImDrawCmd __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawCmd(native.ToPointer(), skipVTables);
        }

        internal static ImDrawCmd __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawCmd)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawCmd __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawCmd(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawCmd(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawCmd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawCmd()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawCmd(global::DearImguiSharp.ImDrawCmd _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImDrawCmd.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawCmd.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec4 ClipRect
        {
            get
            {
                return global::DearImguiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::DearImguiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }

        public __IntPtr TextureId
        {
            get
            {
                return ((__Internal*)__Instance)->TextureId;
            }

            set
            {
                ((__Internal*)__Instance)->TextureId = (__IntPtr) value;
            }
        }

        public uint VtxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->VtxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->VtxOffset = value;
            }
        }

        public uint IdxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->IdxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->IdxOffset = value;
            }
        }

        public uint ElemCount
        {
            get
            {
                return ((__Internal*)__Instance)->ElemCount;
            }

            set
            {
                ((__Internal*)__Instance)->ElemCount = value;
            }
        }

        public global::DearImguiSharp.ImDrawCallback UserCallback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->UserCallback;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.ImDrawCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.ImDrawCallback));
            }

            set
            {
                ((__Internal*)__Instance)->UserCallback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserCallbackData
        {
            get
            {
                return ((__Internal*)__Instance)->UserCallbackData;
            }

            set
            {
                ((__Internal*)__Instance)->UserCallbackData = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImDrawVert : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec2.__Internal pos;
            public global::DearImguiSharp.ImVec2.__Internal uv;
            public uint col;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImDrawVert@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawVert> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawVert>();

        protected bool __ownsNativeInstance;

        internal static ImDrawVert __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawVert(native.ToPointer(), skipVTables);
        }

        internal static ImDrawVert __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawVert)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawVert __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawVert(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawVert(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawVert(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawVert()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawVert.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawVert(global::DearImguiSharp.ImDrawVert _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawVert.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImDrawVert.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawVert.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec2 Pos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 Uv
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uv));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uv = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public uint Col
        {
            get
            {
                return ((__Internal*)__Instance)->col;
            }

            set
            {
                ((__Internal*)__Instance)->col = value;
            }
        }
    }

    public unsafe partial class ImDrawCmdHeader : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec4.__Internal ClipRect;
            public __IntPtr TextureId;
            public uint VtxOffset;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImDrawCmdHeader@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawCmdHeader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawCmdHeader>();

        protected bool __ownsNativeInstance;

        internal static ImDrawCmdHeader __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawCmdHeader(native.ToPointer(), skipVTables);
        }

        internal static ImDrawCmdHeader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawCmdHeader)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawCmdHeader __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawCmdHeader(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawCmdHeader(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawCmdHeader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawCmdHeader()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawCmdHeader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawCmdHeader(global::DearImguiSharp.ImDrawCmdHeader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawCmdHeader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImDrawCmdHeader.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawCmdHeader.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec4 ClipRect
        {
            get
            {
                return global::DearImguiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::DearImguiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }

        public __IntPtr TextureId
        {
            get
            {
                return ((__Internal*)__Instance)->TextureId;
            }

            set
            {
                ((__Internal*)__Instance)->TextureId = (__IntPtr) value;
            }
        }

        public uint VtxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->VtxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->VtxOffset = value;
            }
        }
    }

    public unsafe partial class ImDrawChannel : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImDrawCmd.__Internal _CmdBuffer;
            public global::DearImguiSharp.ImVectorImDrawIdx.__Internal _IdxBuffer;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImDrawChannel@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawChannel> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawChannel>();

        protected bool __ownsNativeInstance;

        internal static ImDrawChannel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawChannel(native.ToPointer(), skipVTables);
        }

        internal static ImDrawChannel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawChannel)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawChannel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawChannel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawChannel(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawChannel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawChannel()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawChannel(global::DearImguiSharp.ImDrawChannel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImDrawChannel.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawChannel.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImDrawCmd CmdBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawCmd.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_CmdBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_CmdBuffer = *(global::DearImguiSharp.ImVectorImDrawCmd.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImDrawIdx IdxBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawIdx.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_IdxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_IdxBuffer = *(global::DearImguiSharp.ImVectorImDrawIdx.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawListSplitter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            public int _Current;
            public int _Count;
            public global::DearImguiSharp.ImVectorImDrawChannel.__Internal _Channels;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImDrawListSplitter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawListSplitter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawListSplitter>();

        protected bool __ownsNativeInstance;

        internal static ImDrawListSplitter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawListSplitter(native.ToPointer(), skipVTables);
        }

        internal static ImDrawListSplitter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawListSplitter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawListSplitter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawListSplitter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawListSplitter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawListSplitter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawListSplitter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawListSplitter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawListSplitter(global::DearImguiSharp.ImDrawListSplitter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawListSplitter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImDrawListSplitter.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawListSplitter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Current
        {
            get
            {
                return ((__Internal*)__Instance)->_Current;
            }

            set
            {
                ((__Internal*)__Instance)->_Current = value;
            }
        }

        public int Count
        {
            get
            {
                return ((__Internal*)__Instance)->_Count;
            }

            set
            {
                ((__Internal*)__Instance)->_Count = value;
            }
        }

        public global::DearImguiSharp.ImVectorImDrawChannel Channels
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawChannel.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_Channels));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_Channels = *(global::DearImguiSharp.ImVectorImDrawChannel.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawList : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 200)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImDrawCmd.__Internal CmdBuffer;
            public global::DearImguiSharp.ImVectorImDrawIdx.__Internal IdxBuffer;
            public global::DearImguiSharp.ImVectorImDrawVert.__Internal VtxBuffer;
            public int Flags;
            public uint _VtxCurrentIdx;
            public __IntPtr _Data;
            public __IntPtr _OwnerName;
            public __IntPtr _VtxWritePtr;
            public __IntPtr _IdxWritePtr;
            public global::DearImguiSharp.ImVectorImVec4.__Internal _ClipRectStack;
            public global::DearImguiSharp.ImVectorImTextureID.__Internal _TextureIdStack;
            public global::DearImguiSharp.ImVectorImVec2.__Internal _Path;
            public global::DearImguiSharp.ImDrawCmdHeader.__Internal _CmdHeader;
            public global::DearImguiSharp.ImDrawListSplitter.__Internal _Splitter;
            public float _FringeScale;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImDrawList@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawList> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawList>();

        protected bool __ownsNativeInstance;

        internal static ImDrawList __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawList(native.ToPointer(), skipVTables);
        }

        internal static ImDrawList __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawList)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawList __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawList(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawList(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawList(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawList()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawList.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawList(global::DearImguiSharp.ImDrawList _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawList.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImDrawList.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawList.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImDrawCmd CmdBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawCmd.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CmdBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CmdBuffer = *(global::DearImguiSharp.ImVectorImDrawCmd.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImDrawIdx IdxBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawIdx.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IdxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IdxBuffer = *(global::DearImguiSharp.ImVectorImDrawIdx.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImDrawVert VtxBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawVert.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->VtxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->VtxBuffer = *(global::DearImguiSharp.ImVectorImDrawVert.__Internal*) value.__Instance;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public uint VtxCurrentIdx
        {
            get
            {
                return ((__Internal*)__Instance)->_VtxCurrentIdx;
            }

            set
            {
                ((__Internal*)__Instance)->_VtxCurrentIdx = value;
            }
        }

        public global::DearImguiSharp.ImDrawListSharedData Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawListSharedData.__GetOrCreateInstance(((__Internal*)__Instance)->_Data, false);
                return __result0;
            }
        }

        public string OwnerName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->_OwnerName);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->_OwnerName = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public global::DearImguiSharp.ImDrawVert VtxWritePtr
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawVert.__GetOrCreateInstance(((__Internal*)__Instance)->_VtxWritePtr, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_VtxWritePtr = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public ushort* IdxWritePtr
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->_IdxWritePtr;
            }

            set
            {
                ((__Internal*)__Instance)->_IdxWritePtr = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.ImVectorImVec4 ClipRectStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_ClipRectStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_ClipRectStack = *(global::DearImguiSharp.ImVectorImVec4.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImTextureID TextureIdStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImTextureID.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_TextureIdStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_TextureIdStack = *(global::DearImguiSharp.ImVectorImTextureID.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImVec2 Path
        {
            get
            {
                return global::DearImguiSharp.ImVectorImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_Path));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_Path = *(global::DearImguiSharp.ImVectorImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImDrawCmdHeader CmdHeader
        {
            get
            {
                return global::DearImguiSharp.ImDrawCmdHeader.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_CmdHeader));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_CmdHeader = *(global::DearImguiSharp.ImDrawCmdHeader.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImDrawListSplitter Splitter
        {
            get
            {
                return global::DearImguiSharp.ImDrawListSplitter.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_Splitter));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_Splitter = *(global::DearImguiSharp.ImDrawListSplitter.__Internal*) value.__Instance;
            }
        }

        public float FringeScale
        {
            get
            {
                return ((__Internal*)__Instance)->_FringeScale;
            }

            set
            {
                ((__Internal*)__Instance)->_FringeScale = value;
            }
        }
    }

    public unsafe partial class ImDrawData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public byte Valid;
            public int CmdListsCount;
            public int TotalIdxCount;
            public int TotalVtxCount;
            public __IntPtr CmdLists;
            public global::DearImguiSharp.ImVec2.__Internal DisplayPos;
            public global::DearImguiSharp.ImVec2.__Internal DisplaySize;
            public global::DearImguiSharp.ImVec2.__Internal FramebufferScale;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImDrawData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImDrawData>();

        protected bool __ownsNativeInstance;

        internal static ImDrawData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawData(native.ToPointer(), skipVTables);
        }

        internal static ImDrawData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImDrawData(global::DearImguiSharp.ImDrawData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImDrawData.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Valid
        {
            get
            {
                return ((__Internal*)__Instance)->Valid != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Valid = (byte) (value ? 1 : 0);
            }
        }

        public int CmdListsCount
        {
            get
            {
                return ((__Internal*)__Instance)->CmdListsCount;
            }

            set
            {
                ((__Internal*)__Instance)->CmdListsCount = value;
            }
        }

        public int TotalIdxCount
        {
            get
            {
                return ((__Internal*)__Instance)->TotalIdxCount;
            }

            set
            {
                ((__Internal*)__Instance)->TotalIdxCount = value;
            }
        }

        public int TotalVtxCount
        {
            get
            {
                return ((__Internal*)__Instance)->TotalVtxCount;
            }

            set
            {
                ((__Internal*)__Instance)->TotalVtxCount = value;
            }
        }

        public global::DearImguiSharp.ImDrawList CmdLists
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(((__Internal*)__Instance)->CmdLists, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->CmdLists = new __IntPtr(&__value);
            }
        }

        public global::DearImguiSharp.ImVec2 DisplayPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 DisplaySize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 FramebufferScale
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FramebufferScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FramebufferScale = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 136)]
        public partial struct __Internal
        {
            public __IntPtr FontData;
            public int FontDataSize;
            public byte FontDataOwnedByAtlas;
            public int FontNo;
            public float SizePixels;
            public int OversampleH;
            public int OversampleV;
            public byte PixelSnapH;
            public global::DearImguiSharp.ImVec2.__Internal GlyphExtraSpacing;
            public global::DearImguiSharp.ImVec2.__Internal GlyphOffset;
            public __IntPtr GlyphRanges;
            public float GlyphMinAdvanceX;
            public float GlyphMaxAdvanceX;
            public byte MergeMode;
            public uint FontBuilderFlags;
            public float RasterizerMultiply;
            public ushort EllipsisChar;
            public fixed sbyte Name[40];
            public __IntPtr DstFont;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImFontConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontConfig> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontConfig>();

        protected bool __ownsNativeInstance;

        internal static ImFontConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontConfig(native.ToPointer(), skipVTables);
        }

        internal static ImFontConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontConfig(global::DearImguiSharp.ImFontConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImFontConfig.__Internal*) __Instance) = *((global::DearImguiSharp.ImFontConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr FontData
        {
            get
            {
                return ((__Internal*)__Instance)->FontData;
            }

            set
            {
                ((__Internal*)__Instance)->FontData = (__IntPtr) value;
            }
        }

        public int FontDataSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontDataSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontDataSize = value;
            }
        }

        public bool FontDataOwnedByAtlas
        {
            get
            {
                return ((__Internal*)__Instance)->FontDataOwnedByAtlas != 0;
            }

            set
            {
                ((__Internal*)__Instance)->FontDataOwnedByAtlas = (byte) (value ? 1 : 0);
            }
        }

        public int FontNo
        {
            get
            {
                return ((__Internal*)__Instance)->FontNo;
            }

            set
            {
                ((__Internal*)__Instance)->FontNo = value;
            }
        }

        public float SizePixels
        {
            get
            {
                return ((__Internal*)__Instance)->SizePixels;
            }

            set
            {
                ((__Internal*)__Instance)->SizePixels = value;
            }
        }

        public int OversampleH
        {
            get
            {
                return ((__Internal*)__Instance)->OversampleH;
            }

            set
            {
                ((__Internal*)__Instance)->OversampleH = value;
            }
        }

        public int OversampleV
        {
            get
            {
                return ((__Internal*)__Instance)->OversampleV;
            }

            set
            {
                ((__Internal*)__Instance)->OversampleV = value;
            }
        }

        public bool PixelSnapH
        {
            get
            {
                return ((__Internal*)__Instance)->PixelSnapH != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PixelSnapH = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImVec2 GlyphExtraSpacing
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphExtraSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphExtraSpacing = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 GlyphOffset
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphOffset = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public ushort* GlyphRanges
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->GlyphRanges;
            }
        }

        public float GlyphMinAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphMinAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphMinAdvanceX = value;
            }
        }

        public float GlyphMaxAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphMaxAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphMaxAdvanceX = value;
            }
        }

        public bool MergeMode
        {
            get
            {
                return ((__Internal*)__Instance)->MergeMode != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MergeMode = (byte) (value ? 1 : 0);
            }
        }

        public uint FontBuilderFlags
        {
            get
            {
                return ((__Internal*)__Instance)->FontBuilderFlags;
            }

            set
            {
                ((__Internal*)__Instance)->FontBuilderFlags = value;
            }
        }

        public float RasterizerMultiply
        {
            get
            {
                return ((__Internal*)__Instance)->RasterizerMultiply;
            }

            set
            {
                ((__Internal*)__Instance)->RasterizerMultiply = value;
            }
        }

        public ushort EllipsisChar
        {
            get
            {
                return ((__Internal*)__Instance)->EllipsisChar;
            }

            set
            {
                ((__Internal*)__Instance)->EllipsisChar = value;
            }
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 40);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 40; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public global::DearImguiSharp.ImFont DstFont
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->DstFont, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DstFont = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontGlyph : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public uint Colored;

            [FieldOffset(0)]
            public uint Visible;

            [FieldOffset(0)]
            public uint Codepoint;

            [FieldOffset(4)]
            public float AdvanceX;

            [FieldOffset(8)]
            public float X0;

            [FieldOffset(12)]
            public float Y0;

            [FieldOffset(16)]
            public float X1;

            [FieldOffset(20)]
            public float Y1;

            [FieldOffset(24)]
            public float U0;

            [FieldOffset(28)]
            public float V0;

            [FieldOffset(32)]
            public float U1;

            [FieldOffset(36)]
            public float V1;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImFontGlyph@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontGlyph> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontGlyph>();

        protected bool __ownsNativeInstance;

        internal static ImFontGlyph __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontGlyph(native.ToPointer(), skipVTables);
        }

        internal static ImFontGlyph __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontGlyph)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontGlyph __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontGlyph(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontGlyph(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontGlyph(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontGlyph()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontGlyph(global::DearImguiSharp.ImFontGlyph _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImFontGlyph.__Internal*) __Instance) = *((global::DearImguiSharp.ImFontGlyph.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Colored
        {
            get
            {
                return ((__Internal*)__Instance)->Colored;
            }

            set
            {
                ((__Internal*)__Instance)->Colored = value;
            }
        }

        public uint Visible
        {
            get
            {
                return ((__Internal*)__Instance)->Visible;
            }

            set
            {
                ((__Internal*)__Instance)->Visible = value;
            }
        }

        public uint Codepoint
        {
            get
            {
                return ((__Internal*)__Instance)->Codepoint;
            }

            set
            {
                ((__Internal*)__Instance)->Codepoint = value;
            }
        }

        public float AdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->AdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->AdvanceX = value;
            }
        }

        public float X0
        {
            get
            {
                return ((__Internal*)__Instance)->X0;
            }

            set
            {
                ((__Internal*)__Instance)->X0 = value;
            }
        }

        public float Y0
        {
            get
            {
                return ((__Internal*)__Instance)->Y0;
            }

            set
            {
                ((__Internal*)__Instance)->Y0 = value;
            }
        }

        public float X1
        {
            get
            {
                return ((__Internal*)__Instance)->X1;
            }

            set
            {
                ((__Internal*)__Instance)->X1 = value;
            }
        }

        public float Y1
        {
            get
            {
                return ((__Internal*)__Instance)->Y1;
            }

            set
            {
                ((__Internal*)__Instance)->Y1 = value;
            }
        }

        public float U0
        {
            get
            {
                return ((__Internal*)__Instance)->U0;
            }

            set
            {
                ((__Internal*)__Instance)->U0 = value;
            }
        }

        public float V0
        {
            get
            {
                return ((__Internal*)__Instance)->V0;
            }

            set
            {
                ((__Internal*)__Instance)->V0 = value;
            }
        }

        public float U1
        {
            get
            {
                return ((__Internal*)__Instance)->U1;
            }

            set
            {
                ((__Internal*)__Instance)->U1 = value;
            }
        }

        public float V1
        {
            get
            {
                return ((__Internal*)__Instance)->V1;
            }

            set
            {
                ((__Internal*)__Instance)->V1 = value;
            }
        }
    }

    public unsafe partial class ImFontGlyphRangesBuilder : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImU32.__Internal UsedChars;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImFontGlyphRangesBuilder@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontGlyphRangesBuilder> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontGlyphRangesBuilder>();

        protected bool __ownsNativeInstance;

        internal static ImFontGlyphRangesBuilder __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontGlyphRangesBuilder(native.ToPointer(), skipVTables);
        }

        internal static ImFontGlyphRangesBuilder __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontGlyphRangesBuilder)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontGlyphRangesBuilder __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontGlyphRangesBuilder(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontGlyphRangesBuilder(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontGlyphRangesBuilder(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontGlyphRangesBuilder()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontGlyphRangesBuilder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontGlyphRangesBuilder(global::DearImguiSharp.ImFontGlyphRangesBuilder _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontGlyphRangesBuilder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImFontGlyphRangesBuilder.__Internal*) __Instance) = *((global::DearImguiSharp.ImFontGlyphRangesBuilder.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImU32 UsedChars
        {
            get
            {
                return global::DearImguiSharp.ImVectorImU32.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->UsedChars));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->UsedChars = *(global::DearImguiSharp.ImVectorImU32.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontAtlasCustomRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public ushort Width;
            public ushort Height;
            public ushort X;
            public ushort Y;
            public uint GlyphID;
            public float GlyphAdvanceX;
            public global::DearImguiSharp.ImVec2.__Internal GlyphOffset;
            public __IntPtr Font;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImFontAtlasCustomRect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontAtlasCustomRect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontAtlasCustomRect>();

        protected bool __ownsNativeInstance;

        internal static ImFontAtlasCustomRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontAtlasCustomRect(native.ToPointer(), skipVTables);
        }

        internal static ImFontAtlasCustomRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontAtlasCustomRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontAtlasCustomRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontAtlasCustomRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontAtlasCustomRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontAtlasCustomRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontAtlasCustomRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontAtlasCustomRect(global::DearImguiSharp.ImFontAtlasCustomRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImFontAtlasCustomRect.__Internal*) __Instance) = *((global::DearImguiSharp.ImFontAtlasCustomRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Width
        {
            get
            {
                return ((__Internal*)__Instance)->Width;
            }

            set
            {
                ((__Internal*)__Instance)->Width = value;
            }
        }

        public ushort Height
        {
            get
            {
                return ((__Internal*)__Instance)->Height;
            }

            set
            {
                ((__Internal*)__Instance)->Height = value;
            }
        }

        public ushort X
        {
            get
            {
                return ((__Internal*)__Instance)->X;
            }

            set
            {
                ((__Internal*)__Instance)->X = value;
            }
        }

        public ushort Y
        {
            get
            {
                return ((__Internal*)__Instance)->Y;
            }

            set
            {
                ((__Internal*)__Instance)->Y = value;
            }
        }

        public uint GlyphID
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphID;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphID = value;
            }
        }

        public float GlyphAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphAdvanceX = value;
            }
        }

        public global::DearImguiSharp.ImVec2 GlyphOffset
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphOffset = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImFont Font
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->Font, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Font = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontAtlas : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1160)]
        public partial struct __Internal
        {
            public byte Locked;
            public int Flags;
            public __IntPtr TexID;
            public int TexDesiredWidth;
            public int TexGlyphPadding;
            public __IntPtr TexPixelsAlpha8;
            public __IntPtr TexPixelsRGBA32;
            public int TexWidth;
            public int TexHeight;
            public global::DearImguiSharp.ImVec2.__Internal TexUvScale;
            public global::DearImguiSharp.ImVec2.__Internal TexUvWhitePixel;
            public global::DearImguiSharp.ImVectorImFontPtr.__Internal Fonts;
            public global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal CustomRects;
            public global::DearImguiSharp.ImVectorImFontConfig.__Internal ConfigData;
            public fixed byte TexUvLines[1024];
            public __IntPtr FontBuilderIO;
            public uint FontBuilderFlags;
            public int PackIdMouseCursors;
            public int PackIdLines;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImFontAtlas@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontAtlas> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFontAtlas>();

        protected bool __ownsNativeInstance;

        internal static ImFontAtlas __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontAtlas(native.ToPointer(), skipVTables);
        }

        internal static ImFontAtlas __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontAtlas)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontAtlas __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontAtlas(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontAtlas(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontAtlas(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontAtlas()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontAtlas.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontAtlas(global::DearImguiSharp.ImFontAtlas _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontAtlas.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImFontAtlas.__Internal*) __Instance) = *((global::DearImguiSharp.ImFontAtlas.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Locked
        {
            get
            {
                return ((__Internal*)__Instance)->Locked != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Locked = (byte) (value ? 1 : 0);
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public __IntPtr TexID
        {
            get
            {
                return ((__Internal*)__Instance)->TexID;
            }

            set
            {
                ((__Internal*)__Instance)->TexID = (__IntPtr) value;
            }
        }

        public int TexDesiredWidth
        {
            get
            {
                return ((__Internal*)__Instance)->TexDesiredWidth;
            }

            set
            {
                ((__Internal*)__Instance)->TexDesiredWidth = value;
            }
        }

        public int TexGlyphPadding
        {
            get
            {
                return ((__Internal*)__Instance)->TexGlyphPadding;
            }

            set
            {
                ((__Internal*)__Instance)->TexGlyphPadding = value;
            }
        }

        public byte* TexPixelsAlpha8
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->TexPixelsAlpha8;
            }

            set
            {
                ((__Internal*)__Instance)->TexPixelsAlpha8 = (__IntPtr) value;
            }
        }

        public uint* TexPixelsRGBA32
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->TexPixelsRGBA32;
            }

            set
            {
                ((__Internal*)__Instance)->TexPixelsRGBA32 = (__IntPtr) value;
            }
        }

        public int TexWidth
        {
            get
            {
                return ((__Internal*)__Instance)->TexWidth;
            }

            set
            {
                ((__Internal*)__Instance)->TexWidth = value;
            }
        }

        public int TexHeight
        {
            get
            {
                return ((__Internal*)__Instance)->TexHeight;
            }

            set
            {
                ((__Internal*)__Instance)->TexHeight = value;
            }
        }

        public global::DearImguiSharp.ImVec2 TexUvScale
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TexUvScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TexUvScale = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 TexUvWhitePixel
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TexUvWhitePixel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TexUvWhitePixel = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImFontPtr Fonts
        {
            get
            {
                return global::DearImguiSharp.ImVectorImFontPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Fonts));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Fonts = *(global::DearImguiSharp.ImVectorImFontPtr.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImFontAtlasCustomRect CustomRects
        {
            get
            {
                return global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CustomRects));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CustomRects = *(global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImFontConfig ConfigData
        {
            get
            {
                return global::DearImguiSharp.ImVectorImFontConfig.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ConfigData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ConfigData = *(global::DearImguiSharp.ImVectorImFontConfig.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec4[] TexUvLines
        {
            get
            {
                global::DearImguiSharp.ImVec4[] __value = null;
                if (((__Internal*)__Instance)->TexUvLines != null)
                {
                    __value = new global::DearImguiSharp.ImVec4[64];
                    for (int i = 0; i < 64; i++)
                        __value[i] = global::DearImguiSharp.ImVec4.__CreateInstance(*((global::DearImguiSharp.ImVec4.__Internal*)&(((__Internal*)__Instance)->TexUvLines[i * sizeof(global::DearImguiSharp.ImVec4.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 64)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 64; i++)
                        *(global::DearImguiSharp.ImVec4.__Internal*) &((__Internal*)__Instance)->TexUvLines[i * sizeof(global::DearImguiSharp.ImVec4.__Internal)] = *(global::DearImguiSharp.ImVec4.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::DearImguiSharp.ImFontBuilderIO FontBuilderIO
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontBuilderIO.__GetOrCreateInstance(((__Internal*)__Instance)->FontBuilderIO, false);
                return __result0;
            }
        }

        public uint FontBuilderFlags
        {
            get
            {
                return ((__Internal*)__Instance)->FontBuilderFlags;
            }

            set
            {
                ((__Internal*)__Instance)->FontBuilderFlags = value;
            }
        }

        public int PackIdMouseCursors
        {
            get
            {
                return ((__Internal*)__Instance)->PackIdMouseCursors;
            }

            set
            {
                ((__Internal*)__Instance)->PackIdMouseCursors = value;
            }
        }

        public int PackIdLines
        {
            get
            {
                return ((__Internal*)__Instance)->PackIdLines;
            }

            set
            {
                ((__Internal*)__Instance)->PackIdLines = value;
            }
        }
    }

    public unsafe partial class ImFont : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVector_float.__Internal IndexAdvanceX;
            public float FallbackAdvanceX;
            public float FontSize;
            public global::DearImguiSharp.ImVectorImWchar.__Internal IndexLookup;
            public global::DearImguiSharp.ImVectorImFontGlyph.__Internal Glyphs;
            public __IntPtr FallbackGlyph;
            public __IntPtr ContainerAtlas;
            public __IntPtr ConfigData;
            public short ConfigDataCount;
            public ushort FallbackChar;
            public ushort EllipsisChar;
            public byte DirtyLookupTables;
            public float Scale;
            public float Ascent;
            public float Descent;
            public int MetricsTotalSurface;
            public fixed byte Used4kPagesMap[2];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImFont@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFont> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImFont>();

        protected bool __ownsNativeInstance;

        internal static ImFont __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFont(native.ToPointer(), skipVTables);
        }

        internal static ImFont __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFont)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFont __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFont(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFont(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFont(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFont()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFont.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFont(global::DearImguiSharp.ImFont _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFont.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImFont.__Internal*) __Instance) = *((global::DearImguiSharp.ImFont.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVector_float IndexAdvanceX
        {
            get
            {
                return global::DearImguiSharp.ImVector_float.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IndexAdvanceX));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IndexAdvanceX = *(global::DearImguiSharp.ImVector_float.__Internal*) value.__Instance;
            }
        }

        public float FallbackAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->FallbackAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->FallbackAdvanceX = value;
            }
        }

        public float FontSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontSize = value;
            }
        }

        public global::DearImguiSharp.ImVectorImWchar IndexLookup
        {
            get
            {
                return global::DearImguiSharp.ImVectorImWchar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IndexLookup));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IndexLookup = *(global::DearImguiSharp.ImVectorImWchar.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImFontGlyph Glyphs
        {
            get
            {
                return global::DearImguiSharp.ImVectorImFontGlyph.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Glyphs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Glyphs = *(global::DearImguiSharp.ImVectorImFontGlyph.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImFontGlyph FallbackGlyph
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontGlyph.__GetOrCreateInstance(((__Internal*)__Instance)->FallbackGlyph, false);
                return __result0;
            }
        }

        public global::DearImguiSharp.ImFontAtlas ContainerAtlas
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontAtlas.__GetOrCreateInstance(((__Internal*)__Instance)->ContainerAtlas, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ContainerAtlas = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImFontConfig ConfigData
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontConfig.__GetOrCreateInstance(((__Internal*)__Instance)->ConfigData, false);
                return __result0;
            }
        }

        public short ConfigDataCount
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDataCount;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDataCount = value;
            }
        }

        public ushort FallbackChar
        {
            get
            {
                return ((__Internal*)__Instance)->FallbackChar;
            }

            set
            {
                ((__Internal*)__Instance)->FallbackChar = value;
            }
        }

        public ushort EllipsisChar
        {
            get
            {
                return ((__Internal*)__Instance)->EllipsisChar;
            }

            set
            {
                ((__Internal*)__Instance)->EllipsisChar = value;
            }
        }

        public bool DirtyLookupTables
        {
            get
            {
                return ((__Internal*)__Instance)->DirtyLookupTables != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DirtyLookupTables = (byte) (value ? 1 : 0);
            }
        }

        public float Scale
        {
            get
            {
                return ((__Internal*)__Instance)->Scale;
            }

            set
            {
                ((__Internal*)__Instance)->Scale = value;
            }
        }

        public float Ascent
        {
            get
            {
                return ((__Internal*)__Instance)->Ascent;
            }

            set
            {
                ((__Internal*)__Instance)->Ascent = value;
            }
        }

        public float Descent
        {
            get
            {
                return ((__Internal*)__Instance)->Descent;
            }

            set
            {
                ((__Internal*)__Instance)->Descent = value;
            }
        }

        public int MetricsTotalSurface
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsTotalSurface;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsTotalSurface = value;
            }
        }

        public byte[] Used4kPagesMap
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->Used4kPagesMap, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->Used4kPagesMap[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiViewport : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 36)]
        public partial struct __Internal
        {
            public int Flags;
            public global::DearImguiSharp.ImVec2.__Internal Pos;
            public global::DearImguiSharp.ImVec2.__Internal Size;
            public global::DearImguiSharp.ImVec2.__Internal WorkPos;
            public global::DearImguiSharp.ImVec2.__Internal WorkSize;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "??0ImGuiViewport@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiViewport> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ImGuiViewport>();

        protected bool __ownsNativeInstance;

        internal static ImGuiViewport __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiViewport(native.ToPointer(), skipVTables);
        }

        internal static ImGuiViewport __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiViewport)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiViewport __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiViewport(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiViewport(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiViewport(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiViewport()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiViewport.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImGuiViewport(global::DearImguiSharp.ImGuiViewport _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiViewport.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::DearImguiSharp.ImGuiViewport.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiViewport.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public global::DearImguiSharp.ImVec2 Pos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 Size
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Size));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Size = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WorkPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WorkSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGui
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImVec2_ImVec2Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec2ImVec2Nil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImVec2_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVec2_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImVec2_ImVec2Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec2ImVec2Float(float _x, float _y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImVec4_ImVec4Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec4ImVec4Nil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImVec4_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVec4_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImVec4_ImVec4Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec4ImVec4Float(float _x, float _y, float _z, float _w);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCreateContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr CreateContext(__IntPtr shared_font_atlas);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDestroyContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DestroyContext(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetCurrentContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetCurrentContext();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetCurrentContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCurrentContext(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetIO", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetIO();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetStyle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStyle();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igNewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igRender", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Render();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetDrawData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igShowDemoWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowDemoWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igShowMetricsWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowMetricsWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igShowAboutWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowAboutWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igShowStyleEditor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowStyleEditor(__IntPtr @ref);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igShowStyleSelector", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ShowStyleSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igShowFontSelector", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowFontSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igShowUserGuide", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowUserGuide();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetVersion", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetVersion();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igStyleColorsDark", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StyleColorsDark(__IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igStyleColorsLight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StyleColorsLight(__IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igStyleColorsClassic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StyleColorsClassic(__IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBegin", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool Begin([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEnd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void End();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginChildStr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginChildStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, global::DearImguiSharp.ImVec2.__Internal size, bool border, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginChildID", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginChildID(uint id, global::DearImguiSharp.ImVec2.__Internal size, bool border, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndChild", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndChild();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsWindowAppearing", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowAppearing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsWindowCollapsed", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowCollapsed();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsWindowFocused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowFocused(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsWindowHovered", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowHovered(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetWindowDrawList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetWindowDrawList();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetWindowPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetWindowSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowSize(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetWindowWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetWindowWidth();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetWindowHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetWindowHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetNextWindowPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowPos(global::DearImguiSharp.ImVec2.__Internal pos, int cond, global::DearImguiSharp.ImVec2.__Internal pivot);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetNextWindowSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowSize(global::DearImguiSharp.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetNextWindowSizeConstraints", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowSizeConstraints(global::DearImguiSharp.ImVec2.__Internal size_min, global::DearImguiSharp.ImVec2.__Internal size_max, __IntPtr custom_callback, __IntPtr custom_callback_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetNextWindowContentSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowContentSize(global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetNextWindowCollapsed", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowCollapsed(bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetNextWindowFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowFocus();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetNextWindowBgAlpha", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowBgAlpha(float alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetWindowPosVec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowPosVec2(global::DearImguiSharp.ImVec2.__Internal pos, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetWindowSizeVec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowSizeVec2(global::DearImguiSharp.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetWindowCollapsedBool", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowCollapsedBool(bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetWindowFocusNil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowFocusNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetWindowFontScale", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowFontScale(float scale);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetWindowPosStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowPosStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, global::DearImguiSharp.ImVec2.__Internal pos, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetWindowSizeStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowSizeStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, global::DearImguiSharp.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetWindowCollapsedStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowCollapsedStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetWindowFocusStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowFocusStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetContentRegionAvail", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetContentRegionAvail(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetContentRegionMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetContentRegionMax(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetWindowContentRegionMin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowContentRegionMin(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetWindowContentRegionMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowContentRegionMax(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetWindowContentRegionWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetWindowContentRegionWidth();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetScrollX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetScrollY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollY();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetScrollX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollX(float scroll_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetScrollY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollY(float scroll_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetScrollMaxX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollMaxX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetScrollMaxY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollMaxY();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetScrollHereX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollHereX(float center_x_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetScrollHereY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollHereY(float center_y_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetScrollFromPosX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollFromPosX(float local_x, float center_x_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetScrollFromPosY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollFromPosY(float local_y, float center_y_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushFont(__IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPopFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopFont();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushStyleColorU32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleColorU32(int idx, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushStyleColorVec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleColorVec4(int idx, __IntPtr col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPopStyleColor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopStyleColor(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushStyleVarFloat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleVarFloat(int idx, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushStyleVarVec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleVarVec2(int idx, global::DearImguiSharp.ImVec2.__Internal val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPopStyleVar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopStyleVar(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushAllowKeyboardFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushAllowKeyboardFocus(bool allow_keyboard_focus);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPopAllowKeyboardFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopAllowKeyboardFocus();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushButtonRepeat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushButtonRepeat(bool repeat);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPopButtonRepeat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopButtonRepeat();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushItemWidth(float item_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPopItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopItemWidth();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetNextItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextItemWidth(float item_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCalcItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float CalcItemWidth();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushTextWrapPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushTextWrapPos(float wrap_local_pos_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPopTextWrapPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopTextWrapPos();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetFont();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetFontSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetFontSize();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetFontTexUvWhitePixel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetFontTexUvWhitePixel(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetColorU32Col", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetColorU32Col(int idx, float alpha_mul);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetColorU32Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetColorU32Vec4(__IntPtr col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetColorU32U32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetColorU32U32(uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetStyleColorVec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStyleColorVec4(int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSeparator", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Separator();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSameLine", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SameLine(float offset_from_start_x, float spacing);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igNewLine", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NewLine();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Spacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDummy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Dummy(global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIndent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Indent(float indent_w);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igUnindent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Unindent(float indent_w);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginGroup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginGroup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndGroup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndGroup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetCursorPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetCursorPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetCursorPosX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetCursorPosX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetCursorPosY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetCursorPosY();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetCursorPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorPos(global::DearImguiSharp.ImVec2.__Internal local_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetCursorPosX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorPosX(float local_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetCursorPosY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorPosY(float local_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetCursorStartPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetCursorStartPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetCursorScreenPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetCursorScreenPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetCursorScreenPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorScreenPos(global::DearImguiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igAlignTextToFramePadding", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void AlignTextToFramePadding();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetTextLineHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetTextLineHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetTextLineHeightWithSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetTextLineHeightWithSpacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetFrameHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetFrameHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetFrameHeightWithSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetFrameHeightWithSpacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushIDStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushIDStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushIDStrStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushIDStrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushIDPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushIDPtr(__IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushIDInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushIDInt(int int_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPopID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetIDStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetIDStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetIDStrStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetIDStrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetIDPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetIDPtr(__IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTextUnformatted", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextUnformatted([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Text([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTextColored", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextColored(__IntPtr col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTextDisabled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextDisabled([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTextWrapped", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextWrapped([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igLabelText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LabelText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBulletText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BulletText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool Button([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSmallButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SmallButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInvisibleButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InvisibleButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, global::DearImguiSharp.ImVec2.__Internal size, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igArrowButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ArrowButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int dir);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igImage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Image(__IntPtr user_texture_id, global::DearImguiSharp.ImVec2.__Internal size, global::DearImguiSharp.ImVec2.__Internal uv0, global::DearImguiSharp.ImVec2.__Internal uv1, __IntPtr tint_col, __IntPtr border_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igImageButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImageButton(__IntPtr user_texture_id, global::DearImguiSharp.ImVec2.__Internal size, global::DearImguiSharp.ImVec2.__Internal uv0, global::DearImguiSharp.ImVec2.__Internal uv1, int frame_padding, __IntPtr bg_col, __IntPtr tint_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCheckbox", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool Checkbox([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCheckboxFlagsIntPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CheckboxFlagsIntPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* flags, int flags_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCheckboxFlagsUintPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CheckboxFlagsUintPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, uint* flags, uint flags_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igRadioButtonBool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool RadioButtonBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool active);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igRadioButtonIntPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool RadioButtonIntPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int v_button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igProgressBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ProgressBar(float fraction, global::DearImguiSharp.ImVec2.__Internal size_arg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBullet", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Bullet();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginCombo", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginCombo([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string preview_value, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndCombo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndCombo();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igComboStr_arr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ComboStr_arr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.LPArray)] string[] items, int items_count, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igComboStr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ComboStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string items_separated_by_zeros, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igComboFnBoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ComboFnBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, __IntPtr items_getter, __IntPtr data, int items_count, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragFloat2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragFloat3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragFloat4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragFloatRange2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloatRange2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format_max, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragInt2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragInt3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragInt4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragIntRange2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragIntRange2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format_max, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDragScalarN", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSliderFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSliderFloat2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSliderFloat3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSliderFloat4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSliderAngle", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderAngle([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v_rad, float v_degrees_min, float v_degrees_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSliderInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSliderInt2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSliderInt3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSliderInt4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSliderScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSliderScalarN", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igVSliderFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool VSliderFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::DearImguiSharp.ImVec2.__Internal size, float* v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igVSliderInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool VSliderInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::DearImguiSharp.ImVec2.__Internal size, int* v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igVSliderScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool VSliderScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::DearImguiSharp.ImVec2.__Internal size, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputText", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, sbyte* buf, IntPtr buf_size, int flags, __IntPtr callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputTextMultiline", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputTextMultiline([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, sbyte* buf, IntPtr buf_size, global::DearImguiSharp.ImVec2.__Internal size, int flags, __IntPtr callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputTextWithHint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputTextWithHint([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string hint, sbyte* buf, IntPtr buf_size, int flags, __IntPtr callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float step, float step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputFloat2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputFloat3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputFloat4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int step, int step_fast, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputInt2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputInt3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputInt4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputDouble", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputDouble([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, double* v, double step, double step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, __IntPtr p_step, __IntPtr p_step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igInputScalarN", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, __IntPtr p_step, __IntPtr p_step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igColorEdit3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorEdit3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igColorEdit4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorEdit4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igColorPicker3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorPicker3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igColorPicker4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorPicker4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags, float* ref_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igColorButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string desc_id, __IntPtr col, int flags, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetColorEditOptions", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetColorEditOptions(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTreeNodeStr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTreeNodeStrStr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeStrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTreeNodePtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodePtr(__IntPtr ptr_id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTreeNodeExStr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeExStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTreeNodeExStrStr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeExStrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTreeNodeExPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeExPtr(__IntPtr ptr_id, int flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTreePushStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TreePushStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTreePushPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TreePushPtr(__IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTreePop", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TreePop();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetTreeNodeToLabelSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetTreeNodeToLabelSpacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCollapsingHeaderTreeNodeFlags", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CollapsingHeaderTreeNodeFlags([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCollapsingHeaderBoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CollapsingHeaderBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_visible, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetNextItemOpen", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextItemOpen(bool is_open, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSelectableBool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SelectableBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool selected, int flags, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSelectableBoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SelectableBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_selected, int flags, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginListBox", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginListBox([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndListBox", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndListBox();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igListBoxStr_arr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ListBoxStr_arr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.LPArray)] string[] items, int items_count, int height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igListBoxFnBoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ListBoxFnBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, __IntPtr items_getter, __IntPtr data, int items_count, int height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPlotLinesFloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotLinesFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* values, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2.__Internal graph_size, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPlotLinesFnFloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotLinesFnFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr values_getter, __IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2.__Internal graph_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPlotHistogramFloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotHistogramFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* values, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2.__Internal graph_size, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPlotHistogramFnFloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotHistogramFnFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr values_getter, __IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2.__Internal graph_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igValueBool", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, bool b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igValueInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, int v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igValueUint", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueUint([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, uint v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igValueFloat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, float v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string float_format);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginMainMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginMainMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndMainMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndMainMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginMenu", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginMenu([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndMenu", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndMenu();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igMenuItemBool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool MenuItemBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shortcut, bool selected, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igMenuItemBoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool MenuItemBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shortcut, bool* p_selected, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginTooltip", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginTooltip();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndTooltip", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTooltip();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetTooltip", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetTooltip([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginPopup", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginPopupModal", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupModal([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndPopup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igOpenPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void OpenPopup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igOpenPopupOnItemClick", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void OpenPopupOnItemClick([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCloseCurrentPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CloseCurrentPopup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginPopupContextItem", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupContextItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginPopupContextWindow", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupContextWindow([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginPopupContextVoid", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupContextVoid([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsPopupOpen", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsPopupOpen([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginTable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTable([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int column, int flags, global::DearImguiSharp.ImVec2.__Internal outer_size, float inner_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTable();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableNextRow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableNextRow(int row_flags, float min_row_height);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableNextColumn", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TableNextColumn();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableSetColumnIndex", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TableSetColumnIndex(int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableSetupColumn", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetupColumn([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags, float init_width_or_weight, uint user_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableSetupScrollFreeze", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetupScrollFreeze(int cols, int rows);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableHeadersRow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableHeadersRow();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableHeader", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableHeader([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableGetSortSpecs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableGetSortSpecs();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableGetColumnCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetColumnCount();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableGetColumnIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetColumnIndex();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableGetRowIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetRowIndex();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableGetColumnName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableGetColumnName(int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableGetColumnFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetColumnFlags(int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTableSetBgColor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetBgColor(int target, uint color, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Columns(int count, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string id, bool border);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igNextColumn", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NextColumn();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetColumnIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetColumnIndex();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetColumnWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetColumnWidth(int column_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetColumnWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetColumnWidth(int column_index, float width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetColumnOffset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetColumnOffset(int column_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetColumnOffset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetColumnOffset(int column_index, float offset_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetColumnsCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetColumnsCount();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginTabBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTabBar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndTabBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTabBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginTabItem", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTabItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndTabItem", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTabItem();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igTabItemButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TabItemButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetTabItemClosed", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetTabItemClosed([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string tab_or_docked_window_label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igLogToTTY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogToTTY(int auto_open_depth);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igLogToFile", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogToFile(int auto_open_depth, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igLogToClipboard", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogToClipboard(int auto_open_depth);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igLogFinish", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogFinish();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igLogButtons", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogButtons();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginDragDropSource", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginDragDropSource(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetDragDropPayload", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SetDragDropPayload([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type, __IntPtr data, IntPtr sz, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndDragDropSource", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndDragDropSource();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginDragDropTarget", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginDragDropTarget();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igAcceptDragDropPayload", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr AcceptDragDropPayload([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndDragDropTarget", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndDragDropTarget();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetDragDropPayload", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetDragDropPayload();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPushClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushClipRect(global::DearImguiSharp.ImVec2.__Internal clip_rect_min, global::DearImguiSharp.ImVec2.__Internal clip_rect_max, bool intersect_with_current_clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igPopClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopClipRect();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetItemDefaultFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetItemDefaultFocus();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetKeyboardFocusHere", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetKeyboardFocusHere(int offset);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsItemHovered", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemHovered(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsItemActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemActive();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsItemFocused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemFocused();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsItemClicked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemClicked(int mouse_button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsItemVisible", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemVisible();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsItemEdited", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemEdited();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsItemActivated", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemActivated();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsItemDeactivated", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemDeactivated();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsItemDeactivatedAfterEdit", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemDeactivatedAfterEdit();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsItemToggledOpen", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemToggledOpen();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsAnyItemHovered", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyItemHovered();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsAnyItemActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyItemActive();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsAnyItemFocused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyItemFocused();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetItemRectMin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetItemRectMin(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetItemRectMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetItemRectMax(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetItemRectSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetItemRectSize(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetItemAllowOverlap", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetItemAllowOverlap();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetMainViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetMainViewport();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsRectVisibleNil", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsRectVisibleNil(global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsRectVisibleVec2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsRectVisibleVec2(global::DearImguiSharp.ImVec2.__Internal rect_min, global::DearImguiSharp.ImVec2.__Internal rect_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetTime", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double GetTime();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetFrameCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetFrameCount();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetBackgroundDrawList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetBackgroundDrawList();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetForegroundDrawList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetForegroundDrawList();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetDrawListSharedData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetDrawListSharedData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetStyleColorName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStyleColorName(int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetStateStorage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetStateStorage(__IntPtr storage);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetStateStorage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStateStorage();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCalcListClipping", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igBeginChildFrame", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginChildFrame(uint id, global::DearImguiSharp.ImVec2.__Internal size, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igEndChildFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndChildFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCalcTextSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CalcTextSize(__IntPtr pOut, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, bool hide_text_after_double_hash, float wrap_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igColorConvertU32ToFloat4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorConvertU32ToFloat4(__IntPtr pOut, uint @in);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igColorConvertFloat4ToU32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ColorConvertFloat4ToU32(__IntPtr @in);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igColorConvertRGBtoHSV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorConvertRGBtoHSV(float r, float g, float b, float* out_h, float* out_s, float* out_v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igColorConvertHSVtoRGB", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorConvertHSVtoRGB(float h, float s, float v, float* out_r, float* out_g, float* out_b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetKeyIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetKeyIndex(int imgui_key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsKeyDown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsKeyDown(int user_key_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsKeyPressed", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsKeyPressed(int user_key_index, bool repeat);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsKeyReleased", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsKeyReleased(int user_key_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetKeyPressedAmount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetKeyPressedAmount(int key_index, float repeat_delay, float rate);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCaptureKeyboardFromApp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CaptureKeyboardFromApp(bool want_capture_keyboard_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsMouseDown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseDown(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsMouseClicked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseClicked(int button, bool repeat);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsMouseReleased", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseReleased(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsMouseDoubleClicked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseDoubleClicked(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsMouseHoveringRect", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseHoveringRect(global::DearImguiSharp.ImVec2.__Internal r_min, global::DearImguiSharp.ImVec2.__Internal r_max, bool clip);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsMousePosValid", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMousePosValid(__IntPtr mouse_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsAnyMouseDown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyMouseDown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetMousePos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetMousePos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetMousePosOnOpeningCurrentPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetMousePosOnOpeningCurrentPopup(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igIsMouseDragging", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseDragging(int button, float lock_threshold);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetMouseDragDelta", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetMouseDragDelta(__IntPtr pOut, int button, float lock_threshold);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igResetMouseDragDelta", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ResetMouseDragDelta(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetMouseCursor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetMouseCursor();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetMouseCursor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetMouseCursor(int cursor_type);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igCaptureMouseFromApp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CaptureMouseFromApp(bool want_capture_mouse_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGetClipboardText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetClipboardText();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetClipboardText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetClipboardText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igLoadIniSettingsFromDisk", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LoadIniSettingsFromDisk([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_filename);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igLoadIniSettingsFromMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LoadIniSettingsFromMemory([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_data, IntPtr ini_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSaveIniSettingsToDisk", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SaveIniSettingsToDisk([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_filename);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSaveIniSettingsToMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr SaveIniSettingsToMemory(IntPtr* out_ini_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igDebugCheckVersionAndDataLayout", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DebugCheckVersionAndDataLayout([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string version_str, IntPtr sz_io, IntPtr sz_style, IntPtr sz_vec2, IntPtr sz_vec4, IntPtr sz_drawvert, IntPtr sz_drawidx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igSetAllocatorFunctions", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetAllocatorFunctions(__IntPtr alloc_func, __IntPtr free_func, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igMemAlloc", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr MemAlloc(IntPtr size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igMemFree", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void MemFree(__IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStyle_ImGuiStyle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStyleImGuiStyle();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStyle_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStyle_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStyle_ScaleAllSizes", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStyleScaleAllSizes(__IntPtr self, float scale_factor);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiIO_AddInputCharacter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddInputCharacter(__IntPtr self, uint c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiIO_AddInputCharacterUTF16", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddInputCharacterUTF16(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiIO_AddInputCharactersUTF8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddInputCharactersUTF8(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiIO_ClearInputCharacters", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_ClearInputCharacters(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiIO_ImGuiIO", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiIO_ImGuiIO();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiIO_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiInputTextCallbackData_ImGuiInputTextCallbackData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiInputTextCallbackDataImGuiInputTextCallbackData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiInputTextCallbackData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiInputTextCallbackData_DeleteChars", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataDeleteChars(__IntPtr self, int pos, int bytes_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiInputTextCallbackData_InsertChars", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataInsertChars(__IntPtr self, int pos, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiInputTextCallbackData_SelectAll", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataSelectAll(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiInputTextCallbackData_ClearSelection", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataClearSelection(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiInputTextCallbackData_HasSelection", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiInputTextCallbackDataHasSelection(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiPayload_ImGuiPayload", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPayloadImGuiPayload();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiPayload_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPayload_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiPayload_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPayloadClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiPayload_IsDataType", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiPayloadIsDataType(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiPayload_IsPreview", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiPayloadIsPreview(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiPayload_IsDelivery", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiPayloadIsDelivery(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableColumnSortSpecsImGuiTableColumnSortSpecs();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTableColumnSortSpecs_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableColumnSortSpecs_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTableSortSpecs_ImGuiTableSortSpecs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableSortSpecsImGuiTableSortSpecs();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTableSortSpecs_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableSortSpecs_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiOnceUponAFrame_ImGuiOnceUponAFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiOnceUponAFrameImGuiOnceUponAFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiOnceUponAFrame_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiOnceUponAFrame_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextFilter_ImGuiTextFilter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextFilterImGuiTextFilter([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string default_filter);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextFilter_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextFilter_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextFilter_Draw", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextFilterDraw(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextFilter_PassFilter", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextFilterPassFilter(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextFilter_Build", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextFilterBuild(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextFilter_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextFilterClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextFilter_IsActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextFilterIsActive(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextRange_ImGuiTextRangeNil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextRangeImGuiTextRangeNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextRange_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextRange_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextRange_ImGuiTextRangeStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextRangeImGuiTextRangeStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _b, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _e);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextRange_empty", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextRange_empty(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextRange_split", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextRange_split(__IntPtr self, sbyte separator, __IntPtr @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextBuffer_ImGuiTextBuffer", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBufferImGuiTextBuffer();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextBuffer_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextBuffer_begin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBuffer_begin(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextBuffer_end", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBuffer_end(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextBuffer_size", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiTextBuffer_size(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextBuffer_empty", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextBuffer_empty(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextBuffer_clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_clear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextBuffer_reserve", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_reserve(__IntPtr self, int capacity);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextBuffer_c_str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBuffer_c_str(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiTextBuffer_append", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_append(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStoragePair_ImGuiStoragePairInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStoragePairImGuiStoragePairInt(uint _key, int _val_i);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStoragePair_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStoragePair_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStoragePair_ImGuiStoragePairFloat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStoragePairImGuiStoragePairFloat(uint _key, float _val_f);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStoragePair_ImGuiStoragePairPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStoragePairImGuiStoragePairPtr(uint _key, __IntPtr _val_p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_GetInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiStorageGetInt(__IntPtr self, uint key, int default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_SetInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetInt(__IntPtr self, uint key, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_GetBool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiStorageGetBool(__IntPtr self, uint key, bool default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_SetBool", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetBool(__IntPtr self, uint key, bool val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_GetFloat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiStorageGetFloat(__IntPtr self, uint key, float default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_SetFloat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetFloat(__IntPtr self, uint key, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_GetVoidPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStorageGetVoidPtr(__IntPtr self, uint key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_SetVoidPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetVoidPtr(__IntPtr self, uint key, __IntPtr val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_GetIntRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int* ImGuiStorageGetIntRef(__IntPtr self, uint key, int default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_GetBoolRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern bool* ImGuiStorageGetBoolRef(__IntPtr self, uint key, bool default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_GetFloatRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float* ImGuiStorageGetFloatRef(__IntPtr self, uint key, float default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_GetVoidPtrRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void** ImGuiStorageGetVoidPtrRef(__IntPtr self, uint key, __IntPtr default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_SetAllInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetAllInt(__IntPtr self, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiStorage_BuildSortByKey", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageBuildSortByKey(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiListClipper_ImGuiListClipper", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiListClipperImGuiListClipper();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiListClipper_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipper_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiListClipper_Begin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperBegin(__IntPtr self, int items_count, float items_height);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiListClipper_End", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperEnd(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiListClipper_Step", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiListClipperStep(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImColor_ImColorNil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImColor_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImColor_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImColor_ImColorInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorInt(int r, int g, int b, int a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImColor_ImColorU32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorU32(uint rgba);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImColor_ImColorFloat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorFloat(float r, float g, float b, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImColor_ImColorVec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorVec4(__IntPtr col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImColor_SetHSV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImColorSetHSV(__IntPtr self, float h, float s, float v, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImColor_HSV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImColorHSV(__IntPtr pOut, float h, float s, float v, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawCmd_ImDrawCmd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawCmdImDrawCmd();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawCmd_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawCmd_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawListSplitter_ImDrawListSplitter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawListSplitterImDrawListSplitter();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawListSplitter_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitter_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawListSplitter_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawListSplitter_ClearFreeMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterClearFreeMemory(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawListSplitter_Split", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterSplit(__IntPtr self, __IntPtr draw_list, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawListSplitter_Merge", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterMerge(__IntPtr self, __IntPtr draw_list);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawListSplitter_SetCurrentChannel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterSetCurrentChannel(__IntPtr self, __IntPtr draw_list, int channel_idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_ImDrawList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawListImDrawList(__IntPtr shared_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawList_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PushClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPushClipRect(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal clip_rect_min, global::DearImguiSharp.ImVec2.__Internal clip_rect_max, bool intersect_with_current_clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PushClipRectFullScreen", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPushClipRectFullScreen(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PopClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPopClipRect(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PushTextureID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPushTextureID(__IntPtr self, __IntPtr texture_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PopTextureID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPopTextureID(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_GetClipRectMin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListGetClipRectMin(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_GetClipRectMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListGetClipRectMax(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddLine", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddLine(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddRect(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, uint col, float rounding, int rounding_corners, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddRectFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddRectFilled(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, uint col, float rounding, int rounding_corners);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddRectFilledMultiColor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddRectFilledMultiColor(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, uint col_upr_left, uint col_upr_right, uint col_bot_right, uint col_bot_left);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddQuad", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddQuad(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddQuadFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddQuadFilled(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddTriangle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTriangle(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddTriangleFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTriangleFilled(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddCircle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddCircle(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddCircleFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddCircleFilled(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddNgon", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddNgon(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddNgonFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddNgonFilled(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddTextVec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTextVec2(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal pos, uint col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddTextFontPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTextFontPtr(__IntPtr self, __IntPtr font, float font_size, global::DearImguiSharp.ImVec2.__Internal pos, uint col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width, __IntPtr cpu_fine_clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddPolyline", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddPolyline(__IntPtr self, __IntPtr points, int num_points, uint col, bool closed, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddConvexPolyFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddConvexPolyFilled(__IntPtr self, __IntPtr points, int num_points, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddBezierCubic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddBezierCubic(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, uint col, float thickness, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddBezierQuadratic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddBezierQuadratic(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, uint col, float thickness, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddImage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddImage(__IntPtr self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, global::DearImguiSharp.ImVec2.__Internal uv_min, global::DearImguiSharp.ImVec2.__Internal uv_max, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddImageQuad", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddImageQuad(__IntPtr self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, global::DearImguiSharp.ImVec2.__Internal uv1, global::DearImguiSharp.ImVec2.__Internal uv2, global::DearImguiSharp.ImVec2.__Internal uv3, global::DearImguiSharp.ImVec2.__Internal uv4, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddImageRounded", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddImageRounded(__IntPtr self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, global::DearImguiSharp.ImVec2.__Internal uv_min, global::DearImguiSharp.ImVec2.__Internal uv_max, uint col, float rounding, int rounding_corners);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PathClear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PathLineTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathLineTo(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PathLineToMergeDuplicate", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathLineToMergeDuplicate(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PathFillConvex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathFillConvex(__IntPtr self, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PathStroke", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathStroke(__IntPtr self, uint col, bool closed, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PathArcTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathArcTo(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, float a_min, float a_max, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PathArcToFast", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathArcToFast(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, int a_min_of_12, int a_max_of_12);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PathBezierCubicCurveTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathBezierCubicCurveTo(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PathBezierQuadraticCurveTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathBezierQuadraticCurveTo(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PathRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathRect(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal rect_min, global::DearImguiSharp.ImVec2.__Internal rect_max, float rounding, int rounding_corners);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddCallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddCallback(__IntPtr self, __IntPtr callback, __IntPtr callback_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_AddDrawCmd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddDrawCmd(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_CloneOutput", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawListCloneOutput(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_ChannelsSplit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListChannelsSplit(__IntPtr self, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_ChannelsMerge", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListChannelsMerge(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_ChannelsSetCurrent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListChannelsSetCurrent(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PrimReserve", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimReserve(__IntPtr self, int idx_count, int vtx_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PrimUnreserve", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimUnreserve(__IntPtr self, int idx_count, int vtx_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PrimRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimRect(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PrimRectUV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimRectUV(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, global::DearImguiSharp.ImVec2.__Internal uv_a, global::DearImguiSharp.ImVec2.__Internal uv_b, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PrimQuadUV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimQuadUV(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, global::DearImguiSharp.ImVec2.__Internal c, global::DearImguiSharp.ImVec2.__Internal d, global::DearImguiSharp.ImVec2.__Internal uv_a, global::DearImguiSharp.ImVec2.__Internal uv_b, global::DearImguiSharp.ImVec2.__Internal uv_c, global::DearImguiSharp.ImVec2.__Internal uv_d, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PrimWriteVtx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimWriteVtx(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal pos, global::DearImguiSharp.ImVec2.__Internal uv, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PrimWriteIdx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimWriteIdx(__IntPtr self, ushort idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList_PrimVtx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimVtx(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal pos, global::DearImguiSharp.ImVec2.__Internal uv, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList__ResetForNewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListResetForNewFrame(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList__ClearFreeMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListClearFreeMemory(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList__PopUnusedDrawCmd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPopUnusedDrawCmd(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList__OnChangedClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListOnChangedClipRect(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList__OnChangedTextureID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListOnChangedTextureID(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawList__OnChangedVtxOffset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListOnChangedVtxOffset(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawData_ImDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawDataImDrawData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawData_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawData_DeIndexAllBuffers", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataDeIndexAllBuffers(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImDrawData_ScaleClipRects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataScaleClipRects(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal fb_scale);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontConfig_ImFontConfig", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontConfigImFontConfig();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontConfig_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontConfig_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontGlyphRangesBuilderImFontGlyphRangesBuilder();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontGlyphRangesBuilder_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilder_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontGlyphRangesBuilder_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontGlyphRangesBuilder_GetBit", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontGlyphRangesBuilderGetBit(__IntPtr self, IntPtr n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontGlyphRangesBuilder_SetBit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderSetBit(__IntPtr self, IntPtr n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontGlyphRangesBuilder_AddChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderAddChar(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontGlyphRangesBuilder_AddText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderAddText(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontGlyphRangesBuilder_AddRanges", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderAddRanges(__IntPtr self, ushort* ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontGlyphRangesBuilder_BuildRanges", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderBuildRanges(__IntPtr self, __IntPtr out_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlasCustomRect_ImFontAtlasCustomRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasCustomRectImFontAtlasCustomRect();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlasCustomRect_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasCustomRect_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlasCustomRect_IsPacked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasCustomRectIsPacked(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_ImFontAtlas", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasImFontAtlas();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlas_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_AddFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFont(__IntPtr self, __IntPtr font_cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_AddFontDefault", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontDefault(__IntPtr self, __IntPtr font_cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_AddFontFromFileTTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromFileTTF(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_AddFontFromMemoryTTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromMemoryTTF(__IntPtr self, __IntPtr font_data, int font_size, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_AddFontFromMemoryCompressedTTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromMemoryCompressedTTF(__IntPtr self, __IntPtr compressed_font_data, int compressed_font_size, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_AddFontFromMemoryCompressedBase85TTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromMemoryCompressedBase85TTF(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string compressed_font_data_base85, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_ClearInputData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClearInputData(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_ClearTexData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClearTexData(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_ClearFonts", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClearFonts(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_Build", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasBuild(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetTexDataAsAlpha8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasGetTexDataAsAlpha8(__IntPtr self, byte** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetTexDataAsRGBA32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasGetTexDataAsRGBA32(__IntPtr self, byte** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_IsBuilt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasIsBuilt(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_SetTexID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasSetTexID(__IntPtr self, __IntPtr id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetGlyphRangesDefault", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesDefault(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetGlyphRangesKorean", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesKorean(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetGlyphRangesJapanese", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesJapanese(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetGlyphRangesChineseFull", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesChineseFull(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetGlyphRangesCyrillic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesCyrillic(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetGlyphRangesThai", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesThai(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetGlyphRangesVietnamese", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesVietnamese(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_AddCustomRectRegular", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImFontAtlasAddCustomRectRegular(__IntPtr self, int width, int height);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_AddCustomRectFontGlyph", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImFontAtlasAddCustomRectFontGlyph(__IntPtr self, __IntPtr font, ushort id, int width, int height, float advance_x, global::DearImguiSharp.ImVec2.__Internal offset);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetCustomRectByIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasGetCustomRectByIndex(__IntPtr self, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_CalcCustomRectUV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasCalcCustomRectUV(__IntPtr self, __IntPtr rect, __IntPtr out_uv_min, __IntPtr out_uv_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFontAtlas_GetMouseCursorTexData", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasGetMouseCursorTexData(__IntPtr self, int cursor, __IntPtr out_offset, __IntPtr out_size, global::DearImguiSharp.ImVec2.__Internal[] out_uv_border, global::DearImguiSharp.ImVec2.__Internal[] out_uv_fill);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_ImFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontImFont();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFont_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_FindGlyph", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontFindGlyph(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_FindGlyphNoFallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontFindGlyphNoFallback(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_GetCharAdvance", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImFontGetCharAdvance(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_IsLoaded", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontIsLoaded(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_GetDebugName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontGetDebugName(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_CalcTextSizeA", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontCalcTextSizeA(__IntPtr pOut, __IntPtr self, float size, float max_width, float wrap_width, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, sbyte** remaining);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_CalcWordWrapPositionA", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontCalcWordWrapPositionA(__IntPtr self, float scale, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_RenderChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontRenderChar(__IntPtr self, __IntPtr draw_list, float size, global::DearImguiSharp.ImVec2.__Internal pos, uint col, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_RenderText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontRenderText(__IntPtr self, __IntPtr draw_list, float size, global::DearImguiSharp.ImVec2.__Internal pos, uint col, __IntPtr clip_rect, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width, bool cpu_fine_clip);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_BuildLookupTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontBuildLookupTable(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_ClearOutputData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontClearOutputData(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_GrowIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGrowIndex(__IntPtr self, int new_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_AddGlyph", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAddGlyph(__IntPtr self, __IntPtr src_cfg, ushort c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_AddRemapChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAddRemapChar(__IntPtr self, ushort dst, ushort src, bool overwrite_dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_SetGlyphVisible", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontSetGlyphVisible(__IntPtr self, ushort c, bool visible);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_SetFallbackChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontSetFallbackChar(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImFont_IsGlyphRangeUnused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontIsGlyphRangeUnused(__IntPtr self, uint c_begin, uint c_last);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiViewport_ImGuiViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiViewportImGuiViewport();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiViewport_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewport_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiViewport_GetCenter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportGetCenter(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGuiViewport_GetWorkCenter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportGetWorkCenter(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igLogText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGET_FLT_MAX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GET_FLT_MAX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "igGET_FLT_MIN", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GET_FLT_MIN();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImVector_ImWchar_create", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVectorImWchar_create();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImVector_ImWchar_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVectorImWchar_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImVector_ImWchar_Init", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVectorImWcharInit(__IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImVector_ImWchar_UnInit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVectorImWcharUnInit(__IntPtr p);
        }

        public static global::DearImguiSharp.ImVec2 ImVec2ImVec2Nil()
        {
            var __ret = __Internal.ImVec2ImVec2Nil();
            var __result0 = global::DearImguiSharp.ImVec2.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVec2_destroy(global::DearImguiSharp.ImVec2 self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVec2_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImVec2 ImVec2ImVec2Float(float _x, float _y)
        {
            var __ret = __Internal.ImVec2ImVec2Float(_x, _y);
            var __result0 = global::DearImguiSharp.ImVec2.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImVec4 ImVec4ImVec4Nil()
        {
            var __ret = __Internal.ImVec4ImVec4Nil();
            var __result0 = global::DearImguiSharp.ImVec4.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVec4_destroy(global::DearImguiSharp.ImVec4 self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVec4_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImVec4 ImVec4ImVec4Float(float _x, float _y, float _z, float _w)
        {
            var __ret = __Internal.ImVec4ImVec4Float(_x, _y, _z, _w);
            var __result0 = global::DearImguiSharp.ImVec4.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiContext CreateContext(global::DearImguiSharp.ImFontAtlas shared_font_atlas)
        {
            var __arg0 = shared_font_atlas is null ? __IntPtr.Zero : shared_font_atlas.__Instance;
            var __ret = __Internal.CreateContext(__arg0);
            var __result0 = global::DearImguiSharp.ImGuiContext.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void DestroyContext(global::DearImguiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.DestroyContext(__arg0);
        }

        public static global::DearImguiSharp.ImGuiContext GetCurrentContext()
        {
            var __ret = __Internal.GetCurrentContext();
            var __result0 = global::DearImguiSharp.ImGuiContext.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void SetCurrentContext(global::DearImguiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.SetCurrentContext(__arg0);
        }

        public static global::DearImguiSharp.ImGuiIO GetIO()
        {
            var __ret = __Internal.GetIO();
            var __result0 = global::DearImguiSharp.ImGuiIO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiStyle GetStyle()
        {
            var __ret = __Internal.GetStyle();
            var __result0 = global::DearImguiSharp.ImGuiStyle.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void NewFrame()
        {
            __Internal.NewFrame();
        }

        public static void EndFrame()
        {
            __Internal.EndFrame();
        }

        public static void Render()
        {
            __Internal.Render();
        }

        public static global::DearImguiSharp.ImDrawData GetDrawData()
        {
            var __ret = __Internal.GetDrawData();
            var __result0 = global::DearImguiSharp.ImDrawData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ShowDemoWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowDemoWindow(__arg0);
            }
        }

        public static void ShowMetricsWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowMetricsWindow(__arg0);
            }
        }

        public static void ShowAboutWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowAboutWindow(__arg0);
            }
        }

        public static void ShowStyleEditor(global::DearImguiSharp.ImGuiStyle @ref)
        {
            var __arg0 = @ref is null ? __IntPtr.Zero : @ref.__Instance;
            __Internal.ShowStyleEditor(__arg0);
        }

        public static bool ShowStyleSelector(string label)
        {
            var __ret = __Internal.ShowStyleSelector(label);
            return __ret;
        }

        public static void ShowFontSelector(string label)
        {
            __Internal.ShowFontSelector(label);
        }

        public static void ShowUserGuide()
        {
            __Internal.ShowUserGuide();
        }

        public static string GetVersion()
        {
            var __ret = __Internal.GetVersion();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void StyleColorsDark(global::DearImguiSharp.ImGuiStyle dst)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsDark(__arg0);
        }

        public static void StyleColorsLight(global::DearImguiSharp.ImGuiStyle dst)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsLight(__arg0);
        }

        public static void StyleColorsClassic(global::DearImguiSharp.ImGuiStyle dst)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsClassic(__arg0);
        }

        public static bool Begin(string name, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.Begin(name, __arg1, flags);
                return __ret;
            }
        }

        public static void End()
        {
            __Internal.End();
        }

        public static bool BeginChildStr(string str_id, global::DearImguiSharp.ImVec2 size, bool border, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildStr(str_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, border, flags);
            return __ret;
        }

        public static bool BeginChildID(uint id, global::DearImguiSharp.ImVec2 size, bool border, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildID(id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, border, flags);
            return __ret;
        }

        public static void EndChild()
        {
            __Internal.EndChild();
        }

        public static bool IsWindowAppearing()
        {
            var __ret = __Internal.IsWindowAppearing();
            return __ret;
        }

        public static bool IsWindowCollapsed()
        {
            var __ret = __Internal.IsWindowCollapsed();
            return __ret;
        }

        public static bool IsWindowFocused(int flags)
        {
            var __ret = __Internal.IsWindowFocused(flags);
            return __ret;
        }

        public static bool IsWindowHovered(int flags)
        {
            var __ret = __Internal.IsWindowHovered(flags);
            return __ret;
        }

        public static global::DearImguiSharp.ImDrawList GetWindowDrawList()
        {
            var __ret = __Internal.GetWindowDrawList();
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void GetWindowPos(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowPos(__arg0);
        }

        public static void GetWindowSize(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowSize(__arg0);
        }

        public static float GetWindowWidth()
        {
            var __ret = __Internal.GetWindowWidth();
            return __ret;
        }

        public static float GetWindowHeight()
        {
            var __ret = __Internal.GetWindowHeight();
            return __ret;
        }

        public static void SetNextWindowPos(global::DearImguiSharp.ImVec2 pos, int cond, global::DearImguiSharp.ImVec2 pivot)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            if (ReferenceEquals(pivot, null))
                throw new global::System.ArgumentNullException("pivot", "Cannot be null because it is passed by value.");
            var __arg2 = pivot.__Instance;
            __Internal.SetNextWindowPos(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, cond, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void SetNextWindowSize(global::DearImguiSharp.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetNextWindowSize(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetNextWindowSizeConstraints(global::DearImguiSharp.ImVec2 size_min, global::DearImguiSharp.ImVec2 size_max, global::DearImguiSharp.ImGuiSizeCallback custom_callback, __IntPtr custom_callback_data)
        {
            if (ReferenceEquals(size_min, null))
                throw new global::System.ArgumentNullException("size_min", "Cannot be null because it is passed by value.");
            var __arg0 = size_min.__Instance;
            if (ReferenceEquals(size_max, null))
                throw new global::System.ArgumentNullException("size_max", "Cannot be null because it is passed by value.");
            var __arg1 = size_max.__Instance;
            var __arg2 = custom_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(custom_callback);
            __Internal.SetNextWindowSizeConstraints(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, __arg2, custom_callback_data);
        }

        public static void SetNextWindowContentSize(global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetNextWindowContentSize(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void SetNextWindowCollapsed(bool collapsed, int cond)
        {
            __Internal.SetNextWindowCollapsed(collapsed, cond);
        }

        public static void SetNextWindowFocus()
        {
            __Internal.SetNextWindowFocus();
        }

        public static void SetNextWindowBgAlpha(float alpha)
        {
            __Internal.SetNextWindowBgAlpha(alpha);
        }

        public static void SetWindowPosVec2(global::DearImguiSharp.ImVec2 pos, int cond)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.SetWindowPosVec2(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetWindowSizeVec2(global::DearImguiSharp.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetWindowSizeVec2(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetWindowCollapsedBool(bool collapsed, int cond)
        {
            __Internal.SetWindowCollapsedBool(collapsed, cond);
        }

        public static void SetWindowFocusNil()
        {
            __Internal.SetWindowFocusNil();
        }

        public static void SetWindowFontScale(float scale)
        {
            __Internal.SetWindowFontScale(scale);
        }

        public static void SetWindowPosStr(string name, global::DearImguiSharp.ImVec2 pos, int cond)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.SetWindowPosStr(name, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowSizeStr(string name, global::DearImguiSharp.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            __Internal.SetWindowSizeStr(name, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowCollapsedStr(string name, bool collapsed, int cond)
        {
            __Internal.SetWindowCollapsedStr(name, collapsed, cond);
        }

        public static void SetWindowFocusStr(string name)
        {
            __Internal.SetWindowFocusStr(name);
        }

        public static void GetContentRegionAvail(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetContentRegionAvail(__arg0);
        }

        public static void GetContentRegionMax(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetContentRegionMax(__arg0);
        }

        public static void GetWindowContentRegionMin(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowContentRegionMin(__arg0);
        }

        public static void GetWindowContentRegionMax(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowContentRegionMax(__arg0);
        }

        public static float GetWindowContentRegionWidth()
        {
            var __ret = __Internal.GetWindowContentRegionWidth();
            return __ret;
        }

        public static float GetScrollX()
        {
            var __ret = __Internal.GetScrollX();
            return __ret;
        }

        public static float GetScrollY()
        {
            var __ret = __Internal.GetScrollY();
            return __ret;
        }

        public static void SetScrollX(float scroll_x)
        {
            __Internal.SetScrollX(scroll_x);
        }

        public static void SetScrollY(float scroll_y)
        {
            __Internal.SetScrollY(scroll_y);
        }

        public static float GetScrollMaxX()
        {
            var __ret = __Internal.GetScrollMaxX();
            return __ret;
        }

        public static float GetScrollMaxY()
        {
            var __ret = __Internal.GetScrollMaxY();
            return __ret;
        }

        public static void SetScrollHereX(float center_x_ratio)
        {
            __Internal.SetScrollHereX(center_x_ratio);
        }

        public static void SetScrollHereY(float center_y_ratio)
        {
            __Internal.SetScrollHereY(center_y_ratio);
        }

        public static void SetScrollFromPosX(float local_x, float center_x_ratio)
        {
            __Internal.SetScrollFromPosX(local_x, center_x_ratio);
        }

        public static void SetScrollFromPosY(float local_y, float center_y_ratio)
        {
            __Internal.SetScrollFromPosY(local_y, center_y_ratio);
        }

        public static void PushFont(global::DearImguiSharp.ImFont font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.PushFont(__arg0);
        }

        public static void PopFont()
        {
            __Internal.PopFont();
        }

        public static void PushStyleColorU32(int idx, uint col)
        {
            __Internal.PushStyleColorU32(idx, col);
        }

        public static void PushStyleColorVec4(int idx, global::DearImguiSharp.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg1 = col.__Instance;
            __Internal.PushStyleColorVec4(idx, __arg1);
        }

        public static void PopStyleColor(int count)
        {
            __Internal.PopStyleColor(count);
        }

        public static void PushStyleVarFloat(int idx, float val)
        {
            __Internal.PushStyleVarFloat(idx, val);
        }

        public static void PushStyleVarVec2(int idx, global::DearImguiSharp.ImVec2 val)
        {
            if (ReferenceEquals(val, null))
                throw new global::System.ArgumentNullException("val", "Cannot be null because it is passed by value.");
            var __arg1 = val.__Instance;
            __Internal.PushStyleVarVec2(idx, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void PopStyleVar(int count)
        {
            __Internal.PopStyleVar(count);
        }

        public static void PushAllowKeyboardFocus(bool allow_keyboard_focus)
        {
            __Internal.PushAllowKeyboardFocus(allow_keyboard_focus);
        }

        public static void PopAllowKeyboardFocus()
        {
            __Internal.PopAllowKeyboardFocus();
        }

        public static void PushButtonRepeat(bool repeat)
        {
            __Internal.PushButtonRepeat(repeat);
        }

        public static void PopButtonRepeat()
        {
            __Internal.PopButtonRepeat();
        }

        public static void PushItemWidth(float item_width)
        {
            __Internal.PushItemWidth(item_width);
        }

        public static void PopItemWidth()
        {
            __Internal.PopItemWidth();
        }

        public static void SetNextItemWidth(float item_width)
        {
            __Internal.SetNextItemWidth(item_width);
        }

        public static float CalcItemWidth()
        {
            var __ret = __Internal.CalcItemWidth();
            return __ret;
        }

        public static void PushTextWrapPos(float wrap_local_pos_x)
        {
            __Internal.PushTextWrapPos(wrap_local_pos_x);
        }

        public static void PopTextWrapPos()
        {
            __Internal.PopTextWrapPos();
        }

        public static global::DearImguiSharp.ImFont GetFont()
        {
            var __ret = __Internal.GetFont();
            var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static float GetFontSize()
        {
            var __ret = __Internal.GetFontSize();
            return __ret;
        }

        public static void GetFontTexUvWhitePixel(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetFontTexUvWhitePixel(__arg0);
        }

        public static uint GetColorU32Col(int idx, float alpha_mul)
        {
            var __ret = __Internal.GetColorU32Col(idx, alpha_mul);
            return __ret;
        }

        public static uint GetColorU32Vec4(global::DearImguiSharp.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            var __ret = __Internal.GetColorU32Vec4(__arg0);
            return __ret;
        }

        public static uint GetColorU32U32(uint col)
        {
            var __ret = __Internal.GetColorU32U32(col);
            return __ret;
        }

        public static global::DearImguiSharp.ImVec4 GetStyleColorVec4(int idx)
        {
            var __ret = __Internal.GetStyleColorVec4(idx);
            var __result0 = global::DearImguiSharp.ImVec4.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void Separator()
        {
            __Internal.Separator();
        }

        public static void SameLine(float offset_from_start_x, float spacing)
        {
            __Internal.SameLine(offset_from_start_x, spacing);
        }

        public static void NewLine()
        {
            __Internal.NewLine();
        }

        public static void Spacing()
        {
            __Internal.Spacing();
        }

        public static void Dummy(global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.Dummy(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void Indent(float indent_w)
        {
            __Internal.Indent(indent_w);
        }

        public static void Unindent(float indent_w)
        {
            __Internal.Unindent(indent_w);
        }

        public static void BeginGroup()
        {
            __Internal.BeginGroup();
        }

        public static void EndGroup()
        {
            __Internal.EndGroup();
        }

        public static void GetCursorPos(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorPos(__arg0);
        }

        public static float GetCursorPosX()
        {
            var __ret = __Internal.GetCursorPosX();
            return __ret;
        }

        public static float GetCursorPosY()
        {
            var __ret = __Internal.GetCursorPosY();
            return __ret;
        }

        public static void SetCursorPos(global::DearImguiSharp.ImVec2 local_pos)
        {
            if (ReferenceEquals(local_pos, null))
                throw new global::System.ArgumentNullException("local_pos", "Cannot be null because it is passed by value.");
            var __arg0 = local_pos.__Instance;
            __Internal.SetCursorPos(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void SetCursorPosX(float local_x)
        {
            __Internal.SetCursorPosX(local_x);
        }

        public static void SetCursorPosY(float local_y)
        {
            __Internal.SetCursorPosY(local_y);
        }

        public static void GetCursorStartPos(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorStartPos(__arg0);
        }

        public static void GetCursorScreenPos(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorScreenPos(__arg0);
        }

        public static void SetCursorScreenPos(global::DearImguiSharp.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.SetCursorScreenPos(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void AlignTextToFramePadding()
        {
            __Internal.AlignTextToFramePadding();
        }

        public static float GetTextLineHeight()
        {
            var __ret = __Internal.GetTextLineHeight();
            return __ret;
        }

        public static float GetTextLineHeightWithSpacing()
        {
            var __ret = __Internal.GetTextLineHeightWithSpacing();
            return __ret;
        }

        public static float GetFrameHeight()
        {
            var __ret = __Internal.GetFrameHeight();
            return __ret;
        }

        public static float GetFrameHeightWithSpacing()
        {
            var __ret = __Internal.GetFrameHeightWithSpacing();
            return __ret;
        }

        public static void PushIDStr(string str_id)
        {
            __Internal.PushIDStr(str_id);
        }

        public static void PushIDStrStr(string str_id_begin, string str_id_end)
        {
            __Internal.PushIDStrStr(str_id_begin, str_id_end);
        }

        public static void PushIDPtr(__IntPtr ptr_id)
        {
            __Internal.PushIDPtr(ptr_id);
        }

        public static void PushIDInt(int int_id)
        {
            __Internal.PushIDInt(int_id);
        }

        public static void PopID()
        {
            __Internal.PopID();
        }

        public static uint GetIDStr(string str_id)
        {
            var __ret = __Internal.GetIDStr(str_id);
            return __ret;
        }

        public static uint GetIDStrStr(string str_id_begin, string str_id_end)
        {
            var __ret = __Internal.GetIDStrStr(str_id_begin, str_id_end);
            return __ret;
        }

        public static uint GetIDPtr(__IntPtr ptr_id)
        {
            var __ret = __Internal.GetIDPtr(ptr_id);
            return __ret;
        }

        public static void TextUnformatted(string text, string text_end)
        {
            __Internal.TextUnformatted(text, text_end);
        }

        public static void Text(string fmt)
        {
            __Internal.Text(fmt);
        }

        public static void TextColored(global::DearImguiSharp.ImVec4 col, string fmt)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            __Internal.TextColored(__arg0, fmt);
        }

        public static void TextDisabled(string fmt)
        {
            __Internal.TextDisabled(fmt);
        }

        public static void TextWrapped(string fmt)
        {
            __Internal.TextWrapped(fmt);
        }

        public static void LabelText(string label, string fmt)
        {
            __Internal.LabelText(label, fmt);
        }

        public static void BulletText(string fmt)
        {
            __Internal.BulletText(fmt);
        }

        public static bool Button(string label, global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.Button(label, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool SmallButton(string label)
        {
            var __ret = __Internal.SmallButton(label);
            return __ret;
        }

        public static bool InvisibleButton(string str_id, global::DearImguiSharp.ImVec2 size, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.InvisibleButton(str_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, flags);
            return __ret;
        }

        public static bool ArrowButton(string str_id, int dir)
        {
            var __ret = __Internal.ArrowButton(str_id, dir);
            return __ret;
        }

        public static void Image(__IntPtr user_texture_id, global::DearImguiSharp.ImVec2 size, global::DearImguiSharp.ImVec2 uv0, global::DearImguiSharp.ImVec2 uv1, global::DearImguiSharp.ImVec4 tint_col, global::DearImguiSharp.ImVec4 border_col)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(uv0, null))
                throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is passed by value.");
            var __arg2 = uv0.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg3 = uv1.__Instance;
            if (ReferenceEquals(tint_col, null))
                throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is passed by value.");
            var __arg4 = tint_col.__Instance;
            if (ReferenceEquals(border_col, null))
                throw new global::System.ArgumentNullException("border_col", "Cannot be null because it is passed by value.");
            var __arg5 = border_col.__Instance;
            __Internal.Image(user_texture_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, __arg4, __arg5);
        }

        public static bool ImageButton(__IntPtr user_texture_id, global::DearImguiSharp.ImVec2 size, global::DearImguiSharp.ImVec2 uv0, global::DearImguiSharp.ImVec2 uv1, int frame_padding, global::DearImguiSharp.ImVec4 bg_col, global::DearImguiSharp.ImVec4 tint_col)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(uv0, null))
                throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is passed by value.");
            var __arg2 = uv0.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg3 = uv1.__Instance;
            if (ReferenceEquals(bg_col, null))
                throw new global::System.ArgumentNullException("bg_col", "Cannot be null because it is passed by value.");
            var __arg5 = bg_col.__Instance;
            if (ReferenceEquals(tint_col, null))
                throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is passed by value.");
            var __arg6 = tint_col.__Instance;
            var __ret = __Internal.ImageButton(user_texture_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, frame_padding, __arg5, __arg6);
            return __ret;
        }

        public static bool Checkbox(string label, ref bool v)
        {
            fixed (bool* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.Checkbox(label, __arg1);
                return __ret;
            }
        }

        public static bool CheckboxFlagsIntPtr(string label, ref int flags, int flags_value)
        {
            fixed (int* __flags1 = &flags)
            {
                var __arg1 = __flags1;
                var __ret = __Internal.CheckboxFlagsIntPtr(label, __arg1, flags_value);
                return __ret;
            }
        }

        public static bool CheckboxFlagsUintPtr(string label, ref uint flags, uint flags_value)
        {
            fixed (uint* __flags1 = &flags)
            {
                var __arg1 = __flags1;
                var __ret = __Internal.CheckboxFlagsUintPtr(label, __arg1, flags_value);
                return __ret;
            }
        }

        public static bool RadioButtonBool(string label, bool active)
        {
            var __ret = __Internal.RadioButtonBool(label, active);
            return __ret;
        }

        public static bool RadioButtonIntPtr(string label, ref int v, int v_button)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.RadioButtonIntPtr(label, __arg1, v_button);
                return __ret;
            }
        }

        public static void ProgressBar(float fraction, global::DearImguiSharp.ImVec2 size_arg, string overlay)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg1 = size_arg.__Instance;
            __Internal.ProgressBar(fraction, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, overlay);
        }

        public static void Bullet()
        {
            __Internal.Bullet();
        }

        public static bool BeginCombo(string label, string preview_value, int flags)
        {
            var __ret = __Internal.BeginCombo(label, preview_value, flags);
            return __ret;
        }

        public static void EndCombo()
        {
            __Internal.EndCombo();
        }

        public static bool ComboStr_arr(string label, ref int current_item, string[] items, int items_count, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ComboStr_arr(label, __arg1, items, items_count, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool ComboStr(string label, ref int current_item, string items_separated_by_zeros, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ComboStr(label, __arg1, items_separated_by_zeros, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool ComboFnBoolPtr(string label, ref int current_item, global::DearImguiSharp.Delegates.Func_bool___IntPtr_int_sbytePtrPtr items_getter, __IntPtr data, int items_count, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __arg2 = items_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(items_getter);
                var __ret = __Internal.ComboFnBoolPtr(label, __arg1, __arg2, data, items_count, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool DragFloat(string label, ref float v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.DragFloat(label, __arg1, v_speed, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool DragFloat2(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat2(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragFloat3(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat3(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragFloat4(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat4(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragFloatRange2(string label, ref float v_current_min, ref float v_current_max, float v_speed, float v_min, float v_max, string format, string format_max, int flags)
        {
            fixed (float* __v_current_min1 = &v_current_min)
            {
                var __arg1 = __v_current_min1;
                fixed (float* __v_current_max2 = &v_current_max)
                {
                    var __arg2 = __v_current_max2;
                    var __ret = __Internal.DragFloatRange2(label, __arg1, __arg2, v_speed, v_min, v_max, format, format_max, flags);
                    return __ret;
                }
            }
        }

        public static bool DragInt(string label, ref int v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.DragInt(label, __arg1, v_speed, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool DragInt2(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt2(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragInt3(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt3(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragInt4(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt4(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragIntRange2(string label, ref int v_current_min, ref int v_current_max, float v_speed, int v_min, int v_max, string format, string format_max, int flags)
        {
            fixed (int* __v_current_min1 = &v_current_min)
            {
                var __arg1 = __v_current_min1;
                fixed (int* __v_current_max2 = &v_current_max)
                {
                    var __arg2 = __v_current_max2;
                    var __ret = __Internal.DragIntRange2(label, __arg1, __arg2, v_speed, v_min, v_max, format, format_max, flags);
                    return __ret;
                }
            }
        }

        public static bool DragScalar(string label, int data_type, __IntPtr p_data, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.DragScalar(label, data_type, p_data, v_speed, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool DragScalarN(string label, int data_type, __IntPtr p_data, int components, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.DragScalarN(label, data_type, p_data, components, v_speed, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool SliderFloat(string label, ref float v, float v_min, float v_max, string format, int flags)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.SliderFloat(label, __arg1, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool SliderFloat2(string label, float[] v, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat2(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderFloat3(string label, float[] v, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat3(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderFloat4(string label, float[] v, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat4(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderAngle(string label, ref float v_rad, float v_degrees_min, float v_degrees_max, string format, int flags)
        {
            fixed (float* __v_rad1 = &v_rad)
            {
                var __arg1 = __v_rad1;
                var __ret = __Internal.SliderAngle(label, __arg1, v_degrees_min, v_degrees_max, format, flags);
                return __ret;
            }
        }

        public static bool SliderInt(string label, ref int v, int v_min, int v_max, string format, int flags)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.SliderInt(label, __arg1, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool SliderInt2(string label, int[] v, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt2(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderInt3(string label, int[] v, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt3(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderInt4(string label, int[] v, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt4(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderScalar(string label, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.SliderScalar(label, data_type, p_data, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool SliderScalarN(string label, int data_type, __IntPtr p_data, int components, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.SliderScalarN(label, data_type, p_data, components, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool VSliderFloat(string label, global::DearImguiSharp.ImVec2 size, ref float v, float v_min, float v_max, string format, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            fixed (float* __v2 = &v)
            {
                var __arg2 = __v2;
                var __ret = __Internal.VSliderFloat(label, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, __arg2, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool VSliderInt(string label, global::DearImguiSharp.ImVec2 size, ref int v, int v_min, int v_max, string format, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            fixed (int* __v2 = &v)
            {
                var __arg2 = __v2;
                var __ret = __Internal.VSliderInt(label, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, __arg2, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool VSliderScalar(string label, global::DearImguiSharp.ImVec2 size, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.VSliderScalar(label, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, data_type, p_data, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool InputText(string label, sbyte* buf, IntPtr buf_size, int flags, global::DearImguiSharp.ImGuiInputTextCallback callback, __IntPtr user_data)
        {
            var __arg4 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputText(label, buf, buf_size, flags, __arg4, user_data);
            return __ret;
        }

        public static bool InputTextMultiline(string label, sbyte* buf, IntPtr buf_size, global::DearImguiSharp.ImVec2 size, int flags, global::DearImguiSharp.ImGuiInputTextCallback callback, __IntPtr user_data)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __arg5 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputTextMultiline(label, buf, buf_size, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, flags, __arg5, user_data);
            return __ret;
        }

        public static bool InputTextWithHint(string label, string hint, sbyte* buf, IntPtr buf_size, int flags, global::DearImguiSharp.ImGuiInputTextCallback callback, __IntPtr user_data)
        {
            var __arg5 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputTextWithHint(label, hint, buf, buf_size, flags, __arg5, user_data);
            return __ret;
        }

        public static bool InputFloat(string label, ref float v, float step, float step_fast, string format, int flags)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputFloat(label, __arg1, step, step_fast, format, flags);
                return __ret;
            }
        }

        public static bool InputFloat2(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat2(label, v, format, flags);
            return __ret;
        }

        public static bool InputFloat3(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat3(label, v, format, flags);
            return __ret;
        }

        public static bool InputFloat4(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat4(label, v, format, flags);
            return __ret;
        }

        public static bool InputInt(string label, ref int v, int step, int step_fast, int flags)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputInt(label, __arg1, step, step_fast, flags);
                return __ret;
            }
        }

        public static bool InputInt2(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt2(label, v, flags);
            return __ret;
        }

        public static bool InputInt3(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt3(label, v, flags);
            return __ret;
        }

        public static bool InputInt4(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt4(label, v, flags);
            return __ret;
        }

        public static bool InputDouble(string label, ref double v, double step, double step_fast, string format, int flags)
        {
            fixed (double* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputDouble(label, __arg1, step, step_fast, format, flags);
                return __ret;
            }
        }

        public static bool InputScalar(string label, int data_type, __IntPtr p_data, __IntPtr p_step, __IntPtr p_step_fast, string format, int flags)
        {
            var __ret = __Internal.InputScalar(label, data_type, p_data, p_step, p_step_fast, format, flags);
            return __ret;
        }

        public static bool InputScalarN(string label, int data_type, __IntPtr p_data, int components, __IntPtr p_step, __IntPtr p_step_fast, string format, int flags)
        {
            var __ret = __Internal.InputScalarN(label, data_type, p_data, components, p_step, p_step_fast, format, flags);
            return __ret;
        }

        public static bool ColorEdit3(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 3)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorEdit3(label, col, flags);
            return __ret;
        }

        public static bool ColorEdit4(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 4)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorEdit4(label, col, flags);
            return __ret;
        }

        public static bool ColorPicker3(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 3)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorPicker3(label, col, flags);
            return __ret;
        }

        public static bool ColorPicker4(string label, float[] col, int flags, ref float ref_col)
        {
            if (col == null || col.Length != 4)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            fixed (float* __ref_col3 = &ref_col)
            {
                var __arg3 = __ref_col3;
                var __ret = __Internal.ColorPicker4(label, col, flags, __arg3);
                return __ret;
            }
        }

        public static bool ColorButton(string desc_id, global::DearImguiSharp.ImVec4 col, int flags, global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg1 = col.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __ret = __Internal.ColorButton(desc_id, __arg1, flags, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3);
            return __ret;
        }

        public static void SetColorEditOptions(int flags)
        {
            __Internal.SetColorEditOptions(flags);
        }

        public static bool TreeNodeStr(string label)
        {
            var __ret = __Internal.TreeNodeStr(label);
            return __ret;
        }

        public static bool TreeNodeStrStr(string str_id, string fmt)
        {
            var __ret = __Internal.TreeNodeStrStr(str_id, fmt);
            return __ret;
        }

        public static bool TreeNodePtr(__IntPtr ptr_id, string fmt)
        {
            var __ret = __Internal.TreeNodePtr(ptr_id, fmt);
            return __ret;
        }

        public static bool TreeNodeExStr(string label, int flags)
        {
            var __ret = __Internal.TreeNodeExStr(label, flags);
            return __ret;
        }

        public static bool TreeNodeExStrStr(string str_id, int flags, string fmt)
        {
            var __ret = __Internal.TreeNodeExStrStr(str_id, flags, fmt);
            return __ret;
        }

        public static bool TreeNodeExPtr(__IntPtr ptr_id, int flags, string fmt)
        {
            var __ret = __Internal.TreeNodeExPtr(ptr_id, flags, fmt);
            return __ret;
        }

        public static void TreePushStr(string str_id)
        {
            __Internal.TreePushStr(str_id);
        }

        public static void TreePushPtr(__IntPtr ptr_id)
        {
            __Internal.TreePushPtr(ptr_id);
        }

        public static void TreePop()
        {
            __Internal.TreePop();
        }

        public static float GetTreeNodeToLabelSpacing()
        {
            var __ret = __Internal.GetTreeNodeToLabelSpacing();
            return __ret;
        }

        public static bool CollapsingHeaderTreeNodeFlags(string label, int flags)
        {
            var __ret = __Internal.CollapsingHeaderTreeNodeFlags(label, flags);
            return __ret;
        }

        public static bool CollapsingHeaderBoolPtr(string label, ref bool p_visible, int flags)
        {
            fixed (bool* __p_visible1 = &p_visible)
            {
                var __arg1 = __p_visible1;
                var __ret = __Internal.CollapsingHeaderBoolPtr(label, __arg1, flags);
                return __ret;
            }
        }

        public static void SetNextItemOpen(bool is_open, int cond)
        {
            __Internal.SetNextItemOpen(is_open, cond);
        }

        public static bool SelectableBool(string label, bool selected, int flags, global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __ret = __Internal.SelectableBool(label, selected, flags, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3);
            return __ret;
        }

        public static bool SelectableBoolPtr(string label, ref bool p_selected, int flags, global::DearImguiSharp.ImVec2 size)
        {
            fixed (bool* __p_selected1 = &p_selected)
            {
                var __arg1 = __p_selected1;
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
                var __arg3 = size.__Instance;
                var __ret = __Internal.SelectableBoolPtr(label, __arg1, flags, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3);
                return __ret;
            }
        }

        public static bool BeginListBox(string label, global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginListBox(label, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static void EndListBox()
        {
            __Internal.EndListBox();
        }

        public static bool ListBoxStr_arr(string label, ref int current_item, string[] items, int items_count, int height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ListBoxStr_arr(label, __arg1, items, items_count, height_in_items);
                return __ret;
            }
        }

        public static bool ListBoxFnBoolPtr(string label, ref int current_item, global::DearImguiSharp.Delegates.Func_bool___IntPtr_int_sbytePtrPtr items_getter, __IntPtr data, int items_count, int height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __arg2 = items_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(items_getter);
                var __ret = __Internal.ListBoxFnBoolPtr(label, __arg1, __arg2, data, items_count, height_in_items);
                return __ret;
            }
        }

        public static void PlotLinesFloatPtr(string label, ref float values, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2 graph_size, int stride)
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (ReferenceEquals(graph_size, null))
                    throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                var __arg7 = graph_size.__Instance;
                __Internal.PlotLinesFloatPtr(label, __arg1, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::DearImguiSharp.ImVec2.__Internal*) __arg7, stride);
            }
        }

        public static void PlotLinesFnFloatPtr(string label, global::DearImguiSharp.Delegates.Func_float___IntPtr_int values_getter, __IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2 graph_size)
        {
            var __arg1 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
            if (ReferenceEquals(graph_size, null))
                throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
            var __arg8 = graph_size.__Instance;
            __Internal.PlotLinesFnFloatPtr(label, __arg1, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::DearImguiSharp.ImVec2.__Internal*) __arg8);
        }

        public static void PlotHistogramFloatPtr(string label, ref float values, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2 graph_size, int stride)
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (ReferenceEquals(graph_size, null))
                    throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                var __arg7 = graph_size.__Instance;
                __Internal.PlotHistogramFloatPtr(label, __arg1, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::DearImguiSharp.ImVec2.__Internal*) __arg7, stride);
            }
        }

        public static void PlotHistogramFnFloatPtr(string label, global::DearImguiSharp.Delegates.Func_float___IntPtr_int values_getter, __IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2 graph_size)
        {
            var __arg1 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
            if (ReferenceEquals(graph_size, null))
                throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
            var __arg8 = graph_size.__Instance;
            __Internal.PlotHistogramFnFloatPtr(label, __arg1, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::DearImguiSharp.ImVec2.__Internal*) __arg8);
        }

        public static void ValueBool(string prefix, bool b)
        {
            __Internal.ValueBool(prefix, b);
        }

        public static void ValueInt(string prefix, int v)
        {
            __Internal.ValueInt(prefix, v);
        }

        public static void ValueUint(string prefix, uint v)
        {
            __Internal.ValueUint(prefix, v);
        }

        public static void ValueFloat(string prefix, float v, string float_format)
        {
            __Internal.ValueFloat(prefix, v, float_format);
        }

        public static bool BeginMenuBar()
        {
            var __ret = __Internal.BeginMenuBar();
            return __ret;
        }

        public static void EndMenuBar()
        {
            __Internal.EndMenuBar();
        }

        public static bool BeginMainMenuBar()
        {
            var __ret = __Internal.BeginMainMenuBar();
            return __ret;
        }

        public static void EndMainMenuBar()
        {
            __Internal.EndMainMenuBar();
        }

        public static bool BeginMenu(string label, bool enabled)
        {
            var __ret = __Internal.BeginMenu(label, enabled);
            return __ret;
        }

        public static void EndMenu()
        {
            __Internal.EndMenu();
        }

        public static bool MenuItemBool(string label, string shortcut, bool selected, bool enabled)
        {
            var __ret = __Internal.MenuItemBool(label, shortcut, selected, enabled);
            return __ret;
        }

        public static bool MenuItemBoolPtr(string label, string shortcut, ref bool p_selected, bool enabled)
        {
            fixed (bool* __p_selected2 = &p_selected)
            {
                var __arg2 = __p_selected2;
                var __ret = __Internal.MenuItemBoolPtr(label, shortcut, __arg2, enabled);
                return __ret;
            }
        }

        public static void BeginTooltip()
        {
            __Internal.BeginTooltip();
        }

        public static void EndTooltip()
        {
            __Internal.EndTooltip();
        }

        public static void SetTooltip(string fmt)
        {
            __Internal.SetTooltip(fmt);
        }

        public static bool BeginPopup(string str_id, int flags)
        {
            var __ret = __Internal.BeginPopup(str_id, flags);
            return __ret;
        }

        public static bool BeginPopupModal(string name, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.BeginPopupModal(name, __arg1, flags);
                return __ret;
            }
        }

        public static void EndPopup()
        {
            __Internal.EndPopup();
        }

        public static void OpenPopup(string str_id, int popup_flags)
        {
            __Internal.OpenPopup(str_id, popup_flags);
        }

        public static void OpenPopupOnItemClick(string str_id, int popup_flags)
        {
            __Internal.OpenPopupOnItemClick(str_id, popup_flags);
        }

        public static void CloseCurrentPopup()
        {
            __Internal.CloseCurrentPopup();
        }

        public static bool BeginPopupContextItem(string str_id, int popup_flags)
        {
            var __ret = __Internal.BeginPopupContextItem(str_id, popup_flags);
            return __ret;
        }

        public static bool BeginPopupContextWindow(string str_id, int popup_flags)
        {
            var __ret = __Internal.BeginPopupContextWindow(str_id, popup_flags);
            return __ret;
        }

        public static bool BeginPopupContextVoid(string str_id, int popup_flags)
        {
            var __ret = __Internal.BeginPopupContextVoid(str_id, popup_flags);
            return __ret;
        }

        public static bool IsPopupOpen(string str_id, int flags)
        {
            var __ret = __Internal.IsPopupOpen(str_id, flags);
            return __ret;
        }

        public static bool BeginTable(string str_id, int column, int flags, global::DearImguiSharp.ImVec2 outer_size, float inner_width)
        {
            if (ReferenceEquals(outer_size, null))
                throw new global::System.ArgumentNullException("outer_size", "Cannot be null because it is passed by value.");
            var __arg3 = outer_size.__Instance;
            var __ret = __Internal.BeginTable(str_id, column, flags, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, inner_width);
            return __ret;
        }

        public static void EndTable()
        {
            __Internal.EndTable();
        }

        public static void TableNextRow(int row_flags, float min_row_height)
        {
            __Internal.TableNextRow(row_flags, min_row_height);
        }

        public static bool TableNextColumn()
        {
            var __ret = __Internal.TableNextColumn();
            return __ret;
        }

        public static bool TableSetColumnIndex(int column_n)
        {
            var __ret = __Internal.TableSetColumnIndex(column_n);
            return __ret;
        }

        public static void TableSetupColumn(string label, int flags, float init_width_or_weight, uint user_id)
        {
            __Internal.TableSetupColumn(label, flags, init_width_or_weight, user_id);
        }

        public static void TableSetupScrollFreeze(int cols, int rows)
        {
            __Internal.TableSetupScrollFreeze(cols, rows);
        }

        public static void TableHeadersRow()
        {
            __Internal.TableHeadersRow();
        }

        public static void TableHeader(string label)
        {
            __Internal.TableHeader(label);
        }

        public static global::DearImguiSharp.ImGuiTableSortSpecs TableGetSortSpecs()
        {
            var __ret = __Internal.TableGetSortSpecs();
            var __result0 = global::DearImguiSharp.ImGuiTableSortSpecs.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static int TableGetColumnCount()
        {
            var __ret = __Internal.TableGetColumnCount();
            return __ret;
        }

        public static int TableGetColumnIndex()
        {
            var __ret = __Internal.TableGetColumnIndex();
            return __ret;
        }

        public static int TableGetRowIndex()
        {
            var __ret = __Internal.TableGetRowIndex();
            return __ret;
        }

        public static string TableGetColumnName(int column_n)
        {
            var __ret = __Internal.TableGetColumnName(column_n);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int TableGetColumnFlags(int column_n)
        {
            var __ret = __Internal.TableGetColumnFlags(column_n);
            return __ret;
        }

        public static void TableSetBgColor(int target, uint color, int column_n)
        {
            __Internal.TableSetBgColor(target, color, column_n);
        }

        public static void Columns(int count, string id, bool border)
        {
            __Internal.Columns(count, id, border);
        }

        public static void NextColumn()
        {
            __Internal.NextColumn();
        }

        public static int GetColumnIndex()
        {
            var __ret = __Internal.GetColumnIndex();
            return __ret;
        }

        public static float GetColumnWidth(int column_index)
        {
            var __ret = __Internal.GetColumnWidth(column_index);
            return __ret;
        }

        public static void SetColumnWidth(int column_index, float width)
        {
            __Internal.SetColumnWidth(column_index, width);
        }

        public static float GetColumnOffset(int column_index)
        {
            var __ret = __Internal.GetColumnOffset(column_index);
            return __ret;
        }

        public static void SetColumnOffset(int column_index, float offset_x)
        {
            __Internal.SetColumnOffset(column_index, offset_x);
        }

        public static int GetColumnsCount()
        {
            var __ret = __Internal.GetColumnsCount();
            return __ret;
        }

        public static bool BeginTabBar(string str_id, int flags)
        {
            var __ret = __Internal.BeginTabBar(str_id, flags);
            return __ret;
        }

        public static void EndTabBar()
        {
            __Internal.EndTabBar();
        }

        public static bool BeginTabItem(string label, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.BeginTabItem(label, __arg1, flags);
                return __ret;
            }
        }

        public static void EndTabItem()
        {
            __Internal.EndTabItem();
        }

        public static bool TabItemButton(string label, int flags)
        {
            var __ret = __Internal.TabItemButton(label, flags);
            return __ret;
        }

        public static void SetTabItemClosed(string tab_or_docked_window_label)
        {
            __Internal.SetTabItemClosed(tab_or_docked_window_label);
        }

        public static void LogToTTY(int auto_open_depth)
        {
            __Internal.LogToTTY(auto_open_depth);
        }

        public static void LogToFile(int auto_open_depth, string filename)
        {
            __Internal.LogToFile(auto_open_depth, filename);
        }

        public static void LogToClipboard(int auto_open_depth)
        {
            __Internal.LogToClipboard(auto_open_depth);
        }

        public static void LogFinish()
        {
            __Internal.LogFinish();
        }

        public static void LogButtons()
        {
            __Internal.LogButtons();
        }

        public static bool BeginDragDropSource(int flags)
        {
            var __ret = __Internal.BeginDragDropSource(flags);
            return __ret;
        }

        public static bool SetDragDropPayload(string type, __IntPtr data, IntPtr sz, int cond)
        {
            var __ret = __Internal.SetDragDropPayload(type, data, sz, cond);
            return __ret;
        }

        public static void EndDragDropSource()
        {
            __Internal.EndDragDropSource();
        }

        public static bool BeginDragDropTarget()
        {
            var __ret = __Internal.BeginDragDropTarget();
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiPayload AcceptDragDropPayload(string type, int flags)
        {
            var __ret = __Internal.AcceptDragDropPayload(type, flags);
            var __result0 = global::DearImguiSharp.ImGuiPayload.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void EndDragDropTarget()
        {
            __Internal.EndDragDropTarget();
        }

        public static global::DearImguiSharp.ImGuiPayload GetDragDropPayload()
        {
            var __ret = __Internal.GetDragDropPayload();
            var __result0 = global::DearImguiSharp.ImGuiPayload.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void PushClipRect(global::DearImguiSharp.ImVec2 clip_rect_min, global::DearImguiSharp.ImVec2 clip_rect_max, bool intersect_with_current_clip_rect)
        {
            if (ReferenceEquals(clip_rect_min, null))
                throw new global::System.ArgumentNullException("clip_rect_min", "Cannot be null because it is passed by value.");
            var __arg0 = clip_rect_min.__Instance;
            if (ReferenceEquals(clip_rect_max, null))
                throw new global::System.ArgumentNullException("clip_rect_max", "Cannot be null because it is passed by value.");
            var __arg1 = clip_rect_max.__Instance;
            __Internal.PushClipRect(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, intersect_with_current_clip_rect);
        }

        public static void PopClipRect()
        {
            __Internal.PopClipRect();
        }

        public static void SetItemDefaultFocus()
        {
            __Internal.SetItemDefaultFocus();
        }

        public static void SetKeyboardFocusHere(int offset)
        {
            __Internal.SetKeyboardFocusHere(offset);
        }

        public static bool IsItemHovered(int flags)
        {
            var __ret = __Internal.IsItemHovered(flags);
            return __ret;
        }

        public static bool IsItemActive()
        {
            var __ret = __Internal.IsItemActive();
            return __ret;
        }

        public static bool IsItemFocused()
        {
            var __ret = __Internal.IsItemFocused();
            return __ret;
        }

        public static bool IsItemClicked(int mouse_button)
        {
            var __ret = __Internal.IsItemClicked(mouse_button);
            return __ret;
        }

        public static bool IsItemVisible()
        {
            var __ret = __Internal.IsItemVisible();
            return __ret;
        }

        public static bool IsItemEdited()
        {
            var __ret = __Internal.IsItemEdited();
            return __ret;
        }

        public static bool IsItemActivated()
        {
            var __ret = __Internal.IsItemActivated();
            return __ret;
        }

        public static bool IsItemDeactivated()
        {
            var __ret = __Internal.IsItemDeactivated();
            return __ret;
        }

        public static bool IsItemDeactivatedAfterEdit()
        {
            var __ret = __Internal.IsItemDeactivatedAfterEdit();
            return __ret;
        }

        public static bool IsItemToggledOpen()
        {
            var __ret = __Internal.IsItemToggledOpen();
            return __ret;
        }

        public static bool IsAnyItemHovered()
        {
            var __ret = __Internal.IsAnyItemHovered();
            return __ret;
        }

        public static bool IsAnyItemActive()
        {
            var __ret = __Internal.IsAnyItemActive();
            return __ret;
        }

        public static bool IsAnyItemFocused()
        {
            var __ret = __Internal.IsAnyItemFocused();
            return __ret;
        }

        public static void GetItemRectMin(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectMin(__arg0);
        }

        public static void GetItemRectMax(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectMax(__arg0);
        }

        public static void GetItemRectSize(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectSize(__arg0);
        }

        public static void SetItemAllowOverlap()
        {
            __Internal.SetItemAllowOverlap();
        }

        public static global::DearImguiSharp.ImGuiViewport GetMainViewport()
        {
            var __ret = __Internal.GetMainViewport();
            var __result0 = global::DearImguiSharp.ImGuiViewport.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool IsRectVisibleNil(global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            var __ret = __Internal.IsRectVisibleNil(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
            return __ret;
        }

        public static bool IsRectVisibleVec2(global::DearImguiSharp.ImVec2 rect_min, global::DearImguiSharp.ImVec2 rect_max)
        {
            if (ReferenceEquals(rect_min, null))
                throw new global::System.ArgumentNullException("rect_min", "Cannot be null because it is passed by value.");
            var __arg0 = rect_min.__Instance;
            if (ReferenceEquals(rect_max, null))
                throw new global::System.ArgumentNullException("rect_max", "Cannot be null because it is passed by value.");
            var __arg1 = rect_max.__Instance;
            var __ret = __Internal.IsRectVisibleVec2(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static double GetTime()
        {
            var __ret = __Internal.GetTime();
            return __ret;
        }

        public static int GetFrameCount()
        {
            var __ret = __Internal.GetFrameCount();
            return __ret;
        }

        public static global::DearImguiSharp.ImDrawList GetBackgroundDrawList()
        {
            var __ret = __Internal.GetBackgroundDrawList();
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImDrawList GetForegroundDrawList()
        {
            var __ret = __Internal.GetForegroundDrawList();
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImDrawListSharedData GetDrawListSharedData()
        {
            var __ret = __Internal.GetDrawListSharedData();
            var __result0 = global::DearImguiSharp.ImDrawListSharedData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static string GetStyleColorName(int idx)
        {
            var __ret = __Internal.GetStyleColorName(idx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void SetStateStorage(global::DearImguiSharp.ImGuiStorage storage)
        {
            var __arg0 = storage is null ? __IntPtr.Zero : storage.__Instance;
            __Internal.SetStateStorage(__arg0);
        }

        public static global::DearImguiSharp.ImGuiStorage GetStateStorage()
        {
            var __ret = __Internal.GetStateStorage();
            var __result0 = global::DearImguiSharp.ImGuiStorage.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void CalcListClipping(int items_count, float items_height, ref int out_items_display_start, ref int out_items_display_end)
        {
            fixed (int* __out_items_display_start2 = &out_items_display_start)
            {
                var __arg2 = __out_items_display_start2;
                fixed (int* __out_items_display_end3 = &out_items_display_end)
                {
                    var __arg3 = __out_items_display_end3;
                    __Internal.CalcListClipping(items_count, items_height, __arg2, __arg3);
                }
            }
        }

        public static bool BeginChildFrame(uint id, global::DearImguiSharp.ImVec2 size, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildFrame(id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, flags);
            return __ret;
        }

        public static void EndChildFrame()
        {
            __Internal.EndChildFrame();
        }

        public static void CalcTextSize(global::DearImguiSharp.ImVec2 pOut, string text, string text_end, bool hide_text_after_double_hash, float wrap_width)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.CalcTextSize(__arg0, text, text_end, hide_text_after_double_hash, wrap_width);
        }

        public static void ColorConvertU32ToFloat4(global::DearImguiSharp.ImVec4 pOut, uint @in)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.ColorConvertU32ToFloat4(__arg0, @in);
        }

        public static uint ColorConvertFloat4ToU32(global::DearImguiSharp.ImVec4 @in)
        {
            if (ReferenceEquals(@in, null))
                throw new global::System.ArgumentNullException("@in", "Cannot be null because it is passed by value.");
            var __arg0 = @in.__Instance;
            var __ret = __Internal.ColorConvertFloat4ToU32(__arg0);
            return __ret;
        }

        public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float out_h, ref float out_s, ref float out_v)
        {
            fixed (float* __out_h3 = &out_h)
            {
                var __arg3 = __out_h3;
                fixed (float* __out_s4 = &out_s)
                {
                    var __arg4 = __out_s4;
                    fixed (float* __out_v5 = &out_v)
                    {
                        var __arg5 = __out_v5;
                        __Internal.ColorConvertRGBtoHSV(r, g, b, __arg3, __arg4, __arg5);
                    }
                }
            }
        }

        public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float out_r, ref float out_g, ref float out_b)
        {
            fixed (float* __out_r3 = &out_r)
            {
                var __arg3 = __out_r3;
                fixed (float* __out_g4 = &out_g)
                {
                    var __arg4 = __out_g4;
                    fixed (float* __out_b5 = &out_b)
                    {
                        var __arg5 = __out_b5;
                        __Internal.ColorConvertHSVtoRGB(h, s, v, __arg3, __arg4, __arg5);
                    }
                }
            }
        }

        public static int GetKeyIndex(int imgui_key)
        {
            var __ret = __Internal.GetKeyIndex(imgui_key);
            return __ret;
        }

        public static bool IsKeyDown(int user_key_index)
        {
            var __ret = __Internal.IsKeyDown(user_key_index);
            return __ret;
        }

        public static bool IsKeyPressed(int user_key_index, bool repeat)
        {
            var __ret = __Internal.IsKeyPressed(user_key_index, repeat);
            return __ret;
        }

        public static bool IsKeyReleased(int user_key_index)
        {
            var __ret = __Internal.IsKeyReleased(user_key_index);
            return __ret;
        }

        public static int GetKeyPressedAmount(int key_index, float repeat_delay, float rate)
        {
            var __ret = __Internal.GetKeyPressedAmount(key_index, repeat_delay, rate);
            return __ret;
        }

        public static void CaptureKeyboardFromApp(bool want_capture_keyboard_value)
        {
            __Internal.CaptureKeyboardFromApp(want_capture_keyboard_value);
        }

        public static bool IsMouseDown(int button)
        {
            var __ret = __Internal.IsMouseDown(button);
            return __ret;
        }

        public static bool IsMouseClicked(int button, bool repeat)
        {
            var __ret = __Internal.IsMouseClicked(button, repeat);
            return __ret;
        }

        public static bool IsMouseReleased(int button)
        {
            var __ret = __Internal.IsMouseReleased(button);
            return __ret;
        }

        public static bool IsMouseDoubleClicked(int button)
        {
            var __ret = __Internal.IsMouseDoubleClicked(button);
            return __ret;
        }

        public static bool IsMouseHoveringRect(global::DearImguiSharp.ImVec2 r_min, global::DearImguiSharp.ImVec2 r_max, bool clip)
        {
            if (ReferenceEquals(r_min, null))
                throw new global::System.ArgumentNullException("r_min", "Cannot be null because it is passed by value.");
            var __arg0 = r_min.__Instance;
            if (ReferenceEquals(r_max, null))
                throw new global::System.ArgumentNullException("r_max", "Cannot be null because it is passed by value.");
            var __arg1 = r_max.__Instance;
            var __ret = __Internal.IsMouseHoveringRect(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, clip);
            return __ret;
        }

        public static bool IsMousePosValid(global::DearImguiSharp.ImVec2 mouse_pos)
        {
            var __arg0 = mouse_pos is null ? __IntPtr.Zero : mouse_pos.__Instance;
            var __ret = __Internal.IsMousePosValid(__arg0);
            return __ret;
        }

        public static bool IsAnyMouseDown()
        {
            var __ret = __Internal.IsAnyMouseDown();
            return __ret;
        }

        public static void GetMousePos(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetMousePos(__arg0);
        }

        public static void GetMousePosOnOpeningCurrentPopup(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetMousePosOnOpeningCurrentPopup(__arg0);
        }

        public static bool IsMouseDragging(int button, float lock_threshold)
        {
            var __ret = __Internal.IsMouseDragging(button, lock_threshold);
            return __ret;
        }

        public static void GetMouseDragDelta(global::DearImguiSharp.ImVec2 pOut, int button, float lock_threshold)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetMouseDragDelta(__arg0, button, lock_threshold);
        }

        public static void ResetMouseDragDelta(int button)
        {
            __Internal.ResetMouseDragDelta(button);
        }

        public static int GetMouseCursor()
        {
            var __ret = __Internal.GetMouseCursor();
            return __ret;
        }

        public static void SetMouseCursor(int cursor_type)
        {
            __Internal.SetMouseCursor(cursor_type);
        }

        public static void CaptureMouseFromApp(bool want_capture_mouse_value)
        {
            __Internal.CaptureMouseFromApp(want_capture_mouse_value);
        }

        public static string GetClipboardText()
        {
            var __ret = __Internal.GetClipboardText();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void SetClipboardText(string text)
        {
            __Internal.SetClipboardText(text);
        }

        public static void LoadIniSettingsFromDisk(string ini_filename)
        {
            __Internal.LoadIniSettingsFromDisk(ini_filename);
        }

        public static void LoadIniSettingsFromMemory(string ini_data, IntPtr ini_size)
        {
            __Internal.LoadIniSettingsFromMemory(ini_data, ini_size);
        }

        public static void SaveIniSettingsToDisk(string ini_filename)
        {
            __Internal.SaveIniSettingsToDisk(ini_filename);
        }

        public static string SaveIniSettingsToMemory(ref IntPtr out_ini_size)
        {
            fixed (IntPtr* __out_ini_size0 = &out_ini_size)
            {
                var __arg0 = __out_ini_size0;
                var __ret = __Internal.SaveIniSettingsToMemory(__arg0);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }
        }

        public static bool DebugCheckVersionAndDataLayout(string version_str, IntPtr sz_io, IntPtr sz_style, IntPtr sz_vec2, IntPtr sz_vec4, IntPtr sz_drawvert, IntPtr sz_drawidx)
        {
            var __ret = __Internal.DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert, sz_drawidx);
            return __ret;
        }

        public static void SetAllocatorFunctions(global::DearImguiSharp.Delegates.Func___IntPtr_IntPtr___IntPtr alloc_func, global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr free_func, __IntPtr user_data)
        {
            var __arg0 = alloc_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(alloc_func);
            var __arg1 = free_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(free_func);
            __Internal.SetAllocatorFunctions(__arg0, __arg1, user_data);
        }

        public static __IntPtr MemAlloc(IntPtr size)
        {
            var __ret = __Internal.MemAlloc(size);
            return __ret;
        }

        public static void MemFree(__IntPtr ptr)
        {
            __Internal.MemFree(ptr);
        }

        public static global::DearImguiSharp.ImGuiStyle ImGuiStyleImGuiStyle()
        {
            var __ret = __Internal.ImGuiStyleImGuiStyle();
            var __result0 = global::DearImguiSharp.ImGuiStyle.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStyle_destroy(global::DearImguiSharp.ImGuiStyle self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStyle_destroy(__arg0);
        }

        public static void ImGuiStyleScaleAllSizes(global::DearImguiSharp.ImGuiStyle self, float scale_factor)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStyleScaleAllSizes(__arg0, scale_factor);
        }

        public static void ImGuiIO_AddInputCharacter(global::DearImguiSharp.ImGuiIO self, uint c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddInputCharacter(__arg0, c);
        }

        public static void ImGuiIO_AddInputCharacterUTF16(global::DearImguiSharp.ImGuiIO self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddInputCharacterUTF16(__arg0, c);
        }

        public static void ImGuiIO_AddInputCharactersUTF8(global::DearImguiSharp.ImGuiIO self, string str)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddInputCharactersUTF8(__arg0, str);
        }

        public static void ImGuiIO_ClearInputCharacters(global::DearImguiSharp.ImGuiIO self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_ClearInputCharacters(__arg0);
        }

        public static global::DearImguiSharp.ImGuiIO ImGuiIO_ImGuiIO()
        {
            var __ret = __Internal.ImGuiIO_ImGuiIO();
            var __result0 = global::DearImguiSharp.ImGuiIO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiIO_destroy(global::DearImguiSharp.ImGuiIO self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiInputTextCallbackData ImGuiInputTextCallbackDataImGuiInputTextCallbackData()
        {
            var __ret = __Internal.ImGuiInputTextCallbackDataImGuiInputTextCallbackData();
            var __result0 = global::DearImguiSharp.ImGuiInputTextCallbackData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiInputTextCallbackData_destroy(global::DearImguiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackData_destroy(__arg0);
        }

        public static void ImGuiInputTextCallbackDataDeleteChars(global::DearImguiSharp.ImGuiInputTextCallbackData self, int pos, int bytes_count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataDeleteChars(__arg0, pos, bytes_count);
        }

        public static void ImGuiInputTextCallbackDataInsertChars(global::DearImguiSharp.ImGuiInputTextCallbackData self, int pos, string text, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataInsertChars(__arg0, pos, text, text_end);
        }

        public static void ImGuiInputTextCallbackDataSelectAll(global::DearImguiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataSelectAll(__arg0);
        }

        public static void ImGuiInputTextCallbackDataClearSelection(global::DearImguiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataClearSelection(__arg0);
        }

        public static bool ImGuiInputTextCallbackDataHasSelection(global::DearImguiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextCallbackDataHasSelection(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiPayload ImGuiPayloadImGuiPayload()
        {
            var __ret = __Internal.ImGuiPayloadImGuiPayload();
            var __result0 = global::DearImguiSharp.ImGuiPayload.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiPayload_destroy(global::DearImguiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPayload_destroy(__arg0);
        }

        public static void ImGuiPayloadClear(global::DearImguiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPayloadClear(__arg0);
        }

        public static bool ImGuiPayloadIsDataType(global::DearImguiSharp.ImGuiPayload self, string type)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsDataType(__arg0, type);
            return __ret;
        }

        public static bool ImGuiPayloadIsPreview(global::DearImguiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsPreview(__arg0);
            return __ret;
        }

        public static bool ImGuiPayloadIsDelivery(global::DearImguiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsDelivery(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiTableColumnSortSpecs ImGuiTableColumnSortSpecsImGuiTableColumnSortSpecs()
        {
            var __ret = __Internal.ImGuiTableColumnSortSpecsImGuiTableColumnSortSpecs();
            var __result0 = global::DearImguiSharp.ImGuiTableColumnSortSpecs.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableColumnSortSpecs_destroy(global::DearImguiSharp.ImGuiTableColumnSortSpecs self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableColumnSortSpecs_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTableSortSpecs ImGuiTableSortSpecsImGuiTableSortSpecs()
        {
            var __ret = __Internal.ImGuiTableSortSpecsImGuiTableSortSpecs();
            var __result0 = global::DearImguiSharp.ImGuiTableSortSpecs.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableSortSpecs_destroy(global::DearImguiSharp.ImGuiTableSortSpecs self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableSortSpecs_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiOnceUponAFrame ImGuiOnceUponAFrameImGuiOnceUponAFrame()
        {
            var __ret = __Internal.ImGuiOnceUponAFrameImGuiOnceUponAFrame();
            var __result0 = global::DearImguiSharp.ImGuiOnceUponAFrame.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiOnceUponAFrame_destroy(global::DearImguiSharp.ImGuiOnceUponAFrame self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiOnceUponAFrame_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTextFilter ImGuiTextFilterImGuiTextFilter(string default_filter)
        {
            var __ret = __Internal.ImGuiTextFilterImGuiTextFilter(default_filter);
            var __result0 = global::DearImguiSharp.ImGuiTextFilter.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTextFilter_destroy(global::DearImguiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilter_destroy(__arg0);
        }

        public static bool ImGuiTextFilterDraw(global::DearImguiSharp.ImGuiTextFilter self, string label, float width)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterDraw(__arg0, label, width);
            return __ret;
        }

        public static bool ImGuiTextFilterPassFilter(global::DearImguiSharp.ImGuiTextFilter self, string text, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterPassFilter(__arg0, text, text_end);
            return __ret;
        }

        public static void ImGuiTextFilterBuild(global::DearImguiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilterBuild(__arg0);
        }

        public static void ImGuiTextFilterClear(global::DearImguiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilterClear(__arg0);
        }

        public static bool ImGuiTextFilterIsActive(global::DearImguiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterIsActive(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiTextRange ImGuiTextRangeImGuiTextRangeNil()
        {
            var __ret = __Internal.ImGuiTextRangeImGuiTextRangeNil();
            var __result0 = global::DearImguiSharp.ImGuiTextRange.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTextRange_destroy(global::DearImguiSharp.ImGuiTextRange self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextRange_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTextRange ImGuiTextRangeImGuiTextRangeStr(string _b, string _e)
        {
            var __ret = __Internal.ImGuiTextRangeImGuiTextRangeStr(_b, _e);
            var __result0 = global::DearImguiSharp.ImGuiTextRange.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool ImGuiTextRange_empty(global::DearImguiSharp.ImGuiTextRange self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextRange_empty(__arg0);
            return __ret;
        }

        public static void ImGuiTextRange_split(global::DearImguiSharp.ImGuiTextRange self, sbyte separator, global::DearImguiSharp.ImVectorImGuiTextRange @out)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg2 = @out is null ? __IntPtr.Zero : @out.__Instance;
            __Internal.ImGuiTextRange_split(__arg0, separator, __arg2);
        }

        public static global::DearImguiSharp.ImGuiTextBuffer ImGuiTextBufferImGuiTextBuffer()
        {
            var __ret = __Internal.ImGuiTextBufferImGuiTextBuffer();
            var __result0 = global::DearImguiSharp.ImGuiTextBuffer.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTextBuffer_destroy(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_destroy(__arg0);
        }

        public static string ImGuiTextBuffer_begin(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_begin(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string ImGuiTextBuffer_end(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_end(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int ImGuiTextBuffer_size(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_size(__arg0);
            return __ret;
        }

        public static bool ImGuiTextBuffer_empty(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_empty(__arg0);
            return __ret;
        }

        public static void ImGuiTextBuffer_clear(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_clear(__arg0);
        }

        public static void ImGuiTextBuffer_reserve(global::DearImguiSharp.ImGuiTextBuffer self, int capacity)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_reserve(__arg0, capacity);
        }

        public static string ImGuiTextBuffer_c_str(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_c_str(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImGuiTextBuffer_append(global::DearImguiSharp.ImGuiTextBuffer self, string str, string str_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_append(__arg0, str, str_end);
        }

        public static global::DearImguiSharp.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairInt(uint _key, int _val_i)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairInt(_key, _val_i);
            var __result0 = global::DearImguiSharp.ImGuiStoragePair.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStoragePair_destroy(global::DearImguiSharp.ImGuiStoragePair self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStoragePair_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairFloat(uint _key, float _val_f)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairFloat(_key, _val_f);
            var __result0 = global::DearImguiSharp.ImGuiStoragePair.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairPtr(uint _key, __IntPtr _val_p)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairPtr(_key, _val_p);
            var __result0 = global::DearImguiSharp.ImGuiStoragePair.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStorageClear(global::DearImguiSharp.ImGuiStorage self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageClear(__arg0);
        }

        public static int ImGuiStorageGetInt(global::DearImguiSharp.ImGuiStorage self, uint key, int default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetInt(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetInt(global::DearImguiSharp.ImGuiStorage self, uint key, int val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetInt(__arg0, key, val);
        }

        public static bool ImGuiStorageGetBool(global::DearImguiSharp.ImGuiStorage self, uint key, bool default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetBool(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetBool(global::DearImguiSharp.ImGuiStorage self, uint key, bool val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetBool(__arg0, key, val);
        }

        public static float ImGuiStorageGetFloat(global::DearImguiSharp.ImGuiStorage self, uint key, float default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetFloat(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetFloat(global::DearImguiSharp.ImGuiStorage self, uint key, float val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetFloat(__arg0, key, val);
        }

        public static __IntPtr ImGuiStorageGetVoidPtr(global::DearImguiSharp.ImGuiStorage self, uint key)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetVoidPtr(__arg0, key);
            return __ret;
        }

        public static void ImGuiStorageSetVoidPtr(global::DearImguiSharp.ImGuiStorage self, uint key, __IntPtr val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetVoidPtr(__arg0, key, val);
        }

        public static int* ImGuiStorageGetIntRef(global::DearImguiSharp.ImGuiStorage self, uint key, int default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetIntRef(__arg0, key, default_val);
            return __ret;
        }

        public static bool* ImGuiStorageGetBoolRef(global::DearImguiSharp.ImGuiStorage self, uint key, bool default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetBoolRef(__arg0, key, default_val);
            return __ret;
        }

        public static float* ImGuiStorageGetFloatRef(global::DearImguiSharp.ImGuiStorage self, uint key, float default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetFloatRef(__arg0, key, default_val);
            return __ret;
        }

        public static void** ImGuiStorageGetVoidPtrRef(global::DearImguiSharp.ImGuiStorage self, uint key, __IntPtr default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetVoidPtrRef(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetAllInt(global::DearImguiSharp.ImGuiStorage self, int val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetAllInt(__arg0, val);
        }

        public static void ImGuiStorageBuildSortByKey(global::DearImguiSharp.ImGuiStorage self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageBuildSortByKey(__arg0);
        }

        public static global::DearImguiSharp.ImGuiListClipper ImGuiListClipperImGuiListClipper()
        {
            var __ret = __Internal.ImGuiListClipperImGuiListClipper();
            var __result0 = global::DearImguiSharp.ImGuiListClipper.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiListClipper_destroy(global::DearImguiSharp.ImGuiListClipper self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipper_destroy(__arg0);
        }

        public static void ImGuiListClipperBegin(global::DearImguiSharp.ImGuiListClipper self, int items_count, float items_height)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperBegin(__arg0, items_count, items_height);
        }

        public static void ImGuiListClipperEnd(global::DearImguiSharp.ImGuiListClipper self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperEnd(__arg0);
        }

        public static bool ImGuiListClipperStep(global::DearImguiSharp.ImGuiListClipper self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiListClipperStep(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImColor ImColorImColorNil()
        {
            var __ret = __Internal.ImColorImColorNil();
            var __result0 = global::DearImguiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImColor_destroy(global::DearImguiSharp.ImColor self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImColor_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImColor ImColorImColorInt(int r, int g, int b, int a)
        {
            var __ret = __Internal.ImColorImColorInt(r, g, b, a);
            var __result0 = global::DearImguiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImColor ImColorImColorU32(uint rgba)
        {
            var __ret = __Internal.ImColorImColorU32(rgba);
            var __result0 = global::DearImguiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImColor ImColorImColorFloat(float r, float g, float b, float a)
        {
            var __ret = __Internal.ImColorImColorFloat(r, g, b, a);
            var __result0 = global::DearImguiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImColor ImColorImColorVec4(global::DearImguiSharp.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            var __ret = __Internal.ImColorImColorVec4(__arg0);
            var __result0 = global::DearImguiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImColorSetHSV(global::DearImguiSharp.ImColor self, float h, float s, float v, float a)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImColorSetHSV(__arg0, h, s, v, a);
        }

        public static void ImColorHSV(global::DearImguiSharp.ImColor pOut, float h, float s, float v, float a)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.ImColorHSV(__arg0, h, s, v, a);
        }

        public static global::DearImguiSharp.ImDrawCmd ImDrawCmdImDrawCmd()
        {
            var __ret = __Internal.ImDrawCmdImDrawCmd();
            var __result0 = global::DearImguiSharp.ImDrawCmd.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawCmd_destroy(global::DearImguiSharp.ImDrawCmd self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawCmd_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImDrawListSplitter ImDrawListSplitterImDrawListSplitter()
        {
            var __ret = __Internal.ImDrawListSplitterImDrawListSplitter();
            var __result0 = global::DearImguiSharp.ImDrawListSplitter.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawListSplitter_destroy(global::DearImguiSharp.ImDrawListSplitter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitter_destroy(__arg0);
        }

        public static void ImDrawListSplitterClear(global::DearImguiSharp.ImDrawListSplitter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitterClear(__arg0);
        }

        public static void ImDrawListSplitterClearFreeMemory(global::DearImguiSharp.ImDrawListSplitter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitterClearFreeMemory(__arg0);
        }

        public static void ImDrawListSplitterSplit(global::DearImguiSharp.ImDrawListSplitter self, global::DearImguiSharp.ImDrawList draw_list, int count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterSplit(__arg0, __arg1, count);
        }

        public static void ImDrawListSplitterMerge(global::DearImguiSharp.ImDrawListSplitter self, global::DearImguiSharp.ImDrawList draw_list)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterMerge(__arg0, __arg1);
        }

        public static void ImDrawListSplitterSetCurrentChannel(global::DearImguiSharp.ImDrawListSplitter self, global::DearImguiSharp.ImDrawList draw_list, int channel_idx)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterSetCurrentChannel(__arg0, __arg1, channel_idx);
        }

        public static global::DearImguiSharp.ImDrawList ImDrawListImDrawList(global::DearImguiSharp.ImDrawListSharedData shared_data)
        {
            var __arg0 = shared_data is null ? __IntPtr.Zero : shared_data.__Instance;
            var __ret = __Internal.ImDrawListImDrawList(__arg0);
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawList_destroy(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawList_destroy(__arg0);
        }

        public static void ImDrawListPushClipRect(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 clip_rect_min, global::DearImguiSharp.ImVec2 clip_rect_max, bool intersect_with_current_clip_rect)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(clip_rect_min, null))
                throw new global::System.ArgumentNullException("clip_rect_min", "Cannot be null because it is passed by value.");
            var __arg1 = clip_rect_min.__Instance;
            if (ReferenceEquals(clip_rect_max, null))
                throw new global::System.ArgumentNullException("clip_rect_max", "Cannot be null because it is passed by value.");
            var __arg2 = clip_rect_max.__Instance;
            __Internal.ImDrawListPushClipRect(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, intersect_with_current_clip_rect);
        }

        public static void ImDrawListPushClipRectFullScreen(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPushClipRectFullScreen(__arg0);
        }

        public static void ImDrawListPopClipRect(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPopClipRect(__arg0);
        }

        public static void ImDrawListPushTextureID(global::DearImguiSharp.ImDrawList self, __IntPtr texture_id)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPushTextureID(__arg0, texture_id);
        }

        public static void ImDrawListPopTextureID(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPopTextureID(__arg0);
        }

        public static void ImDrawListGetClipRectMin(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListGetClipRectMin(__arg0, __arg1);
        }

        public static void ImDrawListGetClipRectMax(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListGetClipRectMax(__arg0, __arg1);
        }

        public static void ImDrawListAddLine(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, uint col, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            __Internal.ImDrawListAddLine(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col, thickness);
        }

        public static void ImDrawListAddRect(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, uint col, float rounding, int rounding_corners, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRect(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col, rounding, rounding_corners, thickness);
        }

        public static void ImDrawListAddRectFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, uint col, float rounding, int rounding_corners)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRectFilled(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col, rounding, rounding_corners);
        }

        public static void ImDrawListAddRectFilledMultiColor(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, uint col_upr_left, uint col_upr_right, uint col_bot_right, uint col_bot_left)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRectFilledMultiColor(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
        }

        public static void ImDrawListAddQuad(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, uint col, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddQuad(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, col, thickness);
        }

        public static void ImDrawListAddQuadFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddQuadFilled(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, col);
        }

        public static void ImDrawListAddTriangle(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, uint col, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImDrawListAddTriangle(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col, thickness);
        }

        public static void ImDrawListAddTriangleFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImDrawListAddTriangleFilled(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col);
        }

        public static void ImDrawListAddCircle(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, uint col, int num_segments, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddCircle(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments, thickness);
        }

        public static void ImDrawListAddCircleFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, uint col, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddCircleFilled(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments);
        }

        public static void ImDrawListAddNgon(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, uint col, int num_segments, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddNgon(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments, thickness);
        }

        public static void ImDrawListAddNgonFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, uint col, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddNgonFilled(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments);
        }

        public static void ImDrawListAddTextVec2(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 pos, uint col, string text_begin, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListAddTextVec2(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, col, text_begin, text_end);
        }

        public static void ImDrawListAddTextFontPtr(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImFont font, float font_size, global::DearImguiSharp.ImVec2 pos, uint col, string text_begin, string text_end, float wrap_width, global::DearImguiSharp.ImVec4 cpu_fine_clip_rect)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font is null ? __IntPtr.Zero : font.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            var __arg8 = cpu_fine_clip_rect is null ? __IntPtr.Zero : cpu_fine_clip_rect.__Instance;
            __Internal.ImDrawListAddTextFontPtr(__arg0, __arg1, font_size, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col, text_begin, text_end, wrap_width, __arg8);
        }

        public static void ImDrawListAddPolyline(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 points, int num_points, uint col, bool closed, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = points is null ? __IntPtr.Zero : points.__Instance;
            __Internal.ImDrawListAddPolyline(__arg0, __arg1, num_points, col, closed, thickness);
        }

        public static void ImDrawListAddConvexPolyFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 points, int num_points, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = points is null ? __IntPtr.Zero : points.__Instance;
            __Internal.ImDrawListAddConvexPolyFilled(__arg0, __arg1, num_points, col);
        }

        public static void ImDrawListAddBezierCubic(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, uint col, float thickness, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddBezierCubic(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, col, thickness, num_segments);
        }

        public static void ImDrawListAddBezierQuadratic(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, uint col, float thickness, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImDrawListAddBezierQuadratic(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col, thickness, num_segments);
        }

        public static void ImDrawListAddImage(global::DearImguiSharp.ImDrawList self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, global::DearImguiSharp.ImVec2 uv_min, global::DearImguiSharp.ImVec2 uv_max, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg2 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg3 = p_max.__Instance;
            if (ReferenceEquals(uv_min, null))
                throw new global::System.ArgumentNullException("uv_min", "Cannot be null because it is passed by value.");
            var __arg4 = uv_min.__Instance;
            if (ReferenceEquals(uv_max, null))
                throw new global::System.ArgumentNullException("uv_max", "Cannot be null because it is passed by value.");
            var __arg5 = uv_max.__Instance;
            __Internal.ImDrawListAddImage(__arg0, user_texture_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, col);
        }

        public static void ImDrawListAddImageQuad(global::DearImguiSharp.ImDrawList self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, global::DearImguiSharp.ImVec2 uv1, global::DearImguiSharp.ImVec2 uv2, global::DearImguiSharp.ImVec2 uv3, global::DearImguiSharp.ImVec2 uv4, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg2 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg3 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg4 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg5 = p4.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg6 = uv1.__Instance;
            if (ReferenceEquals(uv2, null))
                throw new global::System.ArgumentNullException("uv2", "Cannot be null because it is passed by value.");
            var __arg7 = uv2.__Instance;
            if (ReferenceEquals(uv3, null))
                throw new global::System.ArgumentNullException("uv3", "Cannot be null because it is passed by value.");
            var __arg8 = uv3.__Instance;
            if (ReferenceEquals(uv4, null))
                throw new global::System.ArgumentNullException("uv4", "Cannot be null because it is passed by value.");
            var __arg9 = uv4.__Instance;
            __Internal.ImDrawListAddImageQuad(__arg0, user_texture_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, *(global::DearImguiSharp.ImVec2.__Internal*) __arg6, *(global::DearImguiSharp.ImVec2.__Internal*) __arg7, *(global::DearImguiSharp.ImVec2.__Internal*) __arg8, *(global::DearImguiSharp.ImVec2.__Internal*) __arg9, col);
        }

        public static void ImDrawListAddImageRounded(global::DearImguiSharp.ImDrawList self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, global::DearImguiSharp.ImVec2 uv_min, global::DearImguiSharp.ImVec2 uv_max, uint col, float rounding, int rounding_corners)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg2 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg3 = p_max.__Instance;
            if (ReferenceEquals(uv_min, null))
                throw new global::System.ArgumentNullException("uv_min", "Cannot be null because it is passed by value.");
            var __arg4 = uv_min.__Instance;
            if (ReferenceEquals(uv_max, null))
                throw new global::System.ArgumentNullException("uv_max", "Cannot be null because it is passed by value.");
            var __arg5 = uv_max.__Instance;
            __Internal.ImDrawListAddImageRounded(__arg0, user_texture_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, col, rounding, rounding_corners);
        }

        public static void ImDrawListPathClear(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathClear(__arg0);
        }

        public static void ImDrawListPathLineTo(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 pos)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListPathLineTo(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImDrawListPathLineToMergeDuplicate(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 pos)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListPathLineToMergeDuplicate(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImDrawListPathFillConvex(global::DearImguiSharp.ImDrawList self, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathFillConvex(__arg0, col);
        }

        public static void ImDrawListPathStroke(global::DearImguiSharp.ImDrawList self, uint col, bool closed, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathStroke(__arg0, col, closed, thickness);
        }

        public static void ImDrawListPathArcTo(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, float a_min, float a_max, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcTo(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, a_min, a_max, num_segments);
        }

        public static void ImDrawListPathArcToFast(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, int a_min_of_12, int a_max_of_12)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcToFast(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, a_min_of_12, a_max_of_12);
        }

        public static void ImDrawListPathBezierCubicCurveTo(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg2 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg3 = p4.__Instance;
            __Internal.ImDrawListPathBezierCubicCurveTo(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, num_segments);
        }

        public static void ImDrawListPathBezierQuadraticCurveTo(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg2 = p3.__Instance;
            __Internal.ImDrawListPathBezierQuadraticCurveTo(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, num_segments);
        }

        public static void ImDrawListPathRect(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 rect_min, global::DearImguiSharp.ImVec2 rect_max, float rounding, int rounding_corners)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(rect_min, null))
                throw new global::System.ArgumentNullException("rect_min", "Cannot be null because it is passed by value.");
            var __arg1 = rect_min.__Instance;
            if (ReferenceEquals(rect_max, null))
                throw new global::System.ArgumentNullException("rect_max", "Cannot be null because it is passed by value.");
            var __arg2 = rect_max.__Instance;
            __Internal.ImDrawListPathRect(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, rounding, rounding_corners);
        }

        public static void ImDrawListAddCallback(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImDrawCallback callback, __IntPtr callback_data)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.ImDrawListAddCallback(__arg0, __arg1, callback_data);
        }

        public static void ImDrawListAddDrawCmd(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListAddDrawCmd(__arg0);
        }

        public static global::DearImguiSharp.ImDrawList ImDrawListCloneOutput(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImDrawListCloneOutput(__arg0);
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawListChannelsSplit(global::DearImguiSharp.ImDrawList self, int count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsSplit(__arg0, count);
        }

        public static void ImDrawListChannelsMerge(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsMerge(__arg0);
        }

        public static void ImDrawListChannelsSetCurrent(global::DearImguiSharp.ImDrawList self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsSetCurrent(__arg0, n);
        }

        public static void ImDrawListPrimReserve(global::DearImguiSharp.ImDrawList self, int idx_count, int vtx_count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimReserve(__arg0, idx_count, vtx_count);
        }

        public static void ImDrawListPrimUnreserve(global::DearImguiSharp.ImDrawList self, int idx_count, int vtx_count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimUnreserve(__arg0, idx_count, vtx_count);
        }

        public static void ImDrawListPrimRect(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            __Internal.ImDrawListPrimRect(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListPrimRectUV(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, global::DearImguiSharp.ImVec2 uv_a, global::DearImguiSharp.ImVec2 uv_b, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is passed by value.");
            var __arg3 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is passed by value.");
            var __arg4 = uv_b.__Instance;
            __Internal.ImDrawListPrimRectUV(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, col);
        }

        public static void ImDrawListPrimQuadUV(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, global::DearImguiSharp.ImVec2 c, global::DearImguiSharp.ImVec2 d, global::DearImguiSharp.ImVec2 uv_a, global::DearImguiSharp.ImVec2 uv_b, global::DearImguiSharp.ImVec2 uv_c, global::DearImguiSharp.ImVec2 uv_d, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg3 = c.__Instance;
            if (ReferenceEquals(d, null))
                throw new global::System.ArgumentNullException("d", "Cannot be null because it is passed by value.");
            var __arg4 = d.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is passed by value.");
            var __arg5 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is passed by value.");
            var __arg6 = uv_b.__Instance;
            if (ReferenceEquals(uv_c, null))
                throw new global::System.ArgumentNullException("uv_c", "Cannot be null because it is passed by value.");
            var __arg7 = uv_c.__Instance;
            if (ReferenceEquals(uv_d, null))
                throw new global::System.ArgumentNullException("uv_d", "Cannot be null because it is passed by value.");
            var __arg8 = uv_d.__Instance;
            __Internal.ImDrawListPrimQuadUV(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, *(global::DearImguiSharp.ImVec2.__Internal*) __arg6, *(global::DearImguiSharp.ImVec2.__Internal*) __arg7, *(global::DearImguiSharp.ImVec2.__Internal*) __arg8, col);
        }

        public static void ImDrawListPrimWriteVtx(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 pos, global::DearImguiSharp.ImVec2 uv, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is passed by value.");
            var __arg2 = uv.__Instance;
            __Internal.ImDrawListPrimWriteVtx(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListPrimWriteIdx(global::DearImguiSharp.ImDrawList self, ushort idx)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimWriteIdx(__arg0, idx);
        }

        public static void ImDrawListPrimVtx(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 pos, global::DearImguiSharp.ImVec2 uv, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is passed by value.");
            var __arg2 = uv.__Instance;
            __Internal.ImDrawListPrimVtx(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListResetForNewFrame(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListResetForNewFrame(__arg0);
        }

        public static void ImDrawListClearFreeMemory(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListClearFreeMemory(__arg0);
        }

        public static void ImDrawListPopUnusedDrawCmd(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPopUnusedDrawCmd(__arg0);
        }

        public static void ImDrawListOnChangedClipRect(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListOnChangedClipRect(__arg0);
        }

        public static void ImDrawListOnChangedTextureID(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListOnChangedTextureID(__arg0);
        }

        public static void ImDrawListOnChangedVtxOffset(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListOnChangedVtxOffset(__arg0);
        }

        public static global::DearImguiSharp.ImDrawData ImDrawDataImDrawData()
        {
            var __ret = __Internal.ImDrawDataImDrawData();
            var __result0 = global::DearImguiSharp.ImDrawData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawData_destroy(global::DearImguiSharp.ImDrawData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawData_destroy(__arg0);
        }

        public static void ImDrawDataClear(global::DearImguiSharp.ImDrawData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataClear(__arg0);
        }

        public static void ImDrawDataDeIndexAllBuffers(global::DearImguiSharp.ImDrawData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataDeIndexAllBuffers(__arg0);
        }

        public static void ImDrawDataScaleClipRects(global::DearImguiSharp.ImDrawData self, global::DearImguiSharp.ImVec2 fb_scale)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(fb_scale, null))
                throw new global::System.ArgumentNullException("fb_scale", "Cannot be null because it is passed by value.");
            var __arg1 = fb_scale.__Instance;
            __Internal.ImDrawDataScaleClipRects(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static global::DearImguiSharp.ImFontConfig ImFontConfigImFontConfig()
        {
            var __ret = __Internal.ImFontConfigImFontConfig();
            var __result0 = global::DearImguiSharp.ImFontConfig.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontConfig_destroy(global::DearImguiSharp.ImFontConfig self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontConfig_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImFontGlyphRangesBuilder ImFontGlyphRangesBuilderImFontGlyphRangesBuilder()
        {
            var __ret = __Internal.ImFontGlyphRangesBuilderImFontGlyphRangesBuilder();
            var __result0 = global::DearImguiSharp.ImFontGlyphRangesBuilder.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontGlyphRangesBuilder_destroy(global::DearImguiSharp.ImFontGlyphRangesBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilder_destroy(__arg0);
        }

        public static void ImFontGlyphRangesBuilderClear(global::DearImguiSharp.ImFontGlyphRangesBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderClear(__arg0);
        }

        public static bool ImFontGlyphRangesBuilderGetBit(global::DearImguiSharp.ImFontGlyphRangesBuilder self, IntPtr n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGlyphRangesBuilderGetBit(__arg0, n);
            return __ret;
        }

        public static void ImFontGlyphRangesBuilderSetBit(global::DearImguiSharp.ImFontGlyphRangesBuilder self, IntPtr n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderSetBit(__arg0, n);
        }

        public static void ImFontGlyphRangesBuilderAddChar(global::DearImguiSharp.ImFontGlyphRangesBuilder self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderAddChar(__arg0, c);
        }

        public static void ImFontGlyphRangesBuilderAddText(global::DearImguiSharp.ImFontGlyphRangesBuilder self, string text, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderAddText(__arg0, text, text_end);
        }

        public static void ImFontGlyphRangesBuilderAddRanges(global::DearImguiSharp.ImFontGlyphRangesBuilder self, ref ushort ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            fixed (ushort* __ranges1 = &ranges)
            {
                var __arg1 = __ranges1;
                __Internal.ImFontGlyphRangesBuilderAddRanges(__arg0, __arg1);
            }
        }

        public static void ImFontGlyphRangesBuilderBuildRanges(global::DearImguiSharp.ImFontGlyphRangesBuilder self, global::DearImguiSharp.ImVectorImWchar out_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = out_ranges is null ? __IntPtr.Zero : out_ranges.__Instance;
            __Internal.ImFontGlyphRangesBuilderBuildRanges(__arg0, __arg1);
        }

        public static global::DearImguiSharp.ImFontAtlasCustomRect ImFontAtlasCustomRectImFontAtlasCustomRect()
        {
            var __ret = __Internal.ImFontAtlasCustomRectImFontAtlasCustomRect();
            var __result0 = global::DearImguiSharp.ImFontAtlasCustomRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontAtlasCustomRect_destroy(global::DearImguiSharp.ImFontAtlasCustomRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasCustomRect_destroy(__arg0);
        }

        public static bool ImFontAtlasCustomRectIsPacked(global::DearImguiSharp.ImFontAtlasCustomRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasCustomRectIsPacked(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImFontAtlas ImFontAtlasImFontAtlas()
        {
            var __ret = __Internal.ImFontAtlasImFontAtlas();
            var __result0 = global::DearImguiSharp.ImFontAtlas.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontAtlas_destroy(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlas_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFont(global::DearImguiSharp.ImFontAtlas self, global::DearImguiSharp.ImFontConfig font_cfg)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            var __ret = __Internal.ImFontAtlasAddFont(__arg0, __arg1);
            var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFontDefault(global::DearImguiSharp.ImFontAtlas self, global::DearImguiSharp.ImFontConfig font_cfg)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            var __ret = __Internal.ImFontAtlasAddFontDefault(__arg0, __arg1);
            var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFontFromFileTTF(global::DearImguiSharp.ImFontAtlas self, string filename, float size_pixels, global::DearImguiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg3 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges4 = &glyph_ranges)
            {
                var __arg4 = __glyph_ranges4;
                var __ret = __Internal.ImFontAtlasAddFontFromFileTTF(__arg0, filename, size_pixels, __arg3, __arg4);
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFontFromMemoryTTF(global::DearImguiSharp.ImFontAtlas self, __IntPtr font_data, int font_size, float size_pixels, global::DearImguiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg4 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges5 = &glyph_ranges)
            {
                var __arg5 = __glyph_ranges5;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryTTF(__arg0, font_data, font_size, size_pixels, __arg4, __arg5);
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFontFromMemoryCompressedTTF(global::DearImguiSharp.ImFontAtlas self, __IntPtr compressed_font_data, int compressed_font_size, float size_pixels, global::DearImguiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg4 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges5 = &glyph_ranges)
            {
                var __arg5 = __glyph_ranges5;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryCompressedTTF(__arg0, compressed_font_data, compressed_font_size, size_pixels, __arg4, __arg5);
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFontFromMemoryCompressedBase85TTF(global::DearImguiSharp.ImFontAtlas self, string compressed_font_data_base85, float size_pixels, global::DearImguiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg3 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges4 = &glyph_ranges)
            {
                var __arg4 = __glyph_ranges4;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryCompressedBase85TTF(__arg0, compressed_font_data_base85, size_pixels, __arg3, __arg4);
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static void ImFontAtlasClearInputData(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearInputData(__arg0);
        }

        public static void ImFontAtlasClearTexData(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearTexData(__arg0);
        }

        public static void ImFontAtlasClearFonts(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearFonts(__arg0);
        }

        public static void ImFontAtlasClear(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClear(__arg0);
        }

        public static bool ImFontAtlasBuild(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasBuild(__arg0);
            return __ret;
        }

        public static void ImFontAtlasGetTexDataAsAlpha8(global::DearImguiSharp.ImFontAtlas self, byte** out_pixels, ref int out_width, ref int out_height, ref int out_bytes_per_pixel)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            fixed (int* __out_width2 = &out_width)
            {
                var __arg2 = __out_width2;
                fixed (int* __out_height3 = &out_height)
                {
                    var __arg3 = __out_height3;
                    fixed (int* __out_bytes_per_pixel4 = &out_bytes_per_pixel)
                    {
                        var __arg4 = __out_bytes_per_pixel4;
                        __Internal.ImFontAtlasGetTexDataAsAlpha8(__arg0, out_pixels, __arg2, __arg3, __arg4);
                    }
                }
            }
        }

        public static void ImFontAtlasGetTexDataAsRGBA32(global::DearImguiSharp.ImFontAtlas self, byte** out_pixels, ref int out_width, ref int out_height, ref int out_bytes_per_pixel)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            fixed (int* __out_width2 = &out_width)
            {
                var __arg2 = __out_width2;
                fixed (int* __out_height3 = &out_height)
                {
                    var __arg3 = __out_height3;
                    fixed (int* __out_bytes_per_pixel4 = &out_bytes_per_pixel)
                    {
                        var __arg4 = __out_bytes_per_pixel4;
                        __Internal.ImFontAtlasGetTexDataAsRGBA32(__arg0, out_pixels, __arg2, __arg3, __arg4);
                    }
                }
            }
        }

        public static bool ImFontAtlasIsBuilt(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasIsBuilt(__arg0);
            return __ret;
        }

        public static void ImFontAtlasSetTexID(global::DearImguiSharp.ImFontAtlas self, __IntPtr id)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasSetTexID(__arg0, id);
        }

        public static ushort* ImFontAtlasGetGlyphRangesDefault(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesDefault(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesKorean(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesKorean(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesJapanese(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesJapanese(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesChineseFull(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesChineseFull(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesCyrillic(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesCyrillic(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesThai(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesThai(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesVietnamese(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesVietnamese(__arg0);
            return __ret;
        }

        public static int ImFontAtlasAddCustomRectRegular(global::DearImguiSharp.ImFontAtlas self, int width, int height)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasAddCustomRectRegular(__arg0, width, height);
            return __ret;
        }

        public static int ImFontAtlasAddCustomRectFontGlyph(global::DearImguiSharp.ImFontAtlas self, global::DearImguiSharp.ImFont font, ushort id, int width, int height, float advance_x, global::DearImguiSharp.ImVec2 offset)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font is null ? __IntPtr.Zero : font.__Instance;
            if (ReferenceEquals(offset, null))
                throw new global::System.ArgumentNullException("offset", "Cannot be null because it is passed by value.");
            var __arg6 = offset.__Instance;
            var __ret = __Internal.ImFontAtlasAddCustomRectFontGlyph(__arg0, __arg1, id, width, height, advance_x, *(global::DearImguiSharp.ImVec2.__Internal*) __arg6);
            return __ret;
        }

        public static global::DearImguiSharp.ImFontAtlasCustomRect ImFontAtlasGetCustomRectByIndex(global::DearImguiSharp.ImFontAtlas self, int index)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetCustomRectByIndex(__arg0, index);
            var __result0 = global::DearImguiSharp.ImFontAtlasCustomRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontAtlasCalcCustomRectUV(global::DearImguiSharp.ImFontAtlas self, global::DearImguiSharp.ImFontAtlasCustomRect rect, global::DearImguiSharp.ImVec2 out_uv_min, global::DearImguiSharp.ImVec2 out_uv_max)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var __arg2 = out_uv_min is null ? __IntPtr.Zero : out_uv_min.__Instance;
            var __arg3 = out_uv_max is null ? __IntPtr.Zero : out_uv_max.__Instance;
            __Internal.ImFontAtlasCalcCustomRectUV(__arg0, __arg1, __arg2, __arg3);
        }

        public static bool ImFontAtlasGetMouseCursorTexData(global::DearImguiSharp.ImFontAtlas self, int cursor, global::DearImguiSharp.ImVec2 out_offset, global::DearImguiSharp.ImVec2 out_size, global::DearImguiSharp.ImVec2[] out_uv_border, global::DearImguiSharp.ImVec2[] out_uv_fill)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg2 = out_offset is null ? __IntPtr.Zero : out_offset.__Instance;
            var __arg3 = out_size is null ? __IntPtr.Zero : out_size.__Instance;
            if (out_uv_border == null || out_uv_border.Length != 2)
                throw new ArgumentOutOfRangeException("out_uv_border", "The dimensions of the provided array don't match the required size.");
            global::DearImguiSharp.ImVec2.__Internal[] __out_uv_border;
            if (out_uv_border is null)
                __out_uv_border = null;
            else
            {
                __out_uv_border = new global::DearImguiSharp.ImVec2.__Internal[out_uv_border.Length];
                for (int i = 0; i < __out_uv_border.Length; i++)
                {
                    var __element = out_uv_border[i];
                    __out_uv_border[i] = __element is null ? new global::DearImguiSharp.ImVec2.__Internal() : *(global::DearImguiSharp.ImVec2.__Internal*) __element.__Instance;
                }
            }
            var __arg4 = __out_uv_border;
            if (out_uv_fill == null || out_uv_fill.Length != 2)
                throw new ArgumentOutOfRangeException("out_uv_fill", "The dimensions of the provided array don't match the required size.");
            global::DearImguiSharp.ImVec2.__Internal[] __out_uv_fill;
            if (out_uv_fill is null)
                __out_uv_fill = null;
            else
            {
                __out_uv_fill = new global::DearImguiSharp.ImVec2.__Internal[out_uv_fill.Length];
                for (int i = 0; i < __out_uv_fill.Length; i++)
                {
                    var __element = out_uv_fill[i];
                    __out_uv_fill[i] = __element is null ? new global::DearImguiSharp.ImVec2.__Internal() : *(global::DearImguiSharp.ImVec2.__Internal*) __element.__Instance;
                }
            }
            var __arg5 = __out_uv_fill;
            var __ret = __Internal.ImFontAtlasGetMouseCursorTexData(__arg0, cursor, __arg2, __arg3, __arg4, __arg5);
            return __ret;
        }

        public static global::DearImguiSharp.ImFont ImFontImFont()
        {
            var __ret = __Internal.ImFontImFont();
            var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFont_destroy(global::DearImguiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFont_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImFontGlyph ImFontFindGlyph(global::DearImguiSharp.ImFont self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontFindGlyph(__arg0, c);
            var __result0 = global::DearImguiSharp.ImFontGlyph.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImFontGlyph ImFontFindGlyphNoFallback(global::DearImguiSharp.ImFont self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontFindGlyphNoFallback(__arg0, c);
            var __result0 = global::DearImguiSharp.ImFontGlyph.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static float ImFontGetCharAdvance(global::DearImguiSharp.ImFont self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGetCharAdvance(__arg0, c);
            return __ret;
        }

        public static bool ImFontIsLoaded(global::DearImguiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontIsLoaded(__arg0);
            return __ret;
        }

        public static string ImFontGetDebugName(global::DearImguiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGetDebugName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImFontCalcTextSizeA(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImFont self, float size, float max_width, float wrap_width, string text_begin, string text_end, sbyte** remaining)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontCalcTextSizeA(__arg0, __arg1, size, max_width, wrap_width, text_begin, text_end, remaining);
        }

        public static string ImFontCalcWordWrapPositionA(global::DearImguiSharp.ImFont self, float scale, string text, string text_end, float wrap_width)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontCalcWordWrapPositionA(__arg0, scale, text, text_end, wrap_width);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImFontRenderChar(global::DearImguiSharp.ImFont self, global::DearImguiSharp.ImDrawList draw_list, float size, global::DearImguiSharp.ImVec2 pos, uint col, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            __Internal.ImFontRenderChar(__arg0, __arg1, size, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col, c);
        }

        public static void ImFontRenderText(global::DearImguiSharp.ImFont self, global::DearImguiSharp.ImDrawList draw_list, float size, global::DearImguiSharp.ImVec2 pos, uint col, global::DearImguiSharp.ImVec4 clip_rect, string text_begin, string text_end, float wrap_width, bool cpu_fine_clip)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            if (ReferenceEquals(clip_rect, null))
                throw new global::System.ArgumentNullException("clip_rect", "Cannot be null because it is passed by value.");
            var __arg5 = clip_rect.__Instance;
            __Internal.ImFontRenderText(__arg0, __arg1, size, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col, __arg5, text_begin, text_end, wrap_width, cpu_fine_clip);
        }

        public static void ImFontBuildLookupTable(global::DearImguiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontBuildLookupTable(__arg0);
        }

        public static void ImFontClearOutputData(global::DearImguiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontClearOutputData(__arg0);
        }

        public static void ImFontGrowIndex(global::DearImguiSharp.ImFont self, int new_size)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGrowIndex(__arg0, new_size);
        }

        public static void ImFontAddGlyph(global::DearImguiSharp.ImFont self, global::DearImguiSharp.ImFontConfig src_cfg, ushort c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = src_cfg is null ? __IntPtr.Zero : src_cfg.__Instance;
            __Internal.ImFontAddGlyph(__arg0, __arg1, c, x0, y0, x1, y1, u0, v0, u1, v1, advance_x);
        }

        public static void ImFontAddRemapChar(global::DearImguiSharp.ImFont self, ushort dst, ushort src, bool overwrite_dst)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAddRemapChar(__arg0, dst, src, overwrite_dst);
        }

        public static void ImFontSetGlyphVisible(global::DearImguiSharp.ImFont self, ushort c, bool visible)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontSetGlyphVisible(__arg0, c, visible);
        }

        public static void ImFontSetFallbackChar(global::DearImguiSharp.ImFont self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontSetFallbackChar(__arg0, c);
        }

        public static bool ImFontIsGlyphRangeUnused(global::DearImguiSharp.ImFont self, uint c_begin, uint c_last)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontIsGlyphRangeUnused(__arg0, c_begin, c_last);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiViewport ImGuiViewportImGuiViewport()
        {
            var __ret = __Internal.ImGuiViewportImGuiViewport();
            var __result0 = global::DearImguiSharp.ImGuiViewport.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiViewport_destroy(global::DearImguiSharp.ImGuiViewport self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewport_destroy(__arg0);
        }

        public static void ImGuiViewportGetCenter(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImGuiViewport self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportGetCenter(__arg0, __arg1);
        }

        public static void ImGuiViewportGetWorkCenter(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImGuiViewport self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportGetWorkCenter(__arg0, __arg1);
        }

        /// <summary>//////////////////////hand written functions</summary>
        public static void LogText(string fmt)
        {
            __Internal.LogText(fmt);
        }

        public static float GET_FLT_MAX()
        {
            var __ret = __Internal.GET_FLT_MAX();
            return __ret;
        }

        public static float GET_FLT_MIN()
        {
            var __ret = __Internal.GET_FLT_MIN();
            return __ret;
        }

        public static global::DearImguiSharp.ImVectorImWchar ImVectorImWchar_create()
        {
            var __ret = __Internal.ImVectorImWchar_create();
            var __result0 = global::DearImguiSharp.ImVectorImWchar.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVectorImWchar_destroy(global::DearImguiSharp.ImVectorImWchar self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVectorImWchar_destroy(__arg0);
        }

        public static void ImVectorImWcharInit(global::DearImguiSharp.ImVectorImWchar p)
        {
            var __arg0 = p is null ? __IntPtr.Zero : p.__Instance;
            __Internal.ImVectorImWcharInit(__arg0);
        }

        public static void ImVectorImWcharUnInit(global::DearImguiSharp.ImVectorImWchar p)
        {
            var __arg0 = p is null ? __IntPtr.Zero : p.__Instance;
            __Internal.ImVectorImWcharUnInit(__arg0);
        }
    }

    public unsafe partial class ID3D11DeviceContext
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ID3D11DeviceContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ID3D11DeviceContext>();

        protected bool __ownsNativeInstance;

        internal static ID3D11DeviceContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ID3D11DeviceContext(native.ToPointer(), skipVTables);
        }

        internal static ID3D11DeviceContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ID3D11DeviceContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ID3D11DeviceContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ID3D11DeviceContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ID3D11DeviceContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ID3D11DeviceContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ID3D11Device
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ID3D11Device> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.ID3D11Device>();

        protected bool __ownsNativeInstance;

        internal static ID3D11Device __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ID3D11Device(native.ToPointer(), skipVTables);
        }

        internal static ID3D11Device __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ID3D11Device)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ID3D11Device __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ID3D11Device(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ID3D11Device(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ID3D11Device(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class IDirect3DDevice9
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.IDirect3DDevice9> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::DearImguiSharp.IDirect3DDevice9>();

        protected bool __ownsNativeInstance;

        internal static IDirect3DDevice9 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new IDirect3DDevice9(native.ToPointer(), skipVTables);
        }

        internal static IDirect3DDevice9 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (IDirect3DDevice9)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static IDirect3DDevice9 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IDirect3DDevice9(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IDirect3DDevice9(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public IDirect3DDevice9(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImGui
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplWin32_Init", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplWin32Init(__IntPtr hwnd);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplWin32_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplWin32Shutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplWin32_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplWin32NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplWin32_EnableDpiAwareness", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplWin32EnableDpiAwareness();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplWin32_GetDpiScaleForHwnd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiImplWin32GetDpiScaleForHwnd(__IntPtr hwnd);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplWin32_GetDpiScaleForMonitor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiImplWin32GetDpiScaleForMonitor(__IntPtr monitor);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX9_Init", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplDX9Init(__IntPtr device);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX9_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX9Shutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX9_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX9NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX9_RenderDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX9RenderDrawData(__IntPtr draw_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX9_CreateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplDX9CreateDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX9_InvalidateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX9InvalidateDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX11_Init", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplDX11Init(__IntPtr device, __IntPtr device_context);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX11_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX11Shutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX11_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX11NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX11_RenderDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX11RenderDrawData(__IntPtr draw_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX11_InvalidateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX11InvalidateDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui.dll", EntryPoint = "ImGui_ImplDX11_CreateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplDX11CreateDeviceObjects();
        }

        public static bool ImGuiImplWin32Init(__IntPtr hwnd)
        {
            var __ret = __Internal.ImGuiImplWin32Init(hwnd);
            return __ret;
        }

        public static void ImGuiImplWin32Shutdown()
        {
            __Internal.ImGuiImplWin32Shutdown();
        }

        public static void ImGuiImplWin32NewFrame()
        {
            __Internal.ImGuiImplWin32NewFrame();
        }

        public static void ImGuiImplWin32EnableDpiAwareness()
        {
            __Internal.ImGuiImplWin32EnableDpiAwareness();
        }

        public static float ImGuiImplWin32GetDpiScaleForHwnd(__IntPtr hwnd)
        {
            var __ret = __Internal.ImGuiImplWin32GetDpiScaleForHwnd(hwnd);
            return __ret;
        }

        public static float ImGuiImplWin32GetDpiScaleForMonitor(__IntPtr monitor)
        {
            var __ret = __Internal.ImGuiImplWin32GetDpiScaleForMonitor(monitor);
            return __ret;
        }

        public static bool ImGuiImplDX9Init(global::DearImguiSharp.IDirect3DDevice9 device)
        {
            var __arg0 = device is null ? __IntPtr.Zero : device.__Instance;
            var __ret = __Internal.ImGuiImplDX9Init(__arg0);
            return __ret;
        }

        public static void ImGuiImplDX9Shutdown()
        {
            __Internal.ImGuiImplDX9Shutdown();
        }

        public static void ImGuiImplDX9NewFrame()
        {
            __Internal.ImGuiImplDX9NewFrame();
        }

        public static void ImGuiImplDX9RenderDrawData(global::DearImguiSharp.ImDrawData draw_data)
        {
            var __arg0 = draw_data is null ? __IntPtr.Zero : draw_data.__Instance;
            __Internal.ImGuiImplDX9RenderDrawData(__arg0);
        }

        public static bool ImGuiImplDX9CreateDeviceObjects()
        {
            var __ret = __Internal.ImGuiImplDX9CreateDeviceObjects();
            return __ret;
        }

        public static void ImGuiImplDX9InvalidateDeviceObjects()
        {
            __Internal.ImGuiImplDX9InvalidateDeviceObjects();
        }

        public static bool ImGuiImplDX11Init(global::DearImguiSharp.ID3D11Device device, global::DearImguiSharp.ID3D11DeviceContext device_context)
        {
            var __arg0 = device is null ? __IntPtr.Zero : device.__Instance;
            var __arg1 = device_context is null ? __IntPtr.Zero : device_context.__Instance;
            var __ret = __Internal.ImGuiImplDX11Init(__arg0, __arg1);
            return __ret;
        }

        public static void ImGuiImplDX11Shutdown()
        {
            __Internal.ImGuiImplDX11Shutdown();
        }

        public static void ImGuiImplDX11NewFrame()
        {
            __Internal.ImGuiImplDX11NewFrame();
        }

        public static void ImGuiImplDX11RenderDrawData(global::DearImguiSharp.ImDrawData draw_data)
        {
            var __arg0 = draw_data is null ? __IntPtr.Zero : draw_data.__Instance;
            __Internal.ImGuiImplDX11RenderDrawData(__arg0);
        }

        public static void ImGuiImplDX11InvalidateDeviceObjects()
        {
            __Internal.ImGuiImplDX11InvalidateDeviceObjects();
        }

        public static bool ImGuiImplDX11CreateDeviceObjects()
        {
            var __ret = __Internal.ImGuiImplDX11CreateDeviceObjects();
            return __ret;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr__MarshalAs_UnmanagedType_CustomMarshaler__MarshalTypeRef___typeof_CppSharp_Runtime_UTF8Marshaller____string(__IntPtr user_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_int_int(int x, int y);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        public unsafe delegate bool Func_bool___IntPtr_int_sbytePtrPtr(__IntPtr data, int idx, sbyte** out_text);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate float Func_float___IntPtr_int(__IntPtr data, int idx);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr_IntPtr___IntPtr(IntPtr sz, __IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr(__IntPtr ptr, __IntPtr user_data);
    }
}
